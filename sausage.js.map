{
  "version": 3,
  "sources": ["../node_modules/.pnpm/ogl@1.0.3/node_modules/ogl/src/math/functions/Vec3Func.js", "../node_modules/.pnpm/ogl@1.0.3/node_modules/ogl/src/math/Vec3.js", "../node_modules/.pnpm/ogl@1.0.3/node_modules/ogl/src/core/Geometry.js", "../node_modules/.pnpm/ogl@1.0.3/node_modules/ogl/src/core/Program.js", "../node_modules/.pnpm/ogl@1.0.3/node_modules/ogl/src/core/Renderer.js", "../node_modules/.pnpm/ogl@1.0.3/node_modules/ogl/src/math/functions/Vec4Func.js", "../node_modules/.pnpm/ogl@1.0.3/node_modules/ogl/src/math/functions/QuatFunc.js", "../node_modules/.pnpm/ogl@1.0.3/node_modules/ogl/src/math/Quat.js", "../node_modules/.pnpm/ogl@1.0.3/node_modules/ogl/src/math/functions/Mat4Func.js", "../node_modules/.pnpm/ogl@1.0.3/node_modules/ogl/src/math/Mat4.js", "../node_modules/.pnpm/ogl@1.0.3/node_modules/ogl/src/math/functions/EulerFunc.js", "../node_modules/.pnpm/ogl@1.0.3/node_modules/ogl/src/math/Euler.js", "../node_modules/.pnpm/ogl@1.0.3/node_modules/ogl/src/core/Transform.js", "../node_modules/.pnpm/ogl@1.0.3/node_modules/ogl/src/core/Camera.js", "../node_modules/.pnpm/ogl@1.0.3/node_modules/ogl/src/math/functions/Mat3Func.js", "../node_modules/.pnpm/ogl@1.0.3/node_modules/ogl/src/math/Mat3.js", "../node_modules/.pnpm/ogl@1.0.3/node_modules/ogl/src/core/Mesh.js", "../node_modules/.pnpm/ogl@1.0.3/node_modules/ogl/src/core/Texture.js", "../node_modules/.pnpm/ogl@1.0.3/node_modules/ogl/src/math/functions/Vec2Func.js", "../node_modules/.pnpm/ogl@1.0.3/node_modules/ogl/src/math/Vec2.js", "../node_modules/.pnpm/ogl@1.0.3/node_modules/ogl/src/math/Vec4.js", "../node_modules/.pnpm/ogl@1.0.3/node_modules/ogl/src/extras/Plane.js", "../node_modules/.pnpm/ogl@1.0.3/node_modules/ogl/src/extras/Box.js", "../node_modules/.pnpm/ogl@1.0.3/node_modules/ogl/src/extras/Sphere.js", "../node_modules/.pnpm/ogl@1.0.3/node_modules/ogl/src/extras/Orbit.js", "../node_modules/.pnpm/ogl@1.0.3/node_modules/ogl/src/extras/NormalProgram.js", "../node_modules/.pnpm/ogl@1.0.3/node_modules/ogl/src/extras/GLTFAnimation.js", "../node_modules/.pnpm/ogl@1.0.3/node_modules/ogl/src/extras/GLTFSkin.js", "../node_modules/.pnpm/ogl@1.0.3/node_modules/ogl/src/extras/InstancedMesh.js", "../node_modules/.pnpm/ogl@1.0.3/node_modules/ogl/src/extras/GLTFLoader.js", "../skybox.js", "../shaders/physDebug.vert", "../shaders/physDebug.frag", "../physdebug.js", "../abstract.js", "../../rapier.js/rapier3d/pkg/rapier_wasm3d_bg.js", "wasm-module:/home/albatross/src/rapier.js/rapier3d/pkg/rapier_wasm3d_bg.wasm", "../../rapier.js/rapier3d/pkg/src/math.ts", "../../rapier.js/rapier3d/pkg/src/dynamics/rigid_body.ts", "../../rapier.js/rapier3d/pkg/src/coarena.ts", "../../rapier.js/rapier3d/pkg/src/dynamics/rigid_body_set.ts", "../../rapier.js/rapier3d/pkg/src/dynamics/integration_parameters.ts", "../../rapier.js/rapier3d/pkg/src/dynamics/impulse_joint.ts", "../../rapier.js/rapier3d/pkg/src/dynamics/impulse_joint_set.ts", "../../rapier.js/rapier3d/pkg/src/dynamics/multibody_joint.ts", "../../rapier.js/rapier3d/pkg/src/dynamics/multibody_joint_set.ts", "../../rapier.js/rapier3d/pkg/src/dynamics/coefficient_combine_rule.ts", "../../rapier.js/rapier3d/pkg/src/dynamics/ccd_solver.ts", "../../rapier.js/rapier3d/pkg/src/dynamics/island_manager.ts", "../../rapier.js/rapier3d/pkg/src/geometry/broad_phase.ts", "../../rapier.js/rapier3d/pkg/src/geometry/narrow_phase.ts", "../../rapier.js/rapier3d/pkg/src/geometry/contact.ts", "../../rapier.js/rapier3d/pkg/src/geometry/feature.ts", "../../rapier.js/rapier3d/pkg/src/geometry/point.ts", "../../rapier.js/rapier3d/pkg/src/geometry/ray.ts", "../../rapier.js/rapier3d/pkg/src/geometry/toi.ts", "../../rapier.js/rapier3d/pkg/src/geometry/shape.ts", "../../rapier.js/rapier3d/pkg/src/pipeline/physics_pipeline.ts", "../../rapier.js/rapier3d/pkg/src/pipeline/query_pipeline.ts", "../../rapier.js/rapier3d/pkg/src/pipeline/serialization_pipeline.ts", "../../rapier.js/rapier3d/pkg/src/pipeline/debug_render_pipeline.ts", "../../rapier.js/rapier3d/pkg/src/control/character_controller.ts", "../../rapier.js/rapier3d/pkg/src/control/ray_cast_vehicle_controller.ts", "../../rapier.js/rapier3d/pkg/src/pipeline/world.ts", "../../rapier.js/rapier3d/pkg/src/pipeline/event_queue.ts", "../../rapier.js/rapier3d/pkg/src/pipeline/physics_hooks.ts", "../../rapier.js/rapier3d/pkg/src/geometry/collider.ts", "../../rapier.js/rapier3d/pkg/src/geometry/collider_set.ts", "../physics.js", "../ui.js", "../shaders/main.vert", "../shaders/main.frag", "../shaders/skin.vert", "../shaders/skin.frag", "../index.js"],
  "sourcesContent": ["const EPSILON = 0.000001;\n\n/**\n * Calculates the length of a vec3\n *\n * @param {vec3} a vector to calculate length of\n * @returns {Number} length of a\n */\nexport function length(a) {\n    let x = a[0];\n    let y = a[1];\n    let z = a[2];\n    return Math.sqrt(x * x + y * y + z * z);\n}\n\n/**\n * Copy the values from one vec3 to another\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the source vector\n * @returns {vec3} out\n */\nexport function copy(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    return out;\n}\n\n/**\n * Set the components of a vec3 to the given values\n *\n * @param {vec3} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} out\n */\nexport function set(out, x, y, z) {\n    out[0] = x;\n    out[1] = y;\n    out[2] = z;\n    return out;\n}\n\n/**\n * Adds two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nexport function add(out, a, b) {\n    out[0] = a[0] + b[0];\n    out[1] = a[1] + b[1];\n    out[2] = a[2] + b[2];\n    return out;\n}\n\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nexport function subtract(out, a, b) {\n    out[0] = a[0] - b[0];\n    out[1] = a[1] - b[1];\n    out[2] = a[2] - b[2];\n    return out;\n}\n\n/**\n * Multiplies two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nexport function multiply(out, a, b) {\n    out[0] = a[0] * b[0];\n    out[1] = a[1] * b[1];\n    out[2] = a[2] * b[2];\n    return out;\n}\n\n/**\n * Divides two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nexport function divide(out, a, b) {\n    out[0] = a[0] / b[0];\n    out[1] = a[1] / b[1];\n    out[2] = a[2] / b[2];\n    return out;\n}\n\n/**\n * Scales a vec3 by a scalar number\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec3} out\n */\nexport function scale(out, a, b) {\n    out[0] = a[0] * b;\n    out[1] = a[1] * b;\n    out[2] = a[2] * b;\n    return out;\n}\n\n/**\n * Calculates the euclidian distance between two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} distance between a and b\n */\nexport function distance(a, b) {\n    let x = b[0] - a[0];\n    let y = b[1] - a[1];\n    let z = b[2] - a[2];\n    return Math.sqrt(x * x + y * y + z * z);\n}\n\n/**\n * Calculates the squared euclidian distance between two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} squared distance between a and b\n */\nexport function squaredDistance(a, b) {\n    let x = b[0] - a[0];\n    let y = b[1] - a[1];\n    let z = b[2] - a[2];\n    return x * x + y * y + z * z;\n}\n\n/**\n * Calculates the squared length of a vec3\n *\n * @param {vec3} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\nexport function squaredLength(a) {\n    let x = a[0];\n    let y = a[1];\n    let z = a[2];\n    return x * x + y * y + z * z;\n}\n\n/**\n * Negates the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to negate\n * @returns {vec3} out\n */\nexport function negate(out, a) {\n    out[0] = -a[0];\n    out[1] = -a[1];\n    out[2] = -a[2];\n    return out;\n}\n\n/**\n * Returns the inverse of the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to invert\n * @returns {vec3} out\n */\nexport function inverse(out, a) {\n    out[0] = 1.0 / a[0];\n    out[1] = 1.0 / a[1];\n    out[2] = 1.0 / a[2];\n    return out;\n}\n\n/**\n * Normalize a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to normalize\n * @returns {vec3} out\n */\nexport function normalize(out, a) {\n    let x = a[0];\n    let y = a[1];\n    let z = a[2];\n    let len = x * x + y * y + z * z;\n    if (len > 0) {\n        //TODO: evaluate use of glm_invsqrt here?\n        len = 1 / Math.sqrt(len);\n    }\n    out[0] = a[0] * len;\n    out[1] = a[1] * len;\n    out[2] = a[2] * len;\n    return out;\n}\n\n/**\n * Calculates the dot product of two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} dot product of a and b\n */\nexport function dot(a, b) {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n\n/**\n * Computes the cross product of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nexport function cross(out, a, b) {\n    let ax = a[0],\n        ay = a[1],\n        az = a[2];\n    let bx = b[0],\n        by = b[1],\n        bz = b[2];\n\n    out[0] = ay * bz - az * by;\n    out[1] = az * bx - ax * bz;\n    out[2] = ax * by - ay * bx;\n    return out;\n}\n\n/**\n * Performs a linear interpolation between two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {vec3} out\n */\nexport function lerp(out, a, b, t) {\n    let ax = a[0];\n    let ay = a[1];\n    let az = a[2];\n    out[0] = ax + t * (b[0] - ax);\n    out[1] = ay + t * (b[1] - ay);\n    out[2] = az + t * (b[2] - az);\n    return out;\n}\n\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly '1'\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {mat4} m matrix to transform with\n * @returns {vec3} out\n */\nexport function transformMat4(out, a, m) {\n    let x = a[0],\n        y = a[1],\n        z = a[2];\n    let w = m[3] * x + m[7] * y + m[11] * z + m[15];\n    w = w || 1.0;\n    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n    return out;\n}\n\n/**\n * Same as above but doesn't apply translation.\n * Useful for rays.\n */\nexport function scaleRotateMat4(out, a, m) {\n    let x = a[0],\n        y = a[1],\n        z = a[2];\n    let w = m[3] * x + m[7] * y + m[11] * z + m[15];\n    w = w || 1.0;\n    out[0] = (m[0] * x + m[4] * y + m[8] * z) / w;\n    out[1] = (m[1] * x + m[5] * y + m[9] * z) / w;\n    out[2] = (m[2] * x + m[6] * y + m[10] * z) / w;\n    return out;\n}\n\n/**\n * Transforms the vec3 with a mat3.\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {mat3} m the 3x3 matrix to transform with\n * @returns {vec3} out\n */\nexport function transformMat3(out, a, m) {\n    let x = a[0],\n        y = a[1],\n        z = a[2];\n    out[0] = x * m[0] + y * m[3] + z * m[6];\n    out[1] = x * m[1] + y * m[4] + z * m[7];\n    out[2] = x * m[2] + y * m[5] + z * m[8];\n    return out;\n}\n\n/**\n * Transforms the vec3 with a quat\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {quat} q quaternion to transform with\n * @returns {vec3} out\n */\nexport function transformQuat(out, a, q) {\n    // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed\n\n    let x = a[0],\n        y = a[1],\n        z = a[2];\n    let qx = q[0],\n        qy = q[1],\n        qz = q[2],\n        qw = q[3];\n\n    let uvx = qy * z - qz * y;\n    let uvy = qz * x - qx * z;\n    let uvz = qx * y - qy * x;\n\n    let uuvx = qy * uvz - qz * uvy;\n    let uuvy = qz * uvx - qx * uvz;\n    let uuvz = qx * uvy - qy * uvx;\n\n    let w2 = qw * 2;\n    uvx *= w2;\n    uvy *= w2;\n    uvz *= w2;\n\n    uuvx *= 2;\n    uuvy *= 2;\n    uuvz *= 2;\n\n    out[0] = x + uvx + uuvx;\n    out[1] = y + uvy + uuvy;\n    out[2] = z + uvz + uuvz;\n    return out;\n}\n\n/**\n * Get the angle between two 3D vectors\n * @param {vec3} a The first operand\n * @param {vec3} b The second operand\n * @returns {Number} The angle in radians\n */\nexport const angle = (function () {\n    const tempA = [0, 0, 0];\n    const tempB = [0, 0, 0];\n\n    return function (a, b) {\n        copy(tempA, a);\n        copy(tempB, b);\n\n        normalize(tempA, tempA);\n        normalize(tempB, tempB);\n\n        let cosine = dot(tempA, tempB);\n\n        if (cosine > 1.0) {\n            return 0;\n        } else if (cosine < -1.0) {\n            return Math.PI;\n        } else {\n            return Math.acos(cosine);\n        }\n    };\n})();\n\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {vec3} a The first vector.\n * @param {vec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nexport function exactEquals(a, b) {\n    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n}\n", "import * as Vec3Func from './functions/Vec3Func.js';\n\nexport class Vec3 extends Array {\n    constructor(x = 0, y = x, z = x) {\n        super(x, y, z);\n        return this;\n    }\n\n    get x() {\n        return this[0];\n    }\n\n    get y() {\n        return this[1];\n    }\n\n    get z() {\n        return this[2];\n    }\n\n    set x(v) {\n        this[0] = v;\n    }\n\n    set y(v) {\n        this[1] = v;\n    }\n\n    set z(v) {\n        this[2] = v;\n    }\n\n    set(x, y = x, z = x) {\n        if (x.length) return this.copy(x);\n        Vec3Func.set(this, x, y, z);\n        return this;\n    }\n\n    copy(v) {\n        Vec3Func.copy(this, v);\n        return this;\n    }\n\n    add(va, vb) {\n        if (vb) Vec3Func.add(this, va, vb);\n        else Vec3Func.add(this, this, va);\n        return this;\n    }\n\n    sub(va, vb) {\n        if (vb) Vec3Func.subtract(this, va, vb);\n        else Vec3Func.subtract(this, this, va);\n        return this;\n    }\n\n    multiply(v) {\n        if (v.length) Vec3Func.multiply(this, this, v);\n        else Vec3Func.scale(this, this, v);\n        return this;\n    }\n\n    divide(v) {\n        if (v.length) Vec3Func.divide(this, this, v);\n        else Vec3Func.scale(this, this, 1 / v);\n        return this;\n    }\n\n    inverse(v = this) {\n        Vec3Func.inverse(this, v);\n        return this;\n    }\n\n    // Can't use 'length' as Array.prototype uses it\n    len() {\n        return Vec3Func.length(this);\n    }\n\n    distance(v) {\n        if (v) return Vec3Func.distance(this, v);\n        else return Vec3Func.length(this);\n    }\n\n    squaredLen() {\n        return Vec3Func.squaredLength(this);\n    }\n\n    squaredDistance(v) {\n        if (v) return Vec3Func.squaredDistance(this, v);\n        else return Vec3Func.squaredLength(this);\n    }\n\n    negate(v = this) {\n        Vec3Func.negate(this, v);\n        return this;\n    }\n\n    cross(va, vb) {\n        if (vb) Vec3Func.cross(this, va, vb);\n        else Vec3Func.cross(this, this, va);\n        return this;\n    }\n\n    scale(v) {\n        Vec3Func.scale(this, this, v);\n        return this;\n    }\n\n    normalize() {\n        Vec3Func.normalize(this, this);\n        return this;\n    }\n\n    dot(v) {\n        return Vec3Func.dot(this, v);\n    }\n\n    equals(v) {\n        return Vec3Func.exactEquals(this, v);\n    }\n\n    applyMatrix3(mat3) {\n        Vec3Func.transformMat3(this, this, mat3);\n        return this;\n    }\n\n    applyMatrix4(mat4) {\n        Vec3Func.transformMat4(this, this, mat4);\n        return this;\n    }\n\n    scaleRotateMatrix4(mat4) {\n        Vec3Func.scaleRotateMat4(this, this, mat4);\n        return this;\n    }\n\n    applyQuaternion(q) {\n        Vec3Func.transformQuat(this, this, q);\n        return this;\n    }\n\n    angle(v) {\n        return Vec3Func.angle(this, v);\n    }\n\n    lerp(v, t) {\n        Vec3Func.lerp(this, this, v, t);\n        return this;\n    }\n\n    clone() {\n        return new Vec3(this[0], this[1], this[2]);\n    }\n\n    fromArray(a, o = 0) {\n        this[0] = a[o];\n        this[1] = a[o + 1];\n        this[2] = a[o + 2];\n        return this;\n    }\n\n    toArray(a = [], o = 0) {\n        a[o] = this[0];\n        a[o + 1] = this[1];\n        a[o + 2] = this[2];\n        return a;\n    }\n\n    transformDirection(mat4) {\n        const x = this[0];\n        const y = this[1];\n        const z = this[2];\n\n        this[0] = mat4[0] * x + mat4[4] * y + mat4[8] * z;\n        this[1] = mat4[1] * x + mat4[5] * y + mat4[9] * z;\n        this[2] = mat4[2] * x + mat4[6] * y + mat4[10] * z;\n\n        return this.normalize();\n    }\n}\n", "// attribute params\n// {\n//     data - typed array eg UInt16Array for indices, Float32Array\n//     size - int default 1\n//     instanced - default null. Pass divisor amount\n//     type - gl enum default gl.UNSIGNED_SHORT for 'index', gl.FLOAT for others\n//     normalized - boolean default false\n\n//     buffer - gl buffer, if buffer exists, don't need to provide data - although needs position data for bounds calculation\n//     stride - default 0 - for when passing in buffer\n//     offset - default 0 - for when passing in buffer\n//     count - default null - for when passing in buffer\n//     min - array - for when passing in buffer\n//     max - array - for when passing in buffer\n// }\n\n// TODO: fit in transform feedback\n\nimport { Vec3 } from '../math/Vec3.js';\n\nconst tempVec3 = /* @__PURE__ */ new Vec3();\n\nlet ID = 1;\nlet ATTR_ID = 1;\n\n// To stop inifinite warnings\nlet isBoundsWarned = false;\n\nexport class Geometry {\n    constructor(gl, attributes = {}) {\n        if (!gl.canvas) console.error('gl not passed as first argument to Geometry');\n        this.gl = gl;\n        this.attributes = attributes;\n        this.id = ID++;\n\n        // Store one VAO per program attribute locations order\n        this.VAOs = {};\n\n        this.drawRange = { start: 0, count: 0 };\n        this.instancedCount = 0;\n\n        // Unbind current VAO so that new buffers don't get added to active mesh\n        this.gl.renderer.bindVertexArray(null);\n        this.gl.renderer.currentGeometry = null;\n\n        // Alias for state store to avoid redundant calls for global state\n        this.glState = this.gl.renderer.state;\n\n        // create the buffers\n        for (let key in attributes) {\n            this.addAttribute(key, attributes[key]);\n        }\n    }\n\n    addAttribute(key, attr) {\n        this.attributes[key] = attr;\n\n        // Set options\n        attr.id = ATTR_ID++; // TODO: currently unused, remove?\n        attr.size = attr.size || 1;\n        attr.type =\n            attr.type ||\n            (attr.data.constructor === Float32Array\n                ? this.gl.FLOAT\n                : attr.data.constructor === Uint16Array\n                ? this.gl.UNSIGNED_SHORT\n                : this.gl.UNSIGNED_INT); // Uint32Array\n        attr.target = key === 'index' ? this.gl.ELEMENT_ARRAY_BUFFER : this.gl.ARRAY_BUFFER;\n        attr.normalized = attr.normalized || false;\n        attr.stride = attr.stride || 0;\n        attr.offset = attr.offset || 0;\n        attr.count = attr.count || (attr.stride ? attr.data.byteLength / attr.stride : attr.data.length / attr.size);\n        attr.divisor = attr.instanced || 0;\n        attr.needsUpdate = false;\n        attr.usage = attr.usage || this.gl.STATIC_DRAW;\n\n        if (!attr.buffer) {\n            // Push data to buffer\n            this.updateAttribute(attr);\n        }\n\n        // Update geometry counts. If indexed, ignore regular attributes\n        if (attr.divisor) {\n            this.isInstanced = true;\n            if (this.instancedCount && this.instancedCount !== attr.count * attr.divisor) {\n                console.warn('geometry has multiple instanced buffers of different length');\n                return (this.instancedCount = Math.min(this.instancedCount, attr.count * attr.divisor));\n            }\n            this.instancedCount = attr.count * attr.divisor;\n        } else if (key === 'index') {\n            this.drawRange.count = attr.count;\n        } else if (!this.attributes.index) {\n            this.drawRange.count = Math.max(this.drawRange.count, attr.count);\n        }\n    }\n\n    updateAttribute(attr) {\n        const isNewBuffer = !attr.buffer;\n        if (isNewBuffer) attr.buffer = this.gl.createBuffer();\n        if (this.glState.boundBuffer !== attr.buffer) {\n            this.gl.bindBuffer(attr.target, attr.buffer);\n            this.glState.boundBuffer = attr.buffer;\n        }\n        if (isNewBuffer) {\n            this.gl.bufferData(attr.target, attr.data, attr.usage);\n        } else {\n            this.gl.bufferSubData(attr.target, 0, attr.data);\n        }\n        attr.needsUpdate = false;\n    }\n\n    setIndex(value) {\n        this.addAttribute('index', value);\n    }\n\n    setDrawRange(start, count) {\n        this.drawRange.start = start;\n        this.drawRange.count = count;\n    }\n\n    setInstancedCount(value) {\n        this.instancedCount = value;\n    }\n\n    createVAO(program) {\n        this.VAOs[program.attributeOrder] = this.gl.renderer.createVertexArray();\n        this.gl.renderer.bindVertexArray(this.VAOs[program.attributeOrder]);\n        this.bindAttributes(program);\n    }\n\n    bindAttributes(program) {\n        // Link all attributes to program using gl.vertexAttribPointer\n        program.attributeLocations.forEach((location, { name, type }) => {\n            // If geometry missing a required shader attribute\n            if (!this.attributes[name]) {\n                console.warn(`active attribute ${name} not being supplied`);\n                return;\n            }\n\n            const attr = this.attributes[name];\n\n            this.gl.bindBuffer(attr.target, attr.buffer);\n            this.glState.boundBuffer = attr.buffer;\n\n            // For matrix attributes, buffer needs to be defined per column\n            let numLoc = 1;\n            if (type === 35674) numLoc = 2; // mat2\n            if (type === 35675) numLoc = 3; // mat3\n            if (type === 35676) numLoc = 4; // mat4\n\n            const size = attr.size / numLoc;\n            const stride = numLoc === 1 ? 0 : numLoc * numLoc * 4;\n            const offset = numLoc === 1 ? 0 : numLoc * 4;\n\n            for (let i = 0; i < numLoc; i++) {\n                this.gl.vertexAttribPointer(location + i, size, attr.type, attr.normalized, attr.stride + stride, attr.offset + i * offset);\n                this.gl.enableVertexAttribArray(location + i);\n\n                // For instanced attributes, divisor needs to be set.\n                // For firefox, need to set back to 0 if non-instanced drawn after instanced. Else won't render\n                this.gl.renderer.vertexAttribDivisor(location + i, attr.divisor);\n            }\n        });\n\n        // Bind indices if geometry indexed\n        if (this.attributes.index) this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.attributes.index.buffer);\n    }\n\n    draw({ program, mode = this.gl.TRIANGLES }) {\n        if (this.gl.renderer.currentGeometry !== `${this.id}_${program.attributeOrder}`) {\n            if (!this.VAOs[program.attributeOrder]) this.createVAO(program);\n            this.gl.renderer.bindVertexArray(this.VAOs[program.attributeOrder]);\n            this.gl.renderer.currentGeometry = `${this.id}_${program.attributeOrder}`;\n        }\n\n        // Check if any attributes need updating\n        program.attributeLocations.forEach((location, { name }) => {\n            const attr = this.attributes[name];\n            if (attr.needsUpdate) this.updateAttribute(attr);\n        });\n\n        // For drawElements, offset needs to be multiple of type size\n        let indexBytesPerElement = 2;\n        if (this.attributes.index?.type === this.gl.UNSIGNED_INT) indexBytesPerElement = 4;\n\n        if (this.isInstanced) {\n            if (this.attributes.index) {\n                this.gl.renderer.drawElementsInstanced(\n                    mode,\n                    this.drawRange.count,\n                    this.attributes.index.type,\n                    this.attributes.index.offset + this.drawRange.start * indexBytesPerElement,\n                    this.instancedCount\n                );\n            } else {\n                this.gl.renderer.drawArraysInstanced(mode, this.drawRange.start, this.drawRange.count, this.instancedCount);\n            }\n        } else {\n            if (this.attributes.index) {\n                this.gl.drawElements(\n                    mode,\n                    this.drawRange.count,\n                    this.attributes.index.type,\n                    this.attributes.index.offset + this.drawRange.start * indexBytesPerElement\n                );\n            } else {\n                this.gl.drawArrays(mode, this.drawRange.start, this.drawRange.count);\n            }\n        }\n    }\n\n    getPosition() {\n        // Use position buffer, or min/max if available\n        const attr = this.attributes.position;\n        // if (attr.min) return [...attr.min, ...attr.max];\n        if (attr.data) return attr;\n        if (isBoundsWarned) return;\n        console.warn('No position buffer data found to compute bounds');\n        return (isBoundsWarned = true);\n    }\n\n    computeBoundingBox(attr) {\n        if (!attr) attr = this.getPosition();\n        const array = attr.data;\n        // Data loaded shouldn't haave stride, only buffers\n        // const stride = attr.stride ? attr.stride / array.BYTES_PER_ELEMENT : attr.size;\n        const stride = attr.size;\n\n        if (!this.bounds) {\n            this.bounds = {\n                min: new Vec3(),\n                max: new Vec3(),\n                center: new Vec3(),\n                scale: new Vec3(),\n                radius: Infinity,\n            };\n        }\n\n        const min = this.bounds.min;\n        const max = this.bounds.max;\n        const center = this.bounds.center;\n        const scale = this.bounds.scale;\n\n        min.set(+Infinity);\n        max.set(-Infinity);\n\n        // TODO: check size of position (eg triangle with Vec2)\n        for (let i = 0, l = array.length; i < l; i += stride) {\n            const x = array[i];\n            const y = array[i + 1];\n            const z = array[i + 2];\n\n            min.x = Math.min(x, min.x);\n            min.y = Math.min(y, min.y);\n            min.z = Math.min(z, min.z);\n\n            max.x = Math.max(x, max.x);\n            max.y = Math.max(y, max.y);\n            max.z = Math.max(z, max.z);\n        }\n\n        scale.sub(max, min);\n        center.add(min, max).divide(2);\n    }\n\n    computeBoundingSphere(attr) {\n        if (!attr) attr = this.getPosition();\n        const array = attr.data;\n        // Data loaded shouldn't haave stride, only buffers\n        // const stride = attr.stride ? attr.stride / array.BYTES_PER_ELEMENT : attr.size;\n        const stride = attr.size;\n\n        if (!this.bounds) this.computeBoundingBox(attr);\n\n        let maxRadiusSq = 0;\n        for (let i = 0, l = array.length; i < l; i += stride) {\n            tempVec3.fromArray(array, i);\n            maxRadiusSq = Math.max(maxRadiusSq, this.bounds.center.squaredDistance(tempVec3));\n        }\n\n        this.bounds.radius = Math.sqrt(maxRadiusSq);\n    }\n\n    remove() {\n        for (let key in this.VAOs) {\n            this.gl.renderer.deleteVertexArray(this.VAOs[key]);\n            delete this.VAOs[key];\n        }\n        for (let key in this.attributes) {\n            this.gl.deleteBuffer(this.attributes[key].buffer);\n            delete this.attributes[key];\n        }\n    }\n}\n", "// TODO: upload empty texture if null ? maybe not\n// TODO: upload identity matrix if null ?\n// TODO: sampler Cube\n\nlet ID = 1;\n\n// cache of typed arrays used to flatten uniform arrays\nconst arrayCacheF32 = {};\n\nexport class Program {\n    constructor(\n        gl,\n        {\n            vertex,\n            fragment,\n            uniforms = {},\n\n            transparent = false,\n            cullFace = gl.BACK,\n            frontFace = gl.CCW,\n            depthTest = true,\n            depthWrite = true,\n            depthFunc = gl.LESS,\n        } = {}\n    ) {\n        if (!gl.canvas) console.error('gl not passed as first argument to Program');\n        this.gl = gl;\n        this.uniforms = uniforms;\n        this.id = ID++;\n\n        if (!vertex) console.warn('vertex shader not supplied');\n        if (!fragment) console.warn('fragment shader not supplied');\n\n        // Store program state\n        this.transparent = transparent;\n        this.cullFace = cullFace;\n        this.frontFace = frontFace;\n        this.depthTest = depthTest;\n        this.depthWrite = depthWrite;\n        this.depthFunc = depthFunc;\n        this.blendFunc = {};\n        this.blendEquation = {};\n\n        // set default blendFunc if transparent flagged\n        if (this.transparent && !this.blendFunc.src) {\n            if (this.gl.renderer.premultipliedAlpha) this.setBlendFunc(this.gl.ONE, this.gl.ONE_MINUS_SRC_ALPHA);\n            else this.setBlendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);\n        }\n\n        // compile vertex shader and log errors\n        const vertexShader = gl.createShader(gl.VERTEX_SHADER);\n        gl.shaderSource(vertexShader, vertex);\n        gl.compileShader(vertexShader);\n        if (gl.getShaderInfoLog(vertexShader) !== '') {\n            console.warn(`${gl.getShaderInfoLog(vertexShader)}\\nVertex Shader\\n${addLineNumbers(vertex)}`);\n        }\n\n        // compile fragment shader and log errors\n        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n        gl.shaderSource(fragmentShader, fragment);\n        gl.compileShader(fragmentShader);\n        if (gl.getShaderInfoLog(fragmentShader) !== '') {\n            console.warn(`${gl.getShaderInfoLog(fragmentShader)}\\nFragment Shader\\n${addLineNumbers(fragment)}`);\n        }\n\n        // compile program and log errors\n        this.program = gl.createProgram();\n        gl.attachShader(this.program, vertexShader);\n        gl.attachShader(this.program, fragmentShader);\n        gl.linkProgram(this.program);\n        if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {\n            return console.warn(gl.getProgramInfoLog(this.program));\n        }\n\n        // Remove shader once linked\n        gl.deleteShader(vertexShader);\n        gl.deleteShader(fragmentShader);\n\n        // Get active uniform locations\n        this.uniformLocations = new Map();\n        let numUniforms = gl.getProgramParameter(this.program, gl.ACTIVE_UNIFORMS);\n        for (let uIndex = 0; uIndex < numUniforms; uIndex++) {\n            let uniform = gl.getActiveUniform(this.program, uIndex);\n            this.uniformLocations.set(uniform, gl.getUniformLocation(this.program, uniform.name));\n\n            // split uniforms' names to separate array and struct declarations\n            const split = uniform.name.match(/(\\w+)/g);\n\n            uniform.uniformName = split[0];\n            uniform.nameComponents = split.slice(1);\n        }\n\n        // Get active attribute locations\n        this.attributeLocations = new Map();\n        const locations = [];\n        const numAttribs = gl.getProgramParameter(this.program, gl.ACTIVE_ATTRIBUTES);\n        for (let aIndex = 0; aIndex < numAttribs; aIndex++) {\n            const attribute = gl.getActiveAttrib(this.program, aIndex);\n            const location = gl.getAttribLocation(this.program, attribute.name);\n            // Ignore special built-in inputs. eg gl_VertexID, gl_InstanceID\n            if (location === -1) continue;\n            locations[location] = attribute.name;\n            this.attributeLocations.set(attribute, location);\n        }\n        this.attributeOrder = locations.join('');\n    }\n\n    setBlendFunc(src, dst, srcAlpha, dstAlpha) {\n        this.blendFunc.src = src;\n        this.blendFunc.dst = dst;\n        this.blendFunc.srcAlpha = srcAlpha;\n        this.blendFunc.dstAlpha = dstAlpha;\n        if (src) this.transparent = true;\n    }\n\n    setBlendEquation(modeRGB, modeAlpha) {\n        this.blendEquation.modeRGB = modeRGB;\n        this.blendEquation.modeAlpha = modeAlpha;\n    }\n\n    applyState() {\n        if (this.depthTest) this.gl.renderer.enable(this.gl.DEPTH_TEST);\n        else this.gl.renderer.disable(this.gl.DEPTH_TEST);\n\n        if (this.cullFace) this.gl.renderer.enable(this.gl.CULL_FACE);\n        else this.gl.renderer.disable(this.gl.CULL_FACE);\n\n        if (this.blendFunc.src) this.gl.renderer.enable(this.gl.BLEND);\n        else this.gl.renderer.disable(this.gl.BLEND);\n\n        if (this.cullFace) this.gl.renderer.setCullFace(this.cullFace);\n        this.gl.renderer.setFrontFace(this.frontFace);\n        this.gl.renderer.setDepthMask(this.depthWrite);\n        this.gl.renderer.setDepthFunc(this.depthFunc);\n        if (this.blendFunc.src)\n            this.gl.renderer.setBlendFunc(this.blendFunc.src, this.blendFunc.dst, this.blendFunc.srcAlpha, this.blendFunc.dstAlpha);\n        this.gl.renderer.setBlendEquation(this.blendEquation.modeRGB, this.blendEquation.modeAlpha);\n    }\n\n    use({ flipFaces = false } = {}) {\n        let textureUnit = -1;\n        const programActive = this.gl.renderer.state.currentProgram === this.id;\n\n        // Avoid gl call if program already in use\n        if (!programActive) {\n            this.gl.useProgram(this.program);\n            this.gl.renderer.state.currentProgram = this.id;\n        }\n\n        // Set only the active uniforms found in the shader\n        this.uniformLocations.forEach((location, activeUniform) => {\n            let uniform = this.uniforms[activeUniform.uniformName];\n\n            for (const component of activeUniform.nameComponents) {\n                if (!uniform) break;\n\n                if (component in uniform) {\n                    uniform = uniform[component];\n                } else if (Array.isArray(uniform.value)) {\n                    break;\n                } else {\n                    uniform = undefined;\n                    break;\n                }\n            }\n\n            if (!uniform) {\n                return warn(`Active uniform ${activeUniform.name} has not been supplied`);\n            }\n\n            if (uniform && uniform.value === undefined) {\n                return warn(`${activeUniform.name} uniform is missing a value parameter`);\n            }\n\n            if (uniform.value.texture) {\n                textureUnit = textureUnit + 1;\n\n                // Check if texture needs to be updated\n                uniform.value.update(textureUnit);\n                return setUniform(this.gl, activeUniform.type, location, textureUnit);\n            }\n\n            // For texture arrays, set uniform as an array of texture units instead of just one\n            if (uniform.value.length && uniform.value[0].texture) {\n                const textureUnits = [];\n                uniform.value.forEach((value) => {\n                    textureUnit = textureUnit + 1;\n                    value.update(textureUnit);\n                    textureUnits.push(textureUnit);\n                });\n\n                return setUniform(this.gl, activeUniform.type, location, textureUnits);\n            }\n\n            setUniform(this.gl, activeUniform.type, location, uniform.value);\n        });\n\n        this.applyState();\n        if (flipFaces) this.gl.renderer.setFrontFace(this.frontFace === this.gl.CCW ? this.gl.CW : this.gl.CCW);\n    }\n\n    remove() {\n        this.gl.deleteProgram(this.program);\n    }\n}\n\nfunction setUniform(gl, type, location, value) {\n    value = value.length ? flatten(value) : value;\n    const setValue = gl.renderer.state.uniformLocations.get(location);\n\n    // Avoid redundant uniform commands\n    if (value.length) {\n        if (setValue === undefined || setValue.length !== value.length) {\n            // clone array to store as cache\n            gl.renderer.state.uniformLocations.set(location, value.slice(0));\n        } else {\n            if (arraysEqual(setValue, value)) return;\n\n            // Update cached array values\n            setValue.set ? setValue.set(value) : setArray(setValue, value);\n            gl.renderer.state.uniformLocations.set(location, setValue);\n        }\n    } else {\n        if (setValue === value) return;\n        gl.renderer.state.uniformLocations.set(location, value);\n    }\n\n    switch (type) {\n        case 5126:\n            return value.length ? gl.uniform1fv(location, value) : gl.uniform1f(location, value); // FLOAT\n        case 35664:\n            return gl.uniform2fv(location, value); // FLOAT_VEC2\n        case 35665:\n            return gl.uniform3fv(location, value); // FLOAT_VEC3\n        case 35666:\n            return gl.uniform4fv(location, value); // FLOAT_VEC4\n        case 35670: // BOOL\n        case 5124: // INT\n        case 35678: // SAMPLER_2D\n        case 35680:\n            return value.length ? gl.uniform1iv(location, value) : gl.uniform1i(location, value); // SAMPLER_CUBE\n        case 35671: // BOOL_VEC2\n        case 35667:\n            return gl.uniform2iv(location, value); // INT_VEC2\n        case 35672: // BOOL_VEC3\n        case 35668:\n            return gl.uniform3iv(location, value); // INT_VEC3\n        case 35673: // BOOL_VEC4\n        case 35669:\n            return gl.uniform4iv(location, value); // INT_VEC4\n        case 35674:\n            return gl.uniformMatrix2fv(location, false, value); // FLOAT_MAT2\n        case 35675:\n            return gl.uniformMatrix3fv(location, false, value); // FLOAT_MAT3\n        case 35676:\n            return gl.uniformMatrix4fv(location, false, value); // FLOAT_MAT4\n    }\n}\n\nfunction addLineNumbers(string) {\n    let lines = string.split('\\n');\n    for (let i = 0; i < lines.length; i++) {\n        lines[i] = i + 1 + ': ' + lines[i];\n    }\n    return lines.join('\\n');\n}\n\nfunction flatten(a) {\n    const arrayLen = a.length;\n    const valueLen = a[0].length;\n    if (valueLen === undefined) return a;\n    const length = arrayLen * valueLen;\n    let value = arrayCacheF32[length];\n    if (!value) arrayCacheF32[length] = value = new Float32Array(length);\n    for (let i = 0; i < arrayLen; i++) value.set(a[i], i * valueLen);\n    return value;\n}\n\nfunction arraysEqual(a, b) {\n    if (a.length !== b.length) return false;\n    for (let i = 0, l = a.length; i < l; i++) {\n        if (a[i] !== b[i]) return false;\n    }\n    return true;\n}\n\nfunction setArray(a, b) {\n    for (let i = 0, l = a.length; i < l; i++) {\n        a[i] = b[i];\n    }\n}\n\nlet warnCount = 0;\nfunction warn(message) {\n    if (warnCount > 100) return;\n    console.warn(message);\n    warnCount++;\n    if (warnCount > 100) console.warn('More than 100 program warnings - stopping logs.');\n}\n", "import { Vec3 } from '../math/Vec3.js';\n\n// TODO: Handle context loss https://www.khronos.org/webgl/wiki/HandlingContextLost\n\n// Not automatic - devs to use these methods manually\n// gl.colorMask( colorMask, colorMask, colorMask, colorMask );\n// gl.clearColor( r, g, b, a );\n// gl.stencilMask( stencilMask );\n// gl.stencilFunc( stencilFunc, stencilRef, stencilMask );\n// gl.stencilOp( stencilFail, stencilZFail, stencilZPass );\n// gl.clearStencil( stencil );\n\nconst tempVec3 = /* @__PURE__ */ new Vec3();\nlet ID = 1;\n\nexport class Renderer {\n    constructor({\n        canvas = document.createElement('canvas'),\n        width = 300,\n        height = 150,\n        dpr = 1,\n        alpha = false,\n        depth = true,\n        stencil = false,\n        antialias = false,\n        premultipliedAlpha = false,\n        preserveDrawingBuffer = false,\n        powerPreference = 'default',\n        autoClear = true,\n        webgl = 2,\n    } = {}) {\n        const attributes = { alpha, depth, stencil, antialias, premultipliedAlpha, preserveDrawingBuffer, powerPreference };\n        this.dpr = dpr;\n        this.alpha = alpha;\n        this.color = true;\n        this.depth = depth;\n        this.stencil = stencil;\n        this.premultipliedAlpha = premultipliedAlpha;\n        this.autoClear = autoClear;\n        this.id = ID++;\n\n        // Attempt WebGL2 unless forced to 1, if not supported fallback to WebGL1\n        if (webgl === 2) this.gl = canvas.getContext('webgl2', attributes);\n        this.isWebgl2 = !!this.gl;\n        if (!this.gl) this.gl = canvas.getContext('webgl', attributes);\n        if (!this.gl) console.error('unable to create webgl context');\n\n        // Attach renderer to gl so that all classes have access to internal state functions\n        this.gl.renderer = this;\n\n        // initialise size values\n        this.setSize(width, height);\n\n        // gl state stores to avoid redundant calls on methods used internally\n        this.state = {};\n        this.state.blendFunc = { src: this.gl.ONE, dst: this.gl.ZERO };\n        this.state.blendEquation = { modeRGB: this.gl.FUNC_ADD };\n        this.state.cullFace = false;\n        this.state.frontFace = this.gl.CCW;\n        this.state.depthMask = true;\n        this.state.depthFunc = this.gl.LESS;\n        this.state.premultiplyAlpha = false;\n        this.state.flipY = false;\n        this.state.unpackAlignment = 4;\n        this.state.framebuffer = null;\n        this.state.viewport = { x: 0, y: 0, width: null, height: null };\n        this.state.textureUnits = [];\n        this.state.activeTextureUnit = 0;\n        this.state.boundBuffer = null;\n        this.state.uniformLocations = new Map();\n        this.state.currentProgram = null;\n\n        // store requested extensions\n        this.extensions = {};\n\n        // Initialise extra format types\n        if (this.isWebgl2) {\n            this.getExtension('EXT_color_buffer_float');\n            this.getExtension('OES_texture_float_linear');\n        } else {\n            this.getExtension('OES_texture_float');\n            this.getExtension('OES_texture_float_linear');\n            this.getExtension('OES_texture_half_float');\n            this.getExtension('OES_texture_half_float_linear');\n            this.getExtension('OES_element_index_uint');\n            this.getExtension('OES_standard_derivatives');\n            this.getExtension('EXT_sRGB');\n            this.getExtension('WEBGL_depth_texture');\n            this.getExtension('WEBGL_draw_buffers');\n        }\n        this.getExtension('WEBGL_compressed_texture_astc');\n        this.getExtension('EXT_texture_compression_bptc');\n        this.getExtension('WEBGL_compressed_texture_s3tc');\n        this.getExtension('WEBGL_compressed_texture_etc1');\n        this.getExtension('WEBGL_compressed_texture_pvrtc');\n        this.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');\n\n        // Create method aliases using extension (WebGL1) or native if available (WebGL2)\n        this.vertexAttribDivisor = this.getExtension('ANGLE_instanced_arrays', 'vertexAttribDivisor', 'vertexAttribDivisorANGLE');\n        this.drawArraysInstanced = this.getExtension('ANGLE_instanced_arrays', 'drawArraysInstanced', 'drawArraysInstancedANGLE');\n        this.drawElementsInstanced = this.getExtension('ANGLE_instanced_arrays', 'drawElementsInstanced', 'drawElementsInstancedANGLE');\n        this.createVertexArray = this.getExtension('OES_vertex_array_object', 'createVertexArray', 'createVertexArrayOES');\n        this.bindVertexArray = this.getExtension('OES_vertex_array_object', 'bindVertexArray', 'bindVertexArrayOES');\n        this.deleteVertexArray = this.getExtension('OES_vertex_array_object', 'deleteVertexArray', 'deleteVertexArrayOES');\n        this.drawBuffers = this.getExtension('WEBGL_draw_buffers', 'drawBuffers', 'drawBuffersWEBGL');\n\n        // Store device parameters\n        this.parameters = {};\n        this.parameters.maxTextureUnits = this.gl.getParameter(this.gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);\n        this.parameters.maxAnisotropy = this.getExtension('EXT_texture_filter_anisotropic')\n            ? this.gl.getParameter(this.getExtension('EXT_texture_filter_anisotropic').MAX_TEXTURE_MAX_ANISOTROPY_EXT)\n            : 0;\n    }\n\n    setSize(width, height) {\n        this.width = width;\n        this.height = height;\n\n        this.gl.canvas.width = width * this.dpr;\n        this.gl.canvas.height = height * this.dpr;\n\n        if (!this.gl.canvas.style) return;\n        Object.assign(this.gl.canvas.style, {\n            width: width + 'px',\n            height: height + 'px',\n        });\n    }\n\n    setViewport(width, height, x = 0, y = 0) {\n        if (this.state.viewport.width === width && this.state.viewport.height === height) return;\n        this.state.viewport.width = width;\n        this.state.viewport.height = height;\n        this.state.viewport.x = x;\n        this.state.viewport.y = y;\n        this.gl.viewport(x, y, width, height);\n    }\n\n    setScissor(width, height, x = 0, y = 0) {\n        this.gl.scissor(x, y, width, height);\n    }\n\n    enable(id) {\n        if (this.state[id] === true) return;\n        this.gl.enable(id);\n        this.state[id] = true;\n    }\n\n    disable(id) {\n        if (this.state[id] === false) return;\n        this.gl.disable(id);\n        this.state[id] = false;\n    }\n\n    setBlendFunc(src, dst, srcAlpha, dstAlpha) {\n        if (\n            this.state.blendFunc.src === src &&\n            this.state.blendFunc.dst === dst &&\n            this.state.blendFunc.srcAlpha === srcAlpha &&\n            this.state.blendFunc.dstAlpha === dstAlpha\n        )\n            return;\n        this.state.blendFunc.src = src;\n        this.state.blendFunc.dst = dst;\n        this.state.blendFunc.srcAlpha = srcAlpha;\n        this.state.blendFunc.dstAlpha = dstAlpha;\n        if (srcAlpha !== undefined) this.gl.blendFuncSeparate(src, dst, srcAlpha, dstAlpha);\n        else this.gl.blendFunc(src, dst);\n    }\n\n    setBlendEquation(modeRGB, modeAlpha) {\n        modeRGB = modeRGB || this.gl.FUNC_ADD;\n        if (this.state.blendEquation.modeRGB === modeRGB && this.state.blendEquation.modeAlpha === modeAlpha) return;\n        this.state.blendEquation.modeRGB = modeRGB;\n        this.state.blendEquation.modeAlpha = modeAlpha;\n        if (modeAlpha !== undefined) this.gl.blendEquationSeparate(modeRGB, modeAlpha);\n        else this.gl.blendEquation(modeRGB);\n    }\n\n    setCullFace(value) {\n        if (this.state.cullFace === value) return;\n        this.state.cullFace = value;\n        this.gl.cullFace(value);\n    }\n\n    setFrontFace(value) {\n        if (this.state.frontFace === value) return;\n        this.state.frontFace = value;\n        this.gl.frontFace(value);\n    }\n\n    setDepthMask(value) {\n        if (this.state.depthMask === value) return;\n        this.state.depthMask = value;\n        this.gl.depthMask(value);\n    }\n\n    setDepthFunc(value) {\n        if (this.state.depthFunc === value) return;\n        this.state.depthFunc = value;\n        this.gl.depthFunc(value);\n    }\n\n    activeTexture(value) {\n        if (this.state.activeTextureUnit === value) return;\n        this.state.activeTextureUnit = value;\n        this.gl.activeTexture(this.gl.TEXTURE0 + value);\n    }\n\n    bindFramebuffer({ target = this.gl.FRAMEBUFFER, buffer = null } = {}) {\n        if (this.state.framebuffer === buffer) return;\n        this.state.framebuffer = buffer;\n        this.gl.bindFramebuffer(target, buffer);\n    }\n\n    getExtension(extension, webgl2Func, extFunc) {\n        // if webgl2 function supported, return func bound to gl context\n        if (webgl2Func && this.gl[webgl2Func]) return this.gl[webgl2Func].bind(this.gl);\n\n        // fetch extension once only\n        if (!this.extensions[extension]) {\n            this.extensions[extension] = this.gl.getExtension(extension);\n        }\n\n        // return extension if no function requested\n        if (!webgl2Func) return this.extensions[extension];\n\n        // Return null if extension not supported\n        if (!this.extensions[extension]) return null;\n\n        // return extension function, bound to extension\n        return this.extensions[extension][extFunc].bind(this.extensions[extension]);\n    }\n\n    sortOpaque(a, b) {\n        if (a.renderOrder !== b.renderOrder) {\n            return a.renderOrder - b.renderOrder;\n        } else if (a.program.id !== b.program.id) {\n            return a.program.id - b.program.id;\n        } else if (a.zDepth !== b.zDepth) {\n            return a.zDepth - b.zDepth;\n        } else {\n            return b.id - a.id;\n        }\n    }\n\n    sortTransparent(a, b) {\n        if (a.renderOrder !== b.renderOrder) {\n            return a.renderOrder - b.renderOrder;\n        }\n        if (a.zDepth !== b.zDepth) {\n            return b.zDepth - a.zDepth;\n        } else {\n            return b.id - a.id;\n        }\n    }\n\n    sortUI(a, b) {\n        if (a.renderOrder !== b.renderOrder) {\n            return a.renderOrder - b.renderOrder;\n        } else if (a.program.id !== b.program.id) {\n            return a.program.id - b.program.id;\n        } else {\n            return b.id - a.id;\n        }\n    }\n\n    getRenderList({ scene, camera, frustumCull, sort }) {\n        let renderList = [];\n\n        if (camera && frustumCull) camera.updateFrustum();\n\n        // Get visible\n        scene.traverse((node) => {\n            if (!node.visible) return true;\n            if (!node.draw) return;\n\n            if (frustumCull && node.frustumCulled && camera) {\n                if (!camera.frustumIntersectsMesh(node)) return;\n            }\n\n            renderList.push(node);\n        });\n\n        if (sort) {\n            const opaque = [];\n            const transparent = []; // depthTest true\n            const ui = []; // depthTest false\n\n            renderList.forEach((node) => {\n                // Split into the 3 render groups\n                if (!node.program.transparent) {\n                    opaque.push(node);\n                } else if (node.program.depthTest) {\n                    transparent.push(node);\n                } else {\n                    ui.push(node);\n                }\n\n                node.zDepth = 0;\n\n                // Only calculate z-depth if renderOrder unset and depthTest is true\n                if (node.renderOrder !== 0 || !node.program.depthTest || !camera) return;\n\n                // update z-depth\n                node.worldMatrix.getTranslation(tempVec3);\n                tempVec3.applyMatrix4(camera.projectionViewMatrix);\n                node.zDepth = tempVec3.z;\n            });\n\n            opaque.sort(this.sortOpaque);\n            transparent.sort(this.sortTransparent);\n            ui.sort(this.sortUI);\n\n            renderList = opaque.concat(transparent, ui);\n        }\n\n        return renderList;\n    }\n\n    render({ scene, camera, target = null, update = true, sort = true, frustumCull = true, clear }) {\n        if (target === null) {\n            // make sure no render target bound so draws to canvas\n            this.bindFramebuffer();\n            this.setViewport(this.width * this.dpr, this.height * this.dpr);\n        } else {\n            // bind supplied render target and update viewport\n            this.bindFramebuffer(target);\n            this.setViewport(target.width, target.height);\n        }\n\n        if (clear || (this.autoClear && clear !== false)) {\n            // Ensure depth buffer writing is enabled so it can be cleared\n            if (this.depth && (!target || target.depth)) {\n                this.enable(this.gl.DEPTH_TEST);\n                this.setDepthMask(true);\n            }\n            this.gl.clear(\n                (this.color ? this.gl.COLOR_BUFFER_BIT : 0) |\n                    (this.depth ? this.gl.DEPTH_BUFFER_BIT : 0) |\n                    (this.stencil ? this.gl.STENCIL_BUFFER_BIT : 0)\n            );\n        }\n\n        // updates all scene graph matrices\n        if (update) scene.updateMatrixWorld();\n\n        // Update camera separately, in case not in scene graph\n        if (camera) camera.updateMatrixWorld();\n\n        // Get render list - entails culling and sorting\n        const renderList = this.getRenderList({ scene, camera, frustumCull, sort });\n\n        renderList.forEach((node) => {\n            node.draw({ camera });\n        });\n    }\n}\n", "const EPSILON = 0.000001;\n\n/**\n * Copy the values from one vec4 to another\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the source vector\n * @returns {vec4} out\n */\nexport function copy(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    return out;\n}\n\n/**\n * Set the components of a vec4 to the given values\n *\n * @param {vec4} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {vec4} out\n */\nexport function set(out, x, y, z, w) {\n    out[0] = x;\n    out[1] = y;\n    out[2] = z;\n    out[3] = w;\n    return out;\n}\n\n/**\n * Adds two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {vec4} out\n */\nexport function add(out, a, b) {\n    out[0] = a[0] + b[0];\n    out[1] = a[1] + b[1];\n    out[2] = a[2] + b[2];\n    out[3] = a[3] + b[3];\n    return out;\n}\n\n/**\n * Scales a vec4 by a scalar number\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec4} out\n */\nexport function scale(out, a, b) {\n    out[0] = a[0] * b;\n    out[1] = a[1] * b;\n    out[2] = a[2] * b;\n    out[3] = a[3] * b;\n    return out;\n}\n\n/**\n * Calculates the length of a vec4\n *\n * @param {vec4} a vector to calculate length of\n * @returns {Number} length of a\n */\nexport function length(a) {\n    let x = a[0];\n    let y = a[1];\n    let z = a[2];\n    let w = a[3];\n    return Math.sqrt(x * x + y * y + z * z + w * w);\n}\n\n/**\n * Normalize a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a vector to normalize\n * @returns {vec4} out\n */\nexport function normalize(out, a) {\n    let x = a[0];\n    let y = a[1];\n    let z = a[2];\n    let w = a[3];\n    let len = x * x + y * y + z * z + w * w;\n    if (len > 0) {\n        len = 1 / Math.sqrt(len);\n    }\n    out[0] = x * len;\n    out[1] = y * len;\n    out[2] = z * len;\n    out[3] = w * len;\n    return out;\n}\n\n/**\n * Calculates the dot product of two vec4's\n *\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {Number} dot product of a and b\n */\nexport function dot(a, b) {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n}\n\n/**\n * Performs a linear interpolation between two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {vec4} out\n */\nexport function lerp(out, a, b, t) {\n    let ax = a[0];\n    let ay = a[1];\n    let az = a[2];\n    let aw = a[3];\n    out[0] = ax + t * (b[0] - ax);\n    out[1] = ay + t * (b[1] - ay);\n    out[2] = az + t * (b[2] - az);\n    out[3] = aw + t * (b[3] - aw);\n    return out;\n}\n", "import * as vec4 from './Vec4Func.js';\n\n/**\n * Set a quat to the identity quaternion\n *\n * @param {quat} out the receiving quaternion\n * @returns {quat} out\n */\nexport function identity(out) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 1;\n    return out;\n}\n\n/**\n * Sets a quat from the given angle and rotation axis,\n * then returns it.\n *\n * @param {quat} out the receiving quaternion\n * @param {vec3} axis the axis around which to rotate\n * @param {Number} rad the angle in radians\n * @returns {quat} out\n **/\nexport function setAxisAngle(out, axis, rad) {\n    rad = rad * 0.5;\n    let s = Math.sin(rad);\n    out[0] = s * axis[0];\n    out[1] = s * axis[1];\n    out[2] = s * axis[2];\n    out[3] = Math.cos(rad);\n    return out;\n}\n\n/**\n * Multiplies two quats\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @returns {quat} out\n */\nexport function multiply(out, a, b) {\n    let ax = a[0],\n        ay = a[1],\n        az = a[2],\n        aw = a[3];\n    let bx = b[0],\n        by = b[1],\n        bz = b[2],\n        bw = b[3];\n\n    out[0] = ax * bw + aw * bx + ay * bz - az * by;\n    out[1] = ay * bw + aw * by + az * bx - ax * bz;\n    out[2] = az * bw + aw * bz + ax * by - ay * bx;\n    out[3] = aw * bw - ax * bx - ay * by - az * bz;\n    return out;\n}\n\n/**\n * Rotates a quaternion by the given angle about the X axis\n *\n * @param {quat} out quat receiving operation result\n * @param {quat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nexport function rotateX(out, a, rad) {\n    rad *= 0.5;\n\n    let ax = a[0],\n        ay = a[1],\n        az = a[2],\n        aw = a[3];\n    let bx = Math.sin(rad),\n        bw = Math.cos(rad);\n\n    out[0] = ax * bw + aw * bx;\n    out[1] = ay * bw + az * bx;\n    out[2] = az * bw - ay * bx;\n    out[3] = aw * bw - ax * bx;\n    return out;\n}\n\n/**\n * Rotates a quaternion by the given angle about the Y axis\n *\n * @param {quat} out quat receiving operation result\n * @param {quat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nexport function rotateY(out, a, rad) {\n    rad *= 0.5;\n\n    let ax = a[0],\n        ay = a[1],\n        az = a[2],\n        aw = a[3];\n    let by = Math.sin(rad),\n        bw = Math.cos(rad);\n\n    out[0] = ax * bw - az * by;\n    out[1] = ay * bw + aw * by;\n    out[2] = az * bw + ax * by;\n    out[3] = aw * bw - ay * by;\n    return out;\n}\n\n/**\n * Rotates a quaternion by the given angle about the Z axis\n *\n * @param {quat} out quat receiving operation result\n * @param {quat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nexport function rotateZ(out, a, rad) {\n    rad *= 0.5;\n\n    let ax = a[0],\n        ay = a[1],\n        az = a[2],\n        aw = a[3];\n    let bz = Math.sin(rad),\n        bw = Math.cos(rad);\n\n    out[0] = ax * bw + ay * bz;\n    out[1] = ay * bw - ax * bz;\n    out[2] = az * bw + aw * bz;\n    out[3] = aw * bw - az * bz;\n    return out;\n}\n\n/**\n * Performs a spherical linear interpolation between two quat\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {quat} out\n */\nexport function slerp(out, a, b, t) {\n    // benchmarks:\n    //    http://jsperf.com/quaternion-slerp-implementations\n    let ax = a[0],\n        ay = a[1],\n        az = a[2],\n        aw = a[3];\n    let bx = b[0],\n        by = b[1],\n        bz = b[2],\n        bw = b[3];\n\n    let omega, cosom, sinom, scale0, scale1;\n\n    // calc cosine\n    cosom = ax * bx + ay * by + az * bz + aw * bw;\n    // adjust signs (if necessary)\n    if (cosom < 0.0) {\n        cosom = -cosom;\n        bx = -bx;\n        by = -by;\n        bz = -bz;\n        bw = -bw;\n    }\n    // calculate coefficients\n    if (1.0 - cosom > 0.000001) {\n        // standard case (slerp)\n        omega = Math.acos(cosom);\n        sinom = Math.sin(omega);\n        scale0 = Math.sin((1.0 - t) * omega) / sinom;\n        scale1 = Math.sin(t * omega) / sinom;\n    } else {\n        // \"from\" and \"to\" quaternions are very close\n        //  ... so we can do a linear interpolation\n        scale0 = 1.0 - t;\n        scale1 = t;\n    }\n    // calculate final values\n    out[0] = scale0 * ax + scale1 * bx;\n    out[1] = scale0 * ay + scale1 * by;\n    out[2] = scale0 * az + scale1 * bz;\n    out[3] = scale0 * aw + scale1 * bw;\n\n    return out;\n}\n\n/**\n * Calculates the inverse of a quat\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a quat to calculate inverse of\n * @returns {quat} out\n */\nexport function invert(out, a) {\n    let a0 = a[0],\n        a1 = a[1],\n        a2 = a[2],\n        a3 = a[3];\n    let dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;\n    let invDot = dot ? 1.0 / dot : 0;\n\n    // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0\n\n    out[0] = -a0 * invDot;\n    out[1] = -a1 * invDot;\n    out[2] = -a2 * invDot;\n    out[3] = a3 * invDot;\n    return out;\n}\n\n/**\n * Calculates the conjugate of a quat\n * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a quat to calculate conjugate of\n * @returns {quat} out\n */\nexport function conjugate(out, a) {\n    out[0] = -a[0];\n    out[1] = -a[1];\n    out[2] = -a[2];\n    out[3] = a[3];\n    return out;\n}\n\n/**\n * Creates a quaternion from the given 3x3 rotation matrix.\n *\n * NOTE: The resultant quaternion is not normalized, so you should be sure\n * to renormalize the quaternion yourself where necessary.\n *\n * @param {quat} out the receiving quaternion\n * @param {mat3} m rotation matrix\n * @returns {quat} out\n * @function\n */\nexport function fromMat3(out, m) {\n    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes\n    // article \"Quaternion Calculus and Fast Animation\".\n    let fTrace = m[0] + m[4] + m[8];\n    let fRoot;\n\n    if (fTrace > 0.0) {\n        // |w| > 1/2, may as well choose w > 1/2\n        fRoot = Math.sqrt(fTrace + 1.0); // 2w\n        out[3] = 0.5 * fRoot;\n        fRoot = 0.5 / fRoot; // 1/(4w)\n        out[0] = (m[5] - m[7]) * fRoot;\n        out[1] = (m[6] - m[2]) * fRoot;\n        out[2] = (m[1] - m[3]) * fRoot;\n    } else {\n        // |w| <= 1/2\n        let i = 0;\n        if (m[4] > m[0]) i = 1;\n        if (m[8] > m[i * 3 + i]) i = 2;\n        let j = (i + 1) % 3;\n        let k = (i + 2) % 3;\n\n        fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);\n        out[i] = 0.5 * fRoot;\n        fRoot = 0.5 / fRoot;\n        out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;\n        out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;\n        out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;\n    }\n\n    return out;\n}\n\n/**\n * Creates a quaternion from the given euler angle x, y, z.\n *\n * @param {quat} out the receiving quaternion\n * @param {vec3} euler Angles to rotate around each axis in degrees.\n * @param {String} order detailing order of operations. Default 'XYZ'.\n * @returns {quat} out\n * @function\n */\nexport function fromEuler(out, euler, order = 'YXZ') {\n    let sx = Math.sin(euler[0] * 0.5);\n    let cx = Math.cos(euler[0] * 0.5);\n    let sy = Math.sin(euler[1] * 0.5);\n    let cy = Math.cos(euler[1] * 0.5);\n    let sz = Math.sin(euler[2] * 0.5);\n    let cz = Math.cos(euler[2] * 0.5);\n\n    if (order === 'XYZ') {\n        out[0] = sx * cy * cz + cx * sy * sz;\n        out[1] = cx * sy * cz - sx * cy * sz;\n        out[2] = cx * cy * sz + sx * sy * cz;\n        out[3] = cx * cy * cz - sx * sy * sz;\n    } else if (order === 'YXZ') {\n        out[0] = sx * cy * cz + cx * sy * sz;\n        out[1] = cx * sy * cz - sx * cy * sz;\n        out[2] = cx * cy * sz - sx * sy * cz;\n        out[3] = cx * cy * cz + sx * sy * sz;\n    } else if (order === 'ZXY') {\n        out[0] = sx * cy * cz - cx * sy * sz;\n        out[1] = cx * sy * cz + sx * cy * sz;\n        out[2] = cx * cy * sz + sx * sy * cz;\n        out[3] = cx * cy * cz - sx * sy * sz;\n    } else if (order === 'ZYX') {\n        out[0] = sx * cy * cz - cx * sy * sz;\n        out[1] = cx * sy * cz + sx * cy * sz;\n        out[2] = cx * cy * sz - sx * sy * cz;\n        out[3] = cx * cy * cz + sx * sy * sz;\n    } else if (order === 'YZX') {\n        out[0] = sx * cy * cz + cx * sy * sz;\n        out[1] = cx * sy * cz + sx * cy * sz;\n        out[2] = cx * cy * sz - sx * sy * cz;\n        out[3] = cx * cy * cz - sx * sy * sz;\n    } else if (order === 'XZY') {\n        out[0] = sx * cy * cz - cx * sy * sz;\n        out[1] = cx * sy * cz - sx * cy * sz;\n        out[2] = cx * cy * sz + sx * sy * cz;\n        out[3] = cx * cy * cz + sx * sy * sz;\n    }\n\n    return out;\n}\n\n/**\n * Copy the values from one quat to another\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the source quaternion\n * @returns {quat} out\n * @function\n */\nexport const copy = vec4.copy;\n\n/**\n * Set the components of a quat to the given values\n *\n * @param {quat} out the receiving quaternion\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {quat} out\n * @function\n */\nexport const set = vec4.set;\n\n/**\n * Adds two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @returns {quat} out\n * @function\n */\nexport const add = vec4.add;\n\n/**\n * Scales a quat by a scalar number\n *\n * @param {quat} out the receiving vector\n * @param {quat} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {quat} out\n * @function\n */\nexport const scale = vec4.scale;\n\n/**\n * Calculates the dot product of two quat's\n *\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @returns {Number} dot product of a and b\n * @function\n */\nexport const dot = vec4.dot;\n\n/**\n * Performs a linear interpolation between two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {quat} out\n * @function\n */\nexport const lerp = vec4.lerp;\n\n/**\n * Calculates the length of a quat\n *\n * @param {quat} a vector to calculate length of\n * @returns {Number} length of a\n */\nexport const length = vec4.length;\n\n/**\n * Normalize a quat\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a quaternion to normalize\n * @returns {quat} out\n * @function\n */\nexport const normalize = vec4.normalize;\n", "import * as QuatFunc from './functions/QuatFunc.js';\n\nexport class Quat extends Array {\n    constructor(x = 0, y = 0, z = 0, w = 1) {\n        super(x, y, z, w);\n        this.onChange = () => {};\n        return this;\n    }\n\n    get x() {\n        return this[0];\n    }\n\n    get y() {\n        return this[1];\n    }\n\n    get z() {\n        return this[2];\n    }\n\n    get w() {\n        return this[3];\n    }\n\n    set x(v) {\n        this[0] = v;\n        this.onChange();\n    }\n\n    set y(v) {\n        this[1] = v;\n        this.onChange();\n    }\n\n    set z(v) {\n        this[2] = v;\n        this.onChange();\n    }\n\n    set w(v) {\n        this[3] = v;\n        this.onChange();\n    }\n\n    identity() {\n        QuatFunc.identity(this);\n        this.onChange();\n        return this;\n    }\n\n    set(x, y, z, w) {\n        if (x.length) return this.copy(x);\n        QuatFunc.set(this, x, y, z, w);\n        this.onChange();\n        return this;\n    }\n\n    rotateX(a) {\n        QuatFunc.rotateX(this, this, a);\n        this.onChange();\n        return this;\n    }\n\n    rotateY(a) {\n        QuatFunc.rotateY(this, this, a);\n        this.onChange();\n        return this;\n    }\n\n    rotateZ(a) {\n        QuatFunc.rotateZ(this, this, a);\n        this.onChange();\n        return this;\n    }\n\n    inverse(q = this) {\n        QuatFunc.invert(this, q);\n        this.onChange();\n        return this;\n    }\n\n    conjugate(q = this) {\n        QuatFunc.conjugate(this, q);\n        this.onChange();\n        return this;\n    }\n\n    copy(q) {\n        QuatFunc.copy(this, q);\n        this.onChange();\n        return this;\n    }\n\n    normalize(q = this) {\n        QuatFunc.normalize(this, q);\n        this.onChange();\n        return this;\n    }\n\n    multiply(qA, qB) {\n        if (qB) {\n            QuatFunc.multiply(this, qA, qB);\n        } else {\n            QuatFunc.multiply(this, this, qA);\n        }\n        this.onChange();\n        return this;\n    }\n\n    dot(v) {\n        return QuatFunc.dot(this, v);\n    }\n\n    fromMatrix3(matrix3) {\n        QuatFunc.fromMat3(this, matrix3);\n        this.onChange();\n        return this;\n    }\n\n    fromEuler(euler) {\n        QuatFunc.fromEuler(this, euler, euler.order);\n        return this;\n    }\n\n    fromAxisAngle(axis, a) {\n        QuatFunc.setAxisAngle(this, axis, a);\n        this.onChange();\n        return this;\n    }\n\n    slerp(q, t) {\n        QuatFunc.slerp(this, this, q, t);\n        this.onChange();\n        return this;\n    }\n\n    fromArray(a, o = 0) {\n        this[0] = a[o];\n        this[1] = a[o + 1];\n        this[2] = a[o + 2];\n        this[3] = a[o + 3];\n        this.onChange();\n        return this;\n    }\n\n    toArray(a = [], o = 0) {\n        a[o] = this[0];\n        a[o + 1] = this[1];\n        a[o + 2] = this[2];\n        a[o + 3] = this[3];\n        return a;\n    }\n}\n", "const EPSILON = 0.000001;\n\n/**\n * Copy the values from one mat4 to another\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\nexport function copy(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[4] = a[4];\n    out[5] = a[5];\n    out[6] = a[6];\n    out[7] = a[7];\n    out[8] = a[8];\n    out[9] = a[9];\n    out[10] = a[10];\n    out[11] = a[11];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n    return out;\n}\n\n/**\n * Set the components of a mat4 to the given values\n *\n * @param {mat4} out the receiving matrix\n * @returns {mat4} out\n */\nexport function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n    out[0] = m00;\n    out[1] = m01;\n    out[2] = m02;\n    out[3] = m03;\n    out[4] = m10;\n    out[5] = m11;\n    out[6] = m12;\n    out[7] = m13;\n    out[8] = m20;\n    out[9] = m21;\n    out[10] = m22;\n    out[11] = m23;\n    out[12] = m30;\n    out[13] = m31;\n    out[14] = m32;\n    out[15] = m33;\n    return out;\n}\n\n/**\n * Set a mat4 to the identity matrix\n *\n * @param {mat4} out the receiving matrix\n * @returns {mat4} out\n */\nexport function identity(out) {\n    out[0] = 1;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[5] = 1;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[10] = 1;\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n    out[15] = 1;\n    return out;\n}\n\n/**\n * Transpose the values of a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\nexport function transpose(out, a) {\n    // If we are transposing ourselves we can skip a few steps but have to cache some values\n    if (out === a) {\n        let a01 = a[1],\n            a02 = a[2],\n            a03 = a[3];\n        let a12 = a[6],\n            a13 = a[7];\n        let a23 = a[11];\n\n        out[1] = a[4];\n        out[2] = a[8];\n        out[3] = a[12];\n        out[4] = a01;\n        out[6] = a[9];\n        out[7] = a[13];\n        out[8] = a02;\n        out[9] = a12;\n        out[11] = a[14];\n        out[12] = a03;\n        out[13] = a13;\n        out[14] = a23;\n    } else {\n        out[0] = a[0];\n        out[1] = a[4];\n        out[2] = a[8];\n        out[3] = a[12];\n        out[4] = a[1];\n        out[5] = a[5];\n        out[6] = a[9];\n        out[7] = a[13];\n        out[8] = a[2];\n        out[9] = a[6];\n        out[10] = a[10];\n        out[11] = a[14];\n        out[12] = a[3];\n        out[13] = a[7];\n        out[14] = a[11];\n        out[15] = a[15];\n    }\n\n    return out;\n}\n\n/**\n * Inverts a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\nexport function invert(out, a) {\n    let a00 = a[0],\n        a01 = a[1],\n        a02 = a[2],\n        a03 = a[3];\n    let a10 = a[4],\n        a11 = a[5],\n        a12 = a[6],\n        a13 = a[7];\n    let a20 = a[8],\n        a21 = a[9],\n        a22 = a[10],\n        a23 = a[11];\n    let a30 = a[12],\n        a31 = a[13],\n        a32 = a[14],\n        a33 = a[15];\n\n    let b00 = a00 * a11 - a01 * a10;\n    let b01 = a00 * a12 - a02 * a10;\n    let b02 = a00 * a13 - a03 * a10;\n    let b03 = a01 * a12 - a02 * a11;\n    let b04 = a01 * a13 - a03 * a11;\n    let b05 = a02 * a13 - a03 * a12;\n    let b06 = a20 * a31 - a21 * a30;\n    let b07 = a20 * a32 - a22 * a30;\n    let b08 = a20 * a33 - a23 * a30;\n    let b09 = a21 * a32 - a22 * a31;\n    let b10 = a21 * a33 - a23 * a31;\n    let b11 = a22 * a33 - a23 * a32;\n\n    // Calculate the determinant\n    let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n    if (!det) {\n        return null;\n    }\n    det = 1.0 / det;\n\n    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\n    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\n    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\n    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\n    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\n    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\n    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\n\n    return out;\n}\n\n/**\n * Calculates the determinant of a mat4\n *\n * @param {mat4} a the source matrix\n * @returns {Number} determinant of a\n */\nexport function determinant(a) {\n    let a00 = a[0],\n        a01 = a[1],\n        a02 = a[2],\n        a03 = a[3];\n    let a10 = a[4],\n        a11 = a[5],\n        a12 = a[6],\n        a13 = a[7];\n    let a20 = a[8],\n        a21 = a[9],\n        a22 = a[10],\n        a23 = a[11];\n    let a30 = a[12],\n        a31 = a[13],\n        a32 = a[14],\n        a33 = a[15];\n\n    let b00 = a00 * a11 - a01 * a10;\n    let b01 = a00 * a12 - a02 * a10;\n    let b02 = a00 * a13 - a03 * a10;\n    let b03 = a01 * a12 - a02 * a11;\n    let b04 = a01 * a13 - a03 * a11;\n    let b05 = a02 * a13 - a03 * a12;\n    let b06 = a20 * a31 - a21 * a30;\n    let b07 = a20 * a32 - a22 * a30;\n    let b08 = a20 * a33 - a23 * a30;\n    let b09 = a21 * a32 - a22 * a31;\n    let b10 = a21 * a33 - a23 * a31;\n    let b11 = a22 * a33 - a23 * a32;\n\n    // Calculate the determinant\n    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n}\n\n/**\n * Multiplies two mat4s\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the first operand\n * @param {mat4} b the second operand\n * @returns {mat4} out\n */\nexport function multiply(out, a, b) {\n    let a00 = a[0],\n        a01 = a[1],\n        a02 = a[2],\n        a03 = a[3];\n    let a10 = a[4],\n        a11 = a[5],\n        a12 = a[6],\n        a13 = a[7];\n    let a20 = a[8],\n        a21 = a[9],\n        a22 = a[10],\n        a23 = a[11];\n    let a30 = a[12],\n        a31 = a[13],\n        a32 = a[14],\n        a33 = a[15];\n\n    // Cache only the current line of the second matrix\n    let b0 = b[0],\n        b1 = b[1],\n        b2 = b[2],\n        b3 = b[3];\n    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n\n    b0 = b[4];\n    b1 = b[5];\n    b2 = b[6];\n    b3 = b[7];\n    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n\n    b0 = b[8];\n    b1 = b[9];\n    b2 = b[10];\n    b3 = b[11];\n    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n\n    b0 = b[12];\n    b1 = b[13];\n    b2 = b[14];\n    b3 = b[15];\n    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n    return out;\n}\n\n/**\n * Translate a mat4 by the given vector\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to translate\n * @param {vec3} v vector to translate by\n * @returns {mat4} out\n */\nexport function translate(out, a, v) {\n    let x = v[0],\n        y = v[1],\n        z = v[2];\n    let a00, a01, a02, a03;\n    let a10, a11, a12, a13;\n    let a20, a21, a22, a23;\n\n    if (a === out) {\n        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];\n        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];\n        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];\n        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];\n    } else {\n        a00 = a[0];\n        a01 = a[1];\n        a02 = a[2];\n        a03 = a[3];\n        a10 = a[4];\n        a11 = a[5];\n        a12 = a[6];\n        a13 = a[7];\n        a20 = a[8];\n        a21 = a[9];\n        a22 = a[10];\n        a23 = a[11];\n\n        out[0] = a00;\n        out[1] = a01;\n        out[2] = a02;\n        out[3] = a03;\n        out[4] = a10;\n        out[5] = a11;\n        out[6] = a12;\n        out[7] = a13;\n        out[8] = a20;\n        out[9] = a21;\n        out[10] = a22;\n        out[11] = a23;\n\n        out[12] = a00 * x + a10 * y + a20 * z + a[12];\n        out[13] = a01 * x + a11 * y + a21 * z + a[13];\n        out[14] = a02 * x + a12 * y + a22 * z + a[14];\n        out[15] = a03 * x + a13 * y + a23 * z + a[15];\n    }\n\n    return out;\n}\n\n/**\n * Scales the mat4 by the dimensions in the given vec3 not using vectorization\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to scale\n * @param {vec3} v the vec3 to scale the matrix by\n * @returns {mat4} out\n **/\nexport function scale(out, a, v) {\n    let x = v[0],\n        y = v[1],\n        z = v[2];\n\n    out[0] = a[0] * x;\n    out[1] = a[1] * x;\n    out[2] = a[2] * x;\n    out[3] = a[3] * x;\n    out[4] = a[4] * y;\n    out[5] = a[5] * y;\n    out[6] = a[6] * y;\n    out[7] = a[7] * y;\n    out[8] = a[8] * z;\n    out[9] = a[9] * z;\n    out[10] = a[10] * z;\n    out[11] = a[11] * z;\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n    return out;\n}\n\n/**\n * Rotates a mat4 by the given angle around the given axis\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @param {vec3} axis the axis to rotate around\n * @returns {mat4} out\n */\nexport function rotate(out, a, rad, axis) {\n    let x = axis[0],\n        y = axis[1],\n        z = axis[2];\n    let len = Math.hypot(x, y, z);\n    let s, c, t;\n    let a00, a01, a02, a03;\n    let a10, a11, a12, a13;\n    let a20, a21, a22, a23;\n    let b00, b01, b02;\n    let b10, b11, b12;\n    let b20, b21, b22;\n\n    if (Math.abs(len) < EPSILON) {\n        return null;\n    }\n\n    len = 1 / len;\n    x *= len;\n    y *= len;\n    z *= len;\n\n    s = Math.sin(rad);\n    c = Math.cos(rad);\n    t = 1 - c;\n\n    a00 = a[0];\n    a01 = a[1];\n    a02 = a[2];\n    a03 = a[3];\n    a10 = a[4];\n    a11 = a[5];\n    a12 = a[6];\n    a13 = a[7];\n    a20 = a[8];\n    a21 = a[9];\n    a22 = a[10];\n    a23 = a[11];\n\n    // Construct the elements of the rotation matrix\n    b00 = x * x * t + c;\n    b01 = y * x * t + z * s;\n    b02 = z * x * t - y * s;\n    b10 = x * y * t - z * s;\n    b11 = y * y * t + c;\n    b12 = z * y * t + x * s;\n    b20 = x * z * t + y * s;\n    b21 = y * z * t - x * s;\n    b22 = z * z * t + c;\n\n    // Perform rotation-specific matrix multiplication\n    out[0] = a00 * b00 + a10 * b01 + a20 * b02;\n    out[1] = a01 * b00 + a11 * b01 + a21 * b02;\n    out[2] = a02 * b00 + a12 * b01 + a22 * b02;\n    out[3] = a03 * b00 + a13 * b01 + a23 * b02;\n    out[4] = a00 * b10 + a10 * b11 + a20 * b12;\n    out[5] = a01 * b10 + a11 * b11 + a21 * b12;\n    out[6] = a02 * b10 + a12 * b11 + a22 * b12;\n    out[7] = a03 * b10 + a13 * b11 + a23 * b12;\n    out[8] = a00 * b20 + a10 * b21 + a20 * b22;\n    out[9] = a01 * b20 + a11 * b21 + a21 * b22;\n    out[10] = a02 * b20 + a12 * b21 + a22 * b22;\n    out[11] = a03 * b20 + a13 * b21 + a23 * b22;\n\n    if (a !== out) {\n        // If the source and destination differ, copy the unchanged last row\n        out[12] = a[12];\n        out[13] = a[13];\n        out[14] = a[14];\n        out[15] = a[15];\n    }\n    return out;\n}\n\n/**\n * Returns the translation vector component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslation,\n *  the returned vector will be the same as the translation vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive translation component\n * @param  {mat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\nexport function getTranslation(out, mat) {\n    out[0] = mat[12];\n    out[1] = mat[13];\n    out[2] = mat[14];\n\n    return out;\n}\n\n/**\n * Returns the scaling factor component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslationScale\n *  with a normalized Quaternion paramter, the returned vector will be\n *  the same as the scaling vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive scaling factor component\n * @param  {mat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\nexport function getScaling(out, mat) {\n    let m11 = mat[0];\n    let m12 = mat[1];\n    let m13 = mat[2];\n    let m21 = mat[4];\n    let m22 = mat[5];\n    let m23 = mat[6];\n    let m31 = mat[8];\n    let m32 = mat[9];\n    let m33 = mat[10];\n\n    out[0] = Math.hypot(m11, m12, m13);\n    out[1] = Math.hypot(m21, m22, m23);\n    out[2] = Math.hypot(m31, m32, m33);\n\n    return out;\n}\n\nexport function getMaxScaleOnAxis(mat) {\n    let m11 = mat[0];\n    let m12 = mat[1];\n    let m13 = mat[2];\n    let m21 = mat[4];\n    let m22 = mat[5];\n    let m23 = mat[6];\n    let m31 = mat[8];\n    let m32 = mat[9];\n    let m33 = mat[10];\n\n    const x = m11 * m11 + m12 * m12 + m13 * m13;\n    const y = m21 * m21 + m22 * m22 + m23 * m23;\n    const z = m31 * m31 + m32 * m32 + m33 * m33;\n\n    return Math.sqrt(Math.max(x, y, z));\n}\n\n/**\n * Returns a quaternion representing the rotational component\n *  of a transformation matrix. If a matrix is built with\n *  fromRotationTranslation, the returned quaternion will be the\n *  same as the quaternion originally supplied.\n * @param {quat} out Quaternion to receive the rotation component\n * @param {mat4} mat Matrix to be decomposed (input)\n * @return {quat} out\n */\nexport const getRotation = (function () {\n    const temp = [1, 1, 1];\n\n    return function (out, mat) {\n        let scaling = temp;\n        getScaling(scaling, mat);\n\n        let is1 = 1 / scaling[0];\n        let is2 = 1 / scaling[1];\n        let is3 = 1 / scaling[2];\n\n        let sm11 = mat[0] * is1;\n        let sm12 = mat[1] * is2;\n        let sm13 = mat[2] * is3;\n        let sm21 = mat[4] * is1;\n        let sm22 = mat[5] * is2;\n        let sm23 = mat[6] * is3;\n        let sm31 = mat[8] * is1;\n        let sm32 = mat[9] * is2;\n        let sm33 = mat[10] * is3;\n\n        let trace = sm11 + sm22 + sm33;\n        let S = 0;\n\n        if (trace > 0) {\n            S = Math.sqrt(trace + 1.0) * 2;\n            out[3] = 0.25 * S;\n            out[0] = (sm23 - sm32) / S;\n            out[1] = (sm31 - sm13) / S;\n            out[2] = (sm12 - sm21) / S;\n        } else if (sm11 > sm22 && sm11 > sm33) {\n            S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;\n            out[3] = (sm23 - sm32) / S;\n            out[0] = 0.25 * S;\n            out[1] = (sm12 + sm21) / S;\n            out[2] = (sm31 + sm13) / S;\n        } else if (sm22 > sm33) {\n            S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;\n            out[3] = (sm31 - sm13) / S;\n            out[0] = (sm12 + sm21) / S;\n            out[1] = 0.25 * S;\n            out[2] = (sm23 + sm32) / S;\n        } else {\n            S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;\n            out[3] = (sm12 - sm21) / S;\n            out[0] = (sm31 + sm13) / S;\n            out[1] = (sm23 + sm32) / S;\n            out[2] = 0.25 * S;\n        }\n\n        return out;\n    };\n})();\n\n/**\n * Creates a matrix from a quaternion rotation, vector translation and vector scale\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *     mat4.scale(dest, scale)\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {vec3} v Translation vector\n * @param {vec3} s Scaling vector\n * @returns {mat4} out\n */\nexport function fromRotationTranslationScale(out, q, v, s) {\n    // Quaternion math\n    let x = q[0],\n        y = q[1],\n        z = q[2],\n        w = q[3];\n    let x2 = x + x;\n    let y2 = y + y;\n    let z2 = z + z;\n\n    let xx = x * x2;\n    let xy = x * y2;\n    let xz = x * z2;\n    let yy = y * y2;\n    let yz = y * z2;\n    let zz = z * z2;\n    let wx = w * x2;\n    let wy = w * y2;\n    let wz = w * z2;\n    let sx = s[0];\n    let sy = s[1];\n    let sz = s[2];\n\n    out[0] = (1 - (yy + zz)) * sx;\n    out[1] = (xy + wz) * sx;\n    out[2] = (xz - wy) * sx;\n    out[3] = 0;\n    out[4] = (xy - wz) * sy;\n    out[5] = (1 - (xx + zz)) * sy;\n    out[6] = (yz + wx) * sy;\n    out[7] = 0;\n    out[8] = (xz + wy) * sz;\n    out[9] = (yz - wx) * sz;\n    out[10] = (1 - (xx + yy)) * sz;\n    out[11] = 0;\n    out[12] = v[0];\n    out[13] = v[1];\n    out[14] = v[2];\n    out[15] = 1;\n\n    return out;\n}\n\n/**\n * Calculates a 4x4 matrix from the given quaternion\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat} q Quaternion to create matrix from\n *\n * @returns {mat4} out\n */\nexport function fromQuat(out, q) {\n    let x = q[0],\n        y = q[1],\n        z = q[2],\n        w = q[3];\n    let x2 = x + x;\n    let y2 = y + y;\n    let z2 = z + z;\n\n    let xx = x * x2;\n    let yx = y * x2;\n    let yy = y * y2;\n    let zx = z * x2;\n    let zy = z * y2;\n    let zz = z * z2;\n    let wx = w * x2;\n    let wy = w * y2;\n    let wz = w * z2;\n\n    out[0] = 1 - yy - zz;\n    out[1] = yx + wz;\n    out[2] = zx - wy;\n    out[3] = 0;\n\n    out[4] = yx - wz;\n    out[5] = 1 - xx - zz;\n    out[6] = zy + wx;\n    out[7] = 0;\n\n    out[8] = zx + wy;\n    out[9] = zy - wx;\n    out[10] = 1 - xx - yy;\n    out[11] = 0;\n\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n    out[15] = 1;\n\n    return out;\n}\n\n/**\n * Generates a perspective projection matrix with the given bounds\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} fovy Vertical field of view in radians\n * @param {number} aspect Aspect ratio. typically viewport width/height\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\nexport function perspective(out, fovy, aspect, near, far) {\n    let f = 1.0 / Math.tan(fovy / 2);\n    let nf = 1 / (near - far);\n    out[0] = f / aspect;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[5] = f;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[10] = (far + near) * nf;\n    out[11] = -1;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 2 * far * near * nf;\n    out[15] = 0;\n    return out;\n}\n\n/**\n * Generates a orthogonal projection matrix with the given bounds\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} left Left bound of the frustum\n * @param {number} right Right bound of the frustum\n * @param {number} bottom Bottom bound of the frustum\n * @param {number} top Top bound of the frustum\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\nexport function ortho(out, left, right, bottom, top, near, far) {\n    let lr = 1 / (left - right);\n    let bt = 1 / (bottom - top);\n    let nf = 1 / (near - far);\n    out[0] = -2 * lr;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[5] = -2 * bt;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[10] = 2 * nf;\n    out[11] = 0;\n    out[12] = (left + right) * lr;\n    out[13] = (top + bottom) * bt;\n    out[14] = (far + near) * nf;\n    out[15] = 1;\n    return out;\n}\n\n/**\n * Generates a matrix that makes something look at something else.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {vec3} eye Position of the viewer\n * @param {vec3} target Point the viewer is looking at\n * @param {vec3} up vec3 pointing up\n * @returns {mat4} out\n */\nexport function targetTo(out, eye, target, up) {\n    let eyex = eye[0],\n        eyey = eye[1],\n        eyez = eye[2],\n        upx = up[0],\n        upy = up[1],\n        upz = up[2];\n\n    let z0 = eyex - target[0],\n        z1 = eyey - target[1],\n        z2 = eyez - target[2];\n\n    let len = z0 * z0 + z1 * z1 + z2 * z2;\n    if (len === 0) {\n        // eye and target are in the same position\n        z2 = 1;\n    } else {\n        len = 1 / Math.sqrt(len);\n        z0 *= len;\n        z1 *= len;\n        z2 *= len;\n    }\n\n    let x0 = upy * z2 - upz * z1,\n        x1 = upz * z0 - upx * z2,\n        x2 = upx * z1 - upy * z0;\n\n    len = x0 * x0 + x1 * x1 + x2 * x2;\n    if (len === 0) {\n        // up and z are parallel\n        if (upz) {\n            upx += 1e-6;\n        } else if (upy) {\n            upz += 1e-6;\n        } else {\n            upy += 1e-6;\n        }\n        (x0 = upy * z2 - upz * z1), (x1 = upz * z0 - upx * z2), (x2 = upx * z1 - upy * z0);\n\n        len = x0 * x0 + x1 * x1 + x2 * x2;\n    }\n\n    len = 1 / Math.sqrt(len);\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n\n    out[0] = x0;\n    out[1] = x1;\n    out[2] = x2;\n    out[3] = 0;\n    out[4] = z1 * x2 - z2 * x1;\n    out[5] = z2 * x0 - z0 * x2;\n    out[6] = z0 * x1 - z1 * x0;\n    out[7] = 0;\n    out[8] = z0;\n    out[9] = z1;\n    out[10] = z2;\n    out[11] = 0;\n    out[12] = eyex;\n    out[13] = eyey;\n    out[14] = eyez;\n    out[15] = 1;\n    return out;\n}\n\n/**\n * Adds two mat4's\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the first operand\n * @param {mat4} b the second operand\n * @returns {mat4} out\n */\nexport function add(out, a, b) {\n    out[0] = a[0] + b[0];\n    out[1] = a[1] + b[1];\n    out[2] = a[2] + b[2];\n    out[3] = a[3] + b[3];\n    out[4] = a[4] + b[4];\n    out[5] = a[5] + b[5];\n    out[6] = a[6] + b[6];\n    out[7] = a[7] + b[7];\n    out[8] = a[8] + b[8];\n    out[9] = a[9] + b[9];\n    out[10] = a[10] + b[10];\n    out[11] = a[11] + b[11];\n    out[12] = a[12] + b[12];\n    out[13] = a[13] + b[13];\n    out[14] = a[14] + b[14];\n    out[15] = a[15] + b[15];\n    return out;\n}\n\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the first operand\n * @param {mat4} b the second operand\n * @returns {mat4} out\n */\nexport function subtract(out, a, b) {\n    out[0] = a[0] - b[0];\n    out[1] = a[1] - b[1];\n    out[2] = a[2] - b[2];\n    out[3] = a[3] - b[3];\n    out[4] = a[4] - b[4];\n    out[5] = a[5] - b[5];\n    out[6] = a[6] - b[6];\n    out[7] = a[7] - b[7];\n    out[8] = a[8] - b[8];\n    out[9] = a[9] - b[9];\n    out[10] = a[10] - b[10];\n    out[11] = a[11] - b[11];\n    out[12] = a[12] - b[12];\n    out[13] = a[13] - b[13];\n    out[14] = a[14] - b[14];\n    out[15] = a[15] - b[15];\n    return out;\n}\n\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat4} out\n */\nexport function multiplyScalar(out, a, b) {\n    out[0] = a[0] * b;\n    out[1] = a[1] * b;\n    out[2] = a[2] * b;\n    out[3] = a[3] * b;\n    out[4] = a[4] * b;\n    out[5] = a[5] * b;\n    out[6] = a[6] * b;\n    out[7] = a[7] * b;\n    out[8] = a[8] * b;\n    out[9] = a[9] * b;\n    out[10] = a[10] * b;\n    out[11] = a[11] * b;\n    out[12] = a[12] * b;\n    out[13] = a[13] * b;\n    out[14] = a[14] * b;\n    out[15] = a[15] * b;\n    return out;\n}\n", "import * as Mat4Func from './functions/Mat4Func.js';\n\nexport class Mat4 extends Array {\n    constructor(\n        m00 = 1,\n        m01 = 0,\n        m02 = 0,\n        m03 = 0,\n        m10 = 0,\n        m11 = 1,\n        m12 = 0,\n        m13 = 0,\n        m20 = 0,\n        m21 = 0,\n        m22 = 1,\n        m23 = 0,\n        m30 = 0,\n        m31 = 0,\n        m32 = 0,\n        m33 = 1\n    ) {\n        super(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);\n        return this;\n    }\n\n    get x() {\n        return this[12];\n    }\n\n    get y() {\n        return this[13];\n    }\n\n    get z() {\n        return this[14];\n    }\n\n    get w() {\n        return this[15];\n    }\n\n    set x(v) {\n        this[12] = v;\n    }\n\n    set y(v) {\n        this[13] = v;\n    }\n\n    set z(v) {\n        this[14] = v;\n    }\n\n    set w(v) {\n        this[15] = v;\n    }\n\n    set(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n        if (m00.length) return this.copy(m00);\n        Mat4Func.set(this, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);\n        return this;\n    }\n\n    translate(v, m = this) {\n        Mat4Func.translate(this, m, v);\n        return this;\n    }\n\n    rotate(v, axis, m = this) {\n        Mat4Func.rotate(this, m, v, axis);\n        return this;\n    }\n\n    scale(v, m = this) {\n        Mat4Func.scale(this, m, typeof v === 'number' ? [v, v, v] : v);\n        return this;\n    }\n\n    add(ma, mb) {\n        if (mb) Mat4Func.add(this, ma, mb);\n        else Mat4Func.add(this, this, ma);\n        return this;\n    }\n\n    sub(ma, mb) {\n        if (mb) Mat4Func.subtract(this, ma, mb);\n        else Mat4Func.subtract(this, this, ma);\n        return this;\n    }\n\n    multiply(ma, mb) {\n        if (!ma.length) {\n            Mat4Func.multiplyScalar(this, this, ma);\n        } else if (mb) {\n            Mat4Func.multiply(this, ma, mb);\n        } else {\n            Mat4Func.multiply(this, this, ma);\n        }\n        return this;\n    }\n\n    identity() {\n        Mat4Func.identity(this);\n        return this;\n    }\n\n    copy(m) {\n        Mat4Func.copy(this, m);\n        return this;\n    }\n\n    fromPerspective({ fov, aspect, near, far } = {}) {\n        Mat4Func.perspective(this, fov, aspect, near, far);\n        return this;\n    }\n\n    fromOrthogonal({ left, right, bottom, top, near, far }) {\n        Mat4Func.ortho(this, left, right, bottom, top, near, far);\n        return this;\n    }\n\n    fromQuaternion(q) {\n        Mat4Func.fromQuat(this, q);\n        return this;\n    }\n\n    setPosition(v) {\n        this.x = v[0];\n        this.y = v[1];\n        this.z = v[2];\n        return this;\n    }\n\n    inverse(m = this) {\n        Mat4Func.invert(this, m);\n        return this;\n    }\n\n    compose(q, pos, scale) {\n        Mat4Func.fromRotationTranslationScale(this, q, pos, scale);\n        return this;\n    }\n\n    getRotation(q) {\n        Mat4Func.getRotation(q, this);\n        return this;\n    }\n\n    getTranslation(pos) {\n        Mat4Func.getTranslation(pos, this);\n        return this;\n    }\n\n    getScaling(scale) {\n        Mat4Func.getScaling(scale, this);\n        return this;\n    }\n\n    getMaxScaleOnAxis() {\n        return Mat4Func.getMaxScaleOnAxis(this);\n    }\n\n    lookAt(eye, target, up) {\n        Mat4Func.targetTo(this, eye, target, up);\n        return this;\n    }\n\n    determinant() {\n        return Mat4Func.determinant(this);\n    }\n\n    fromArray(a, o = 0) {\n        this[0] = a[o];\n        this[1] = a[o + 1];\n        this[2] = a[o + 2];\n        this[3] = a[o + 3];\n        this[4] = a[o + 4];\n        this[5] = a[o + 5];\n        this[6] = a[o + 6];\n        this[7] = a[o + 7];\n        this[8] = a[o + 8];\n        this[9] = a[o + 9];\n        this[10] = a[o + 10];\n        this[11] = a[o + 11];\n        this[12] = a[o + 12];\n        this[13] = a[o + 13];\n        this[14] = a[o + 14];\n        this[15] = a[o + 15];\n        return this;\n    }\n\n    toArray(a = [], o = 0) {\n        a[o] = this[0];\n        a[o + 1] = this[1];\n        a[o + 2] = this[2];\n        a[o + 3] = this[3];\n        a[o + 4] = this[4];\n        a[o + 5] = this[5];\n        a[o + 6] = this[6];\n        a[o + 7] = this[7];\n        a[o + 8] = this[8];\n        a[o + 9] = this[9];\n        a[o + 10] = this[10];\n        a[o + 11] = this[11];\n        a[o + 12] = this[12];\n        a[o + 13] = this[13];\n        a[o + 14] = this[14];\n        a[o + 15] = this[15];\n        return a;\n    }\n}\n", "// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\nexport function fromRotationMatrix(out, m, order = 'YXZ') {\n    if (order === 'XYZ') {\n        out[1] = Math.asin(Math.min(Math.max(m[8], -1), 1));\n        if (Math.abs(m[8]) < 0.99999) {\n            out[0] = Math.atan2(-m[9], m[10]);\n            out[2] = Math.atan2(-m[4], m[0]);\n        } else {\n            out[0] = Math.atan2(m[6], m[5]);\n            out[2] = 0;\n        }\n    } else if (order === 'YXZ') {\n        out[0] = Math.asin(-Math.min(Math.max(m[9], -1), 1));\n        if (Math.abs(m[9]) < 0.99999) {\n            out[1] = Math.atan2(m[8], m[10]);\n            out[2] = Math.atan2(m[1], m[5]);\n        } else {\n            out[1] = Math.atan2(-m[2], m[0]);\n            out[2] = 0;\n        }\n    } else if (order === 'ZXY') {\n        out[0] = Math.asin(Math.min(Math.max(m[6], -1), 1));\n        if (Math.abs(m[6]) < 0.99999) {\n            out[1] = Math.atan2(-m[2], m[10]);\n            out[2] = Math.atan2(-m[4], m[5]);\n        } else {\n            out[1] = 0;\n            out[2] = Math.atan2(m[1], m[0]);\n        }\n    } else if (order === 'ZYX') {\n        out[1] = Math.asin(-Math.min(Math.max(m[2], -1), 1));\n        if (Math.abs(m[2]) < 0.99999) {\n            out[0] = Math.atan2(m[6], m[10]);\n            out[2] = Math.atan2(m[1], m[0]);\n        } else {\n            out[0] = 0;\n            out[2] = Math.atan2(-m[4], m[5]);\n        }\n    } else if (order === 'YZX') {\n        out[2] = Math.asin(Math.min(Math.max(m[1], -1), 1));\n        if (Math.abs(m[1]) < 0.99999) {\n            out[0] = Math.atan2(-m[9], m[5]);\n            out[1] = Math.atan2(-m[2], m[0]);\n        } else {\n            out[0] = 0;\n            out[1] = Math.atan2(m[8], m[10]);\n        }\n    } else if (order === 'XZY') {\n        out[2] = Math.asin(-Math.min(Math.max(m[4], -1), 1));\n        if (Math.abs(m[4]) < 0.99999) {\n            out[0] = Math.atan2(m[6], m[5]);\n            out[1] = Math.atan2(m[8], m[0]);\n        } else {\n            out[0] = Math.atan2(-m[9], m[10]);\n            out[1] = 0;\n        }\n    }\n\n    return out;\n}\n", "import * as EulerFunc from './functions/EulerFunc.js';\nimport { Mat4 } from './Mat4.js';\n\nconst tmpMat4 = /* @__PURE__ */ new Mat4();\n\nexport class Euler extends Array {\n    constructor(x = 0, y = x, z = x, order = 'YXZ') {\n        super(x, y, z);\n        this.order = order;\n        this.onChange = () => {};\n        return this;\n    }\n\n    get x() {\n        return this[0];\n    }\n\n    get y() {\n        return this[1];\n    }\n\n    get z() {\n        return this[2];\n    }\n\n    set x(v) {\n        this[0] = v;\n        this.onChange();\n    }\n\n    set y(v) {\n        this[1] = v;\n        this.onChange();\n    }\n\n    set z(v) {\n        this[2] = v;\n        this.onChange();\n    }\n\n    set(x, y = x, z = x) {\n        if (x.length) return this.copy(x);\n        this[0] = x;\n        this[1] = y;\n        this[2] = z;\n        this.onChange();\n        return this;\n    }\n\n    copy(v) {\n        this[0] = v[0];\n        this[1] = v[1];\n        this[2] = v[2];\n        this.onChange();\n        return this;\n    }\n\n    reorder(order) {\n        this.order = order;\n        this.onChange();\n        return this;\n    }\n\n    fromRotationMatrix(m, order = this.order) {\n        EulerFunc.fromRotationMatrix(this, m, order);\n        this.onChange();\n        return this;\n    }\n\n    fromQuaternion(q, order = this.order) {\n        tmpMat4.fromQuaternion(q);\n        return this.fromRotationMatrix(tmpMat4, order);\n    }\n\n    fromArray(a, o = 0) {\n        this[0] = a[o];\n        this[1] = a[o + 1];\n        this[2] = a[o + 2];\n        return this;\n    }\n\n    toArray(a = [], o = 0) {\n        a[o] = this[0];\n        a[o + 1] = this[1];\n        a[o + 2] = this[2];\n        return a;\n    }\n}\n", "import { Vec3 } from '../math/Vec3.js';\nimport { Quat } from '../math/Quat.js';\nimport { Mat4 } from '../math/Mat4.js';\nimport { Euler } from '../math/Euler.js';\n\nexport class Transform {\n    constructor() {\n        this.parent = null;\n        this.children = [];\n        this.visible = true;\n\n        this.matrix = new Mat4();\n        this.worldMatrix = new Mat4();\n        this.matrixAutoUpdate = true;\n        this.worldMatrixNeedsUpdate = false;\n\n        this.position = new Vec3();\n        this.quaternion = new Quat();\n        this.scale = new Vec3(1);\n        this.rotation = new Euler();\n        this.up = new Vec3(0, 1, 0);\n\n        this.rotation.onChange = () => this.quaternion.fromEuler(this.rotation);\n        this.quaternion.onChange = () => this.rotation.fromQuaternion(this.quaternion);\n    }\n\n    setParent(parent, notifyParent = true) {\n        if (this.parent && parent !== this.parent) this.parent.removeChild(this, false);\n        this.parent = parent;\n        if (notifyParent && parent) parent.addChild(this, false);\n    }\n\n    addChild(child, notifyChild = true) {\n        if (!~this.children.indexOf(child)) this.children.push(child);\n        if (notifyChild) child.setParent(this, false);\n    }\n\n    removeChild(child, notifyChild = true) {\n        if (!!~this.children.indexOf(child)) this.children.splice(this.children.indexOf(child), 1);\n        if (notifyChild) child.setParent(null, false);\n    }\n\n    updateMatrixWorld(force) {\n        if (this.matrixAutoUpdate) this.updateMatrix();\n        if (this.worldMatrixNeedsUpdate || force) {\n            if (this.parent === null) this.worldMatrix.copy(this.matrix);\n            else this.worldMatrix.multiply(this.parent.worldMatrix, this.matrix);\n            this.worldMatrixNeedsUpdate = false;\n            force = true;\n        }\n\n        for (let i = 0, l = this.children.length; i < l; i++) {\n            this.children[i].updateMatrixWorld(force);\n        }\n    }\n\n    updateMatrix() {\n        this.matrix.compose(this.quaternion, this.position, this.scale);\n        this.worldMatrixNeedsUpdate = true;\n    }\n\n    traverse(callback) {\n        // Return true in callback to stop traversing children\n        if (callback(this)) return;\n        for (let i = 0, l = this.children.length; i < l; i++) {\n            this.children[i].traverse(callback);\n        }\n    }\n\n    decompose() {\n        this.matrix.getTranslation(this.position);\n        this.matrix.getRotation(this.quaternion);\n        this.matrix.getScaling(this.scale);\n        this.rotation.fromQuaternion(this.quaternion);\n    }\n\n    lookAt(target, invert = false) {\n        if (invert) this.matrix.lookAt(this.position, target, this.up);\n        else this.matrix.lookAt(target, this.position, this.up);\n        this.matrix.getRotation(this.quaternion);\n        this.rotation.fromQuaternion(this.quaternion);\n    }\n}\n", "import { Transform } from './Transform.js';\nimport { Mat4 } from '../math/Mat4.js';\nimport { Vec3 } from '../math/Vec3.js';\n\nconst tempMat4 = /* @__PURE__ */ new Mat4();\nconst tempVec3a = /* @__PURE__ */ new Vec3();\nconst tempVec3b = /* @__PURE__ */ new Vec3();\n\nexport class Camera extends Transform {\n    constructor(gl, { near = 0.1, far = 100, fov = 45, aspect = 1, left, right, bottom, top, zoom = 1 } = {}) {\n        super();\n\n        Object.assign(this, { near, far, fov, aspect, left, right, bottom, top, zoom });\n\n        this.projectionMatrix = new Mat4();\n        this.viewMatrix = new Mat4();\n        this.projectionViewMatrix = new Mat4();\n        this.worldPosition = new Vec3();\n\n        // Use orthographic if left/right set, else default to perspective camera\n        this.type = left || right ? 'orthographic' : 'perspective';\n\n        if (this.type === 'orthographic') this.orthographic();\n        else this.perspective();\n    }\n\n    perspective({ near = this.near, far = this.far, fov = this.fov, aspect = this.aspect } = {}) {\n        Object.assign(this, { near, far, fov, aspect });\n        this.projectionMatrix.fromPerspective({ fov: fov * (Math.PI / 180), aspect, near, far });\n        this.type = 'perspective';\n        return this;\n    }\n\n    orthographic({\n        near = this.near,\n        far = this.far,\n        left = this.left || -1,\n        right = this.right || 1,\n        bottom = this.bottom || -1,\n        top = this.top || 1,\n        zoom = this.zoom,\n    } = {}) {\n        Object.assign(this, { near, far, left, right, bottom, top, zoom });\n        left /= zoom;\n        right /= zoom;\n        bottom /= zoom;\n        top /= zoom;\n        this.projectionMatrix.fromOrthogonal({ left, right, bottom, top, near, far });\n        this.type = 'orthographic';\n        return this;\n    }\n\n    updateMatrixWorld() {\n        super.updateMatrixWorld();\n        this.viewMatrix.inverse(this.worldMatrix);\n        this.worldMatrix.getTranslation(this.worldPosition);\n\n        // used for sorting\n        this.projectionViewMatrix.multiply(this.projectionMatrix, this.viewMatrix);\n        return this;\n    }\n\n    lookAt(target) {\n        super.lookAt(target, true);\n        return this;\n    }\n\n    // Project 3D coordinate to 2D point\n    project(v) {\n        v.applyMatrix4(this.viewMatrix);\n        v.applyMatrix4(this.projectionMatrix);\n        return this;\n    }\n\n    // Unproject 2D point to 3D coordinate\n    unproject(v) {\n        v.applyMatrix4(tempMat4.inverse(this.projectionMatrix));\n        v.applyMatrix4(this.worldMatrix);\n        return this;\n    }\n\n    updateFrustum() {\n        if (!this.frustum) {\n            this.frustum = [new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3()];\n        }\n\n        const m = this.projectionViewMatrix;\n        this.frustum[0].set(m[3] - m[0], m[7] - m[4], m[11] - m[8]).constant = m[15] - m[12]; // -x\n        this.frustum[1].set(m[3] + m[0], m[7] + m[4], m[11] + m[8]).constant = m[15] + m[12]; // +x\n        this.frustum[2].set(m[3] + m[1], m[7] + m[5], m[11] + m[9]).constant = m[15] + m[13]; // +y\n        this.frustum[3].set(m[3] - m[1], m[7] - m[5], m[11] - m[9]).constant = m[15] - m[13]; // -y\n        this.frustum[4].set(m[3] - m[2], m[7] - m[6], m[11] - m[10]).constant = m[15] - m[14]; // +z (far)\n        this.frustum[5].set(m[3] + m[2], m[7] + m[6], m[11] + m[10]).constant = m[15] + m[14]; // -z (near)\n\n        for (let i = 0; i < 6; i++) {\n            const invLen = 1.0 / this.frustum[i].distance();\n            this.frustum[i].multiply(invLen);\n            this.frustum[i].constant *= invLen;\n        }\n    }\n\n    frustumIntersectsMesh(node, worldMatrix = node.worldMatrix) {\n        // If no position attribute, treat as frustumCulled false\n        if (!node.geometry.attributes.position) return true;\n\n        if (!node.geometry.bounds || node.geometry.bounds.radius === Infinity) node.geometry.computeBoundingSphere();\n\n        if (!node.geometry.bounds) return true;\n\n        const center = tempVec3a;\n        center.copy(node.geometry.bounds.center);\n        center.applyMatrix4(worldMatrix);\n\n        const radius = node.geometry.bounds.radius * worldMatrix.getMaxScaleOnAxis();\n\n        return this.frustumIntersectsSphere(center, radius);\n    }\n\n    frustumIntersectsSphere(center, radius) {\n        const normal = tempVec3b;\n\n        for (let i = 0; i < 6; i++) {\n            const plane = this.frustum[i];\n            const distance = normal.copy(plane).dot(center) + plane.constant;\n            if (distance < -radius) return false;\n        }\n        return true;\n    }\n}\n", "const EPSILON = 0.000001;\n\n/**\n * Copies the upper-left 3x3 values into the given mat3.\n *\n * @param {mat3} out the receiving 3x3 matrix\n * @param {mat4} a   the source 4x4 matrix\n * @returns {mat3} out\n */\nexport function fromMat4(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[4];\n    out[4] = a[5];\n    out[5] = a[6];\n    out[6] = a[8];\n    out[7] = a[9];\n    out[8] = a[10];\n    return out;\n}\n\n/**\n * Calculates a 3x3 matrix from the given quaternion\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {quat} q Quaternion to create matrix from\n *\n * @returns {mat3} out\n */\nexport function fromQuat(out, q) {\n    let x = q[0],\n        y = q[1],\n        z = q[2],\n        w = q[3];\n    let x2 = x + x;\n    let y2 = y + y;\n    let z2 = z + z;\n\n    let xx = x * x2;\n    let yx = y * x2;\n    let yy = y * y2;\n    let zx = z * x2;\n    let zy = z * y2;\n    let zz = z * z2;\n    let wx = w * x2;\n    let wy = w * y2;\n    let wz = w * z2;\n\n    out[0] = 1 - yy - zz;\n    out[3] = yx - wz;\n    out[6] = zx + wy;\n\n    out[1] = yx + wz;\n    out[4] = 1 - xx - zz;\n    out[7] = zy - wx;\n\n    out[2] = zx - wy;\n    out[5] = zy + wx;\n    out[8] = 1 - xx - yy;\n\n    return out;\n}\n\n/**\n * Copy the values from one mat3 to another\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the source matrix\n * @returns {mat3} out\n */\nexport function copy(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[4] = a[4];\n    out[5] = a[5];\n    out[6] = a[6];\n    out[7] = a[7];\n    out[8] = a[8];\n    return out;\n}\n\n/**\n * Set the components of a mat3 to the given values\n *\n * @param {mat3} out the receiving matrix\n * @returns {mat3} out\n */\nexport function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n    out[0] = m00;\n    out[1] = m01;\n    out[2] = m02;\n    out[3] = m10;\n    out[4] = m11;\n    out[5] = m12;\n    out[6] = m20;\n    out[7] = m21;\n    out[8] = m22;\n    return out;\n}\n\n/**\n * Set a mat3 to the identity matrix\n *\n * @param {mat3} out the receiving matrix\n * @returns {mat3} out\n */\nexport function identity(out) {\n    out[0] = 1;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 1;\n    out[5] = 0;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 1;\n    return out;\n}\n\n/**\n * Transpose the values of a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the source matrix\n * @returns {mat3} out\n */\nexport function transpose(out, a) {\n    // If we are transposing ourselves we can skip a few steps but have to cache some values\n    if (out === a) {\n        let a01 = a[1],\n            a02 = a[2],\n            a12 = a[5];\n        out[1] = a[3];\n        out[2] = a[6];\n        out[3] = a01;\n        out[5] = a[7];\n        out[6] = a02;\n        out[7] = a12;\n    } else {\n        out[0] = a[0];\n        out[1] = a[3];\n        out[2] = a[6];\n        out[3] = a[1];\n        out[4] = a[4];\n        out[5] = a[7];\n        out[6] = a[2];\n        out[7] = a[5];\n        out[8] = a[8];\n    }\n\n    return out;\n}\n\n/**\n * Inverts a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the source matrix\n * @returns {mat3} out\n */\nexport function invert(out, a) {\n    let a00 = a[0],\n        a01 = a[1],\n        a02 = a[2];\n    let a10 = a[3],\n        a11 = a[4],\n        a12 = a[5];\n    let a20 = a[6],\n        a21 = a[7],\n        a22 = a[8];\n\n    let b01 = a22 * a11 - a12 * a21;\n    let b11 = -a22 * a10 + a12 * a20;\n    let b21 = a21 * a10 - a11 * a20;\n\n    // Calculate the determinant\n    let det = a00 * b01 + a01 * b11 + a02 * b21;\n\n    if (!det) {\n        return null;\n    }\n    det = 1.0 / det;\n\n    out[0] = b01 * det;\n    out[1] = (-a22 * a01 + a02 * a21) * det;\n    out[2] = (a12 * a01 - a02 * a11) * det;\n    out[3] = b11 * det;\n    out[4] = (a22 * a00 - a02 * a20) * det;\n    out[5] = (-a12 * a00 + a02 * a10) * det;\n    out[6] = b21 * det;\n    out[7] = (-a21 * a00 + a01 * a20) * det;\n    out[8] = (a11 * a00 - a01 * a10) * det;\n    return out;\n}\n\n/**\n * Calculates the determinant of a mat3\n *\n * @param {mat3} a the source matrix\n * @returns {Number} determinant of a\n */\nexport function determinant(a) {\n    let a00 = a[0],\n        a01 = a[1],\n        a02 = a[2];\n    let a10 = a[3],\n        a11 = a[4],\n        a12 = a[5];\n    let a20 = a[6],\n        a21 = a[7],\n        a22 = a[8];\n\n    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);\n}\n\n/**\n * Multiplies two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the first operand\n * @param {mat3} b the second operand\n * @returns {mat3} out\n */\nexport function multiply(out, a, b) {\n    let a00 = a[0],\n        a01 = a[1],\n        a02 = a[2];\n    let a10 = a[3],\n        a11 = a[4],\n        a12 = a[5];\n    let a20 = a[6],\n        a21 = a[7],\n        a22 = a[8];\n\n    let b00 = b[0],\n        b01 = b[1],\n        b02 = b[2];\n    let b10 = b[3],\n        b11 = b[4],\n        b12 = b[5];\n    let b20 = b[6],\n        b21 = b[7],\n        b22 = b[8];\n\n    out[0] = b00 * a00 + b01 * a10 + b02 * a20;\n    out[1] = b00 * a01 + b01 * a11 + b02 * a21;\n    out[2] = b00 * a02 + b01 * a12 + b02 * a22;\n\n    out[3] = b10 * a00 + b11 * a10 + b12 * a20;\n    out[4] = b10 * a01 + b11 * a11 + b12 * a21;\n    out[5] = b10 * a02 + b11 * a12 + b12 * a22;\n\n    out[6] = b20 * a00 + b21 * a10 + b22 * a20;\n    out[7] = b20 * a01 + b21 * a11 + b22 * a21;\n    out[8] = b20 * a02 + b21 * a12 + b22 * a22;\n    return out;\n}\n\n/**\n * Translate a mat3 by the given vector\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the matrix to translate\n * @param {vec2} v vector to translate by\n * @returns {mat3} out\n */\nexport function translate(out, a, v) {\n    let a00 = a[0],\n        a01 = a[1],\n        a02 = a[2],\n        a10 = a[3],\n        a11 = a[4],\n        a12 = a[5],\n        a20 = a[6],\n        a21 = a[7],\n        a22 = a[8],\n        x = v[0],\n        y = v[1];\n\n    out[0] = a00;\n    out[1] = a01;\n    out[2] = a02;\n\n    out[3] = a10;\n    out[4] = a11;\n    out[5] = a12;\n\n    out[6] = x * a00 + y * a10 + a20;\n    out[7] = x * a01 + y * a11 + a21;\n    out[8] = x * a02 + y * a12 + a22;\n    return out;\n}\n\n/**\n * Rotates a mat3 by the given angle\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat3} out\n */\nexport function rotate(out, a, rad) {\n    let a00 = a[0],\n        a01 = a[1],\n        a02 = a[2],\n        a10 = a[3],\n        a11 = a[4],\n        a12 = a[5],\n        a20 = a[6],\n        a21 = a[7],\n        a22 = a[8],\n        s = Math.sin(rad),\n        c = Math.cos(rad);\n\n    out[0] = c * a00 + s * a10;\n    out[1] = c * a01 + s * a11;\n    out[2] = c * a02 + s * a12;\n\n    out[3] = c * a10 - s * a00;\n    out[4] = c * a11 - s * a01;\n    out[5] = c * a12 - s * a02;\n\n    out[6] = a20;\n    out[7] = a21;\n    out[8] = a22;\n    return out;\n}\n\n/**\n * Scales the mat3 by the dimensions in the given vec2\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the matrix to rotate\n * @param {vec2} v the vec2 to scale the matrix by\n * @returns {mat3} out\n **/\nexport function scale(out, a, v) {\n    let x = v[0],\n        y = v[1];\n\n    out[0] = x * a[0];\n    out[1] = x * a[1];\n    out[2] = x * a[2];\n\n    out[3] = y * a[3];\n    out[4] = y * a[4];\n    out[5] = y * a[5];\n\n    out[6] = a[6];\n    out[7] = a[7];\n    out[8] = a[8];\n    return out;\n}\n\n/**\n * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {mat4} a Mat4 to derive the normal matrix from\n *\n * @returns {mat3} out\n */\nexport function normalFromMat4(out, a) {\n    let a00 = a[0],\n        a01 = a[1],\n        a02 = a[2],\n        a03 = a[3];\n    let a10 = a[4],\n        a11 = a[5],\n        a12 = a[6],\n        a13 = a[7];\n    let a20 = a[8],\n        a21 = a[9],\n        a22 = a[10],\n        a23 = a[11];\n    let a30 = a[12],\n        a31 = a[13],\n        a32 = a[14],\n        a33 = a[15];\n\n    let b00 = a00 * a11 - a01 * a10;\n    let b01 = a00 * a12 - a02 * a10;\n    let b02 = a00 * a13 - a03 * a10;\n    let b03 = a01 * a12 - a02 * a11;\n    let b04 = a01 * a13 - a03 * a11;\n    let b05 = a02 * a13 - a03 * a12;\n    let b06 = a20 * a31 - a21 * a30;\n    let b07 = a20 * a32 - a22 * a30;\n    let b08 = a20 * a33 - a23 * a30;\n    let b09 = a21 * a32 - a22 * a31;\n    let b10 = a21 * a33 - a23 * a31;\n    let b11 = a22 * a33 - a23 * a32;\n\n    // Calculate the determinant\n    let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n    if (!det) {\n        return null;\n    }\n    det = 1.0 / det;\n\n    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n\n    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n\n    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n\n    return out;\n}\n\n/**\n * Generates a 2D projection matrix with the given bounds\n *\n * @param {mat3} out mat3 frustum matrix will be written into\n * @param {number} width Width of your gl context\n * @param {number} height Height of gl context\n * @returns {mat3} out\n */\nexport function projection(out, width, height) {\n    out[0] = 2 / width;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = -2 / height;\n    out[5] = 0;\n    out[6] = -1;\n    out[7] = 1;\n    out[8] = 1;\n    return out;\n}\n\n/**\n * Adds two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the first operand\n * @param {mat3} b the second operand\n * @returns {mat3} out\n */\nexport function add(out, a, b) {\n    out[0] = a[0] + b[0];\n    out[1] = a[1] + b[1];\n    out[2] = a[2] + b[2];\n    out[3] = a[3] + b[3];\n    out[4] = a[4] + b[4];\n    out[5] = a[5] + b[5];\n    out[6] = a[6] + b[6];\n    out[7] = a[7] + b[7];\n    out[8] = a[8] + b[8];\n    return out;\n}\n\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the first operand\n * @param {mat3} b the second operand\n * @returns {mat3} out\n */\nexport function subtract(out, a, b) {\n    out[0] = a[0] - b[0];\n    out[1] = a[1] - b[1];\n    out[2] = a[2] - b[2];\n    out[3] = a[3] - b[3];\n    out[4] = a[4] - b[4];\n    out[5] = a[5] - b[5];\n    out[6] = a[6] - b[6];\n    out[7] = a[7] - b[7];\n    out[8] = a[8] - b[8];\n    return out;\n}\n\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat3} out\n */\nexport function multiplyScalar(out, a, b) {\n    out[0] = a[0] * b;\n    out[1] = a[1] * b;\n    out[2] = a[2] * b;\n    out[3] = a[3] * b;\n    out[4] = a[4] * b;\n    out[5] = a[5] * b;\n    out[6] = a[6] * b;\n    out[7] = a[7] * b;\n    out[8] = a[8] * b;\n    return out;\n}\n", "import * as Mat3Func from './functions/Mat3Func.js';\n\nexport class Mat3 extends Array {\n    constructor(m00 = 1, m01 = 0, m02 = 0, m10 = 0, m11 = 1, m12 = 0, m20 = 0, m21 = 0, m22 = 1) {\n        super(m00, m01, m02, m10, m11, m12, m20, m21, m22);\n        return this;\n    }\n\n    set(m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n        if (m00.length) return this.copy(m00);\n        Mat3Func.set(this, m00, m01, m02, m10, m11, m12, m20, m21, m22);\n        return this;\n    }\n\n    translate(v, m = this) {\n        Mat3Func.translate(this, m, v);\n        return this;\n    }\n\n    rotate(v, m = this) {\n        Mat3Func.rotate(this, m, v);\n        return this;\n    }\n\n    scale(v, m = this) {\n        Mat3Func.scale(this, m, v);\n        return this;\n    }\n\n    multiply(ma, mb) {\n        if (mb) {\n            Mat3Func.multiply(this, ma, mb);\n        } else {\n            Mat3Func.multiply(this, this, ma);\n        }\n        return this;\n    }\n\n    identity() {\n        Mat3Func.identity(this);\n        return this;\n    }\n\n    copy(m) {\n        Mat3Func.copy(this, m);\n        return this;\n    }\n\n    fromMatrix4(m) {\n        Mat3Func.fromMat4(this, m);\n        return this;\n    }\n\n    fromQuaternion(q) {\n        Mat3Func.fromQuat(this, q);\n        return this;\n    }\n\n    fromBasis(vec3a, vec3b, vec3c) {\n        this.set(vec3a[0], vec3a[1], vec3a[2], vec3b[0], vec3b[1], vec3b[2], vec3c[0], vec3c[1], vec3c[2]);\n        return this;\n    }\n\n    inverse(m = this) {\n        Mat3Func.invert(this, m);\n        return this;\n    }\n\n    getNormalMatrix(m) {\n        Mat3Func.normalFromMat4(this, m);\n        return this;\n    }\n}\n", "import { Transform } from './Transform.js';\nimport { Mat3 } from '../math/Mat3.js';\nimport { Mat4 } from '../math/Mat4.js';\n\nlet ID = 0;\n\nexport class Mesh extends Transform {\n    constructor(gl, { geometry, program, mode = gl.TRIANGLES, frustumCulled = true, renderOrder = 0 } = {}) {\n        super();\n        if (!gl.canvas) console.error('gl not passed as first argument to Mesh');\n        this.gl = gl;\n        this.id = ID++;\n        this.geometry = geometry;\n        this.program = program;\n        this.mode = mode;\n\n        // Used to skip frustum culling\n        this.frustumCulled = frustumCulled;\n\n        // Override sorting to force an order\n        this.renderOrder = renderOrder;\n        this.modelViewMatrix = new Mat4();\n        this.normalMatrix = new Mat3();\n        this.beforeRenderCallbacks = [];\n        this.afterRenderCallbacks = [];\n    }\n\n    onBeforeRender(f) {\n        this.beforeRenderCallbacks.push(f);\n        return this;\n    }\n\n    onAfterRender(f) {\n        this.afterRenderCallbacks.push(f);\n        return this;\n    }\n\n    draw({ camera } = {}) {\n        if (camera) {\n            // Add empty matrix uniforms to program if unset\n            if (!this.program.uniforms.modelMatrix) {\n                Object.assign(this.program.uniforms, {\n                    modelMatrix: { value: null },\n                    viewMatrix: { value: null },\n                    modelViewMatrix: { value: null },\n                    normalMatrix: { value: null },\n                    projectionMatrix: { value: null },\n                    cameraPosition: { value: null },\n                });\n            }\n\n            // Set the matrix uniforms\n            this.program.uniforms.projectionMatrix.value = camera.projectionMatrix;\n            this.program.uniforms.cameraPosition.value = camera.worldPosition;\n            this.program.uniforms.viewMatrix.value = camera.viewMatrix;\n            this.modelViewMatrix.multiply(camera.viewMatrix, this.worldMatrix);\n            this.normalMatrix.getNormalMatrix(this.modelViewMatrix);\n            this.program.uniforms.modelMatrix.value = this.worldMatrix;\n            this.program.uniforms.modelViewMatrix.value = this.modelViewMatrix;\n            this.program.uniforms.normalMatrix.value = this.normalMatrix;\n        }\n        this.beforeRenderCallbacks.forEach((f) => f && f({ mesh: this, camera }));\n\n        // determine if faces need to be flipped - when mesh scaled negatively\n        let flipFaces = this.program.cullFace && this.worldMatrix.determinant() < 0;\n        this.program.use({ flipFaces });\n        this.geometry.draw({ mode: this.mode, program: this.program });\n        this.afterRenderCallbacks.forEach((f) => f && f({ mesh: this, camera }));\n    }\n}\n", "// TODO: delete texture\n// TODO: use texSubImage2D for updates (video or when loaded)\n// TODO: need? encoding = linearEncoding\n// TODO: support non-compressed mipmaps uploads\n\nconst emptyPixel = new Uint8Array(4);\n\nfunction isPowerOf2(value) {\n    return (value & (value - 1)) === 0;\n}\n\nlet ID = 1;\n\nexport class Texture {\n    constructor(\n        gl,\n        {\n            image,\n            target = gl.TEXTURE_2D,\n            type = gl.UNSIGNED_BYTE,\n            format = gl.RGBA,\n            internalFormat = format,\n            wrapS = gl.CLAMP_TO_EDGE,\n            wrapT = gl.CLAMP_TO_EDGE,\n            generateMipmaps = true,\n            minFilter = generateMipmaps ? gl.NEAREST_MIPMAP_LINEAR : gl.LINEAR,\n            magFilter = gl.LINEAR,\n            premultiplyAlpha = false,\n            unpackAlignment = 4,\n            flipY = target == gl.TEXTURE_2D ? true : false,\n            anisotropy = 0,\n            level = 0,\n            width, // used for RenderTargets or Data Textures\n            height = width,\n        } = {}\n    ) {\n        this.gl = gl;\n        this.id = ID++;\n\n        this.image = image;\n        this.target = target;\n        this.type = type;\n        this.format = format;\n        this.internalFormat = internalFormat;\n        this.minFilter = minFilter;\n        this.magFilter = magFilter;\n        this.wrapS = wrapS;\n        this.wrapT = wrapT;\n        this.generateMipmaps = generateMipmaps;\n        this.premultiplyAlpha = premultiplyAlpha;\n        this.unpackAlignment = unpackAlignment;\n        this.flipY = flipY;\n        this.anisotropy = Math.min(anisotropy, this.gl.renderer.parameters.maxAnisotropy);\n        this.level = level;\n        this.width = width;\n        this.height = height;\n        this.texture = this.gl.createTexture();\n\n        this.store = {\n            image: null,\n        };\n\n        // Alias for state store to avoid redundant calls for global state\n        this.glState = this.gl.renderer.state;\n\n        // State store to avoid redundant calls for per-texture state\n        this.state = {};\n        this.state.minFilter = this.gl.NEAREST_MIPMAP_LINEAR;\n        this.state.magFilter = this.gl.LINEAR;\n        this.state.wrapS = this.gl.REPEAT;\n        this.state.wrapT = this.gl.REPEAT;\n        this.state.anisotropy = 0;\n    }\n\n    bind() {\n        // Already bound to active texture unit\n        if (this.glState.textureUnits[this.glState.activeTextureUnit] === this.id) return;\n        this.gl.bindTexture(this.target, this.texture);\n        this.glState.textureUnits[this.glState.activeTextureUnit] = this.id;\n    }\n\n    update(textureUnit = 0) {\n        const needsUpdate = !(this.image === this.store.image && !this.needsUpdate);\n\n        // Make sure that texture is bound to its texture unit\n        if (needsUpdate || this.glState.textureUnits[textureUnit] !== this.id) {\n            // set active texture unit to perform texture functions\n            this.gl.renderer.activeTexture(textureUnit);\n            this.bind();\n        }\n\n        if (!needsUpdate) return;\n        this.needsUpdate = false;\n\n        if (this.flipY !== this.glState.flipY) {\n            this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, this.flipY);\n            this.glState.flipY = this.flipY;\n        }\n\n        if (this.premultiplyAlpha !== this.glState.premultiplyAlpha) {\n            this.gl.pixelStorei(this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.premultiplyAlpha);\n            this.glState.premultiplyAlpha = this.premultiplyAlpha;\n        }\n\n        if (this.unpackAlignment !== this.glState.unpackAlignment) {\n            this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, this.unpackAlignment);\n            this.glState.unpackAlignment = this.unpackAlignment;\n        }\n\n        if (this.minFilter !== this.state.minFilter) {\n            this.gl.texParameteri(this.target, this.gl.TEXTURE_MIN_FILTER, this.minFilter);\n            this.state.minFilter = this.minFilter;\n        }\n\n        if (this.magFilter !== this.state.magFilter) {\n            this.gl.texParameteri(this.target, this.gl.TEXTURE_MAG_FILTER, this.magFilter);\n            this.state.magFilter = this.magFilter;\n        }\n\n        if (this.wrapS !== this.state.wrapS) {\n            this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_S, this.wrapS);\n            this.state.wrapS = this.wrapS;\n        }\n\n        if (this.wrapT !== this.state.wrapT) {\n            this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_T, this.wrapT);\n            this.state.wrapT = this.wrapT;\n        }\n\n        if (this.anisotropy && this.anisotropy !== this.state.anisotropy) {\n            this.gl.texParameterf(\n                this.target,\n                this.gl.renderer.getExtension('EXT_texture_filter_anisotropic').TEXTURE_MAX_ANISOTROPY_EXT,\n                this.anisotropy\n            );\n            this.state.anisotropy = this.anisotropy;\n        }\n\n        if (this.image) {\n            if (this.image.width) {\n                this.width = this.image.width;\n                this.height = this.image.height;\n            }\n\n            if (this.target === this.gl.TEXTURE_CUBE_MAP) {\n                // For cube maps\n                for (let i = 0; i < 6; i++) {\n                    this.gl.texImage2D(\n                        this.gl.TEXTURE_CUBE_MAP_POSITIVE_X + i,\n                        this.level,\n                        this.internalFormat,\n                        this.format,\n                        this.type,\n                        this.image[i]\n                    );\n                }\n            } else if (ArrayBuffer.isView(this.image)) {\n                // Data texture\n                this.gl.texImage2D(this.target, this.level, this.internalFormat, this.width, this.height, 0, this.format, this.type, this.image);\n            } else if (this.image.isCompressedTexture) {\n                // Compressed texture\n                for (let level = 0; level < this.image.length; level++) {\n                    this.gl.compressedTexImage2D(\n                        this.target,\n                        level,\n                        this.internalFormat,\n                        this.image[level].width,\n                        this.image[level].height,\n                        0,\n                        this.image[level].data\n                    );\n                }\n            } else {\n                // Regular texture\n                this.gl.texImage2D(this.target, this.level, this.internalFormat, this.format, this.type, this.image);\n            }\n\n            if (this.generateMipmaps) {\n                // For WebGL1, if not a power of 2, turn off mips, set wrapping to clamp to edge and minFilter to linear\n                if (!this.gl.renderer.isWebgl2 && (!isPowerOf2(this.image.width) || !isPowerOf2(this.image.height))) {\n                    this.generateMipmaps = false;\n                    this.wrapS = this.wrapT = this.gl.CLAMP_TO_EDGE;\n                    this.minFilter = this.gl.LINEAR;\n                } else {\n                    this.gl.generateMipmap(this.target);\n                }\n            }\n\n            // Callback for when data is pushed to GPU\n            this.onUpdate && this.onUpdate();\n        } else {\n            if (this.target === this.gl.TEXTURE_CUBE_MAP) {\n                // Upload empty pixel for each side while no image to avoid errors while image or video loading\n                for (let i = 0; i < 6; i++) {\n                    this.gl.texImage2D(\n                        this.gl.TEXTURE_CUBE_MAP_POSITIVE_X + i,\n                        0,\n                        this.gl.RGBA,\n                        1,\n                        1,\n                        0,\n                        this.gl.RGBA,\n                        this.gl.UNSIGNED_BYTE,\n                        emptyPixel\n                    );\n                }\n            } else if (this.width) {\n                // image intentionally left null for RenderTarget\n                this.gl.texImage2D(this.target, this.level, this.internalFormat, this.width, this.height, 0, this.format, this.type, null);\n            } else {\n                // Upload empty pixel if no image to avoid errors while image or video loading\n                this.gl.texImage2D(this.target, 0, this.gl.RGBA, 1, 1, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, emptyPixel);\n            }\n        }\n        this.store.image = this.image;\n    }\n}\n", "const EPSILON = 0.000001;\n\n/**\n * Copy the values from one vec2 to another\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the source vector\n * @returns {vec2} out\n */\nexport function copy(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    return out;\n}\n\n/**\n * Set the components of a vec2 to the given values\n *\n * @param {vec2} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @returns {vec2} out\n */\nexport function set(out, x, y) {\n    out[0] = x;\n    out[1] = y;\n    return out;\n}\n\n/**\n * Adds two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nexport function add(out, a, b) {\n    out[0] = a[0] + b[0];\n    out[1] = a[1] + b[1];\n    return out;\n}\n\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nexport function subtract(out, a, b) {\n    out[0] = a[0] - b[0];\n    out[1] = a[1] - b[1];\n    return out;\n}\n\n/**\n * Multiplies two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nexport function multiply(out, a, b) {\n    out[0] = a[0] * b[0];\n    out[1] = a[1] * b[1];\n    return out;\n}\n\n/**\n * Divides two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nexport function divide(out, a, b) {\n    out[0] = a[0] / b[0];\n    out[1] = a[1] / b[1];\n    return out;\n}\n\n/**\n * Scales a vec2 by a scalar number\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec2} out\n */\nexport function scale(out, a, b) {\n    out[0] = a[0] * b;\n    out[1] = a[1] * b;\n    return out;\n}\n\n/**\n * Calculates the euclidian distance between two vec2's\n *\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {Number} distance between a and b\n */\nexport function distance(a, b) {\n    var x = b[0] - a[0],\n        y = b[1] - a[1];\n    return Math.sqrt(x * x + y * y);\n}\n\n/**\n * Calculates the squared euclidian distance between two vec2's\n *\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {Number} squared distance between a and b\n */\nexport function squaredDistance(a, b) {\n    var x = b[0] - a[0],\n        y = b[1] - a[1];\n    return x * x + y * y;\n}\n\n/**\n * Calculates the length of a vec2\n *\n * @param {vec2} a vector to calculate length of\n * @returns {Number} length of a\n */\nexport function length(a) {\n    var x = a[0],\n        y = a[1];\n    return Math.sqrt(x * x + y * y);\n}\n\n/**\n * Calculates the squared length of a vec2\n *\n * @param {vec2} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\nexport function squaredLength(a) {\n    var x = a[0],\n        y = a[1];\n    return x * x + y * y;\n}\n\n/**\n * Negates the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to negate\n * @returns {vec2} out\n */\nexport function negate(out, a) {\n    out[0] = -a[0];\n    out[1] = -a[1];\n    return out;\n}\n\n/**\n * Returns the inverse of the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to invert\n * @returns {vec2} out\n */\nexport function inverse(out, a) {\n    out[0] = 1.0 / a[0];\n    out[1] = 1.0 / a[1];\n    return out;\n}\n\n/**\n * Normalize a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to normalize\n * @returns {vec2} out\n */\nexport function normalize(out, a) {\n    var x = a[0],\n        y = a[1];\n    var len = x * x + y * y;\n    if (len > 0) {\n        //TODO: evaluate use of glm_invsqrt here?\n        len = 1 / Math.sqrt(len);\n    }\n    out[0] = a[0] * len;\n    out[1] = a[1] * len;\n    return out;\n}\n\n/**\n * Calculates the dot product of two vec2's\n *\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {Number} dot product of a and b\n */\nexport function dot(a, b) {\n    return a[0] * b[0] + a[1] * b[1];\n}\n\n/**\n * Computes the cross product of two vec2's\n * Note that the cross product returns a scalar\n *\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {Number} cross product of a and b\n */\nexport function cross(a, b) {\n    return a[0] * b[1] - a[1] * b[0];\n}\n\n/**\n * Performs a linear interpolation between two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {vec2} out\n */\nexport function lerp(out, a, b, t) {\n    var ax = a[0],\n        ay = a[1];\n    out[0] = ax + t * (b[0] - ax);\n    out[1] = ay + t * (b[1] - ay);\n    return out;\n}\n\n/**\n * Transforms the vec2 with a mat2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to transform\n * @param {mat2} m matrix to transform with\n * @returns {vec2} out\n */\nexport function transformMat2(out, a, m) {\n    var x = a[0],\n        y = a[1];\n    out[0] = m[0] * x + m[2] * y;\n    out[1] = m[1] * x + m[3] * y;\n    return out;\n}\n\n/**\n * Transforms the vec2 with a mat2d\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to transform\n * @param {mat2d} m matrix to transform with\n * @returns {vec2} out\n */\nexport function transformMat2d(out, a, m) {\n    var x = a[0],\n        y = a[1];\n    out[0] = m[0] * x + m[2] * y + m[4];\n    out[1] = m[1] * x + m[3] * y + m[5];\n    return out;\n}\n\n/**\n * Transforms the vec2 with a mat3\n * 3rd vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to transform\n * @param {mat3} m matrix to transform with\n * @returns {vec2} out\n */\nexport function transformMat3(out, a, m) {\n    var x = a[0],\n        y = a[1];\n    out[0] = m[0] * x + m[3] * y + m[6];\n    out[1] = m[1] * x + m[4] * y + m[7];\n    return out;\n}\n\n/**\n * Transforms the vec2 with a mat4\n * 3rd vector component is implicitly '0'\n * 4th vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to transform\n * @param {mat4} m matrix to transform with\n * @returns {vec2} out\n */\nexport function transformMat4(out, a, m) {\n    let x = a[0];\n    let y = a[1];\n    out[0] = m[0] * x + m[4] * y + m[12];\n    out[1] = m[1] * x + m[5] * y + m[13];\n    return out;\n}\n\n/**\n * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)\n *\n * @param {vec2} a The first vector.\n * @param {vec2} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nexport function exactEquals(a, b) {\n    return a[0] === b[0] && a[1] === b[1];\n}\n", "import * as Vec2Func from './functions/Vec2Func.js';\n\nexport class Vec2 extends Array {\n    constructor(x = 0, y = x) {\n        super(x, y);\n        return this;\n    }\n\n    get x() {\n        return this[0];\n    }\n\n    get y() {\n        return this[1];\n    }\n\n    set x(v) {\n        this[0] = v;\n    }\n\n    set y(v) {\n        this[1] = v;\n    }\n\n    set(x, y = x) {\n        if (x.length) return this.copy(x);\n        Vec2Func.set(this, x, y);\n        return this;\n    }\n\n    copy(v) {\n        Vec2Func.copy(this, v);\n        return this;\n    }\n\n    add(va, vb) {\n        if (vb) Vec2Func.add(this, va, vb);\n        else Vec2Func.add(this, this, va);\n        return this;\n    }\n\n    sub(va, vb) {\n        if (vb) Vec2Func.subtract(this, va, vb);\n        else Vec2Func.subtract(this, this, va);\n        return this;\n    }\n\n    multiply(v) {\n        if (v.length) Vec2Func.multiply(this, this, v);\n        else Vec2Func.scale(this, this, v);\n        return this;\n    }\n\n    divide(v) {\n        if (v.length) Vec2Func.divide(this, this, v);\n        else Vec2Func.scale(this, this, 1 / v);\n        return this;\n    }\n\n    inverse(v = this) {\n        Vec2Func.inverse(this, v);\n        return this;\n    }\n\n    // Can't use 'length' as Array.prototype uses it\n    len() {\n        return Vec2Func.length(this);\n    }\n\n    distance(v) {\n        if (v) return Vec2Func.distance(this, v);\n        else return Vec2Func.length(this);\n    }\n\n    squaredLen() {\n        return this.squaredDistance();\n    }\n\n    squaredDistance(v) {\n        if (v) return Vec2Func.squaredDistance(this, v);\n        else return Vec2Func.squaredLength(this);\n    }\n\n    negate(v = this) {\n        Vec2Func.negate(this, v);\n        return this;\n    }\n\n    cross(va, vb) {\n        if (vb) return Vec2Func.cross(va, vb);\n        return Vec2Func.cross(this, va);\n    }\n\n    scale(v) {\n        Vec2Func.scale(this, this, v);\n        return this;\n    }\n\n    normalize() {\n        Vec2Func.normalize(this, this);\n        return this;\n    }\n\n    dot(v) {\n        return Vec2Func.dot(this, v);\n    }\n\n    equals(v) {\n        return Vec2Func.exactEquals(this, v);\n    }\n\n    applyMatrix3(mat3) {\n        Vec2Func.transformMat3(this, this, mat3);\n        return this;\n    }\n\n    applyMatrix4(mat4) {\n        Vec2Func.transformMat4(this, this, mat4);\n        return this;\n    }\n\n    lerp(v, a) {\n        Vec2Func.lerp(this, this, v, a);\n        return this;\n    }\n\n    clone() {\n        return new Vec2(this[0], this[1]);\n    }\n\n    fromArray(a, o = 0) {\n        this[0] = a[o];\n        this[1] = a[o + 1];\n        return this;\n    }\n\n    toArray(a = [], o = 0) {\n        a[o] = this[0];\n        a[o + 1] = this[1];\n        return a;\n    }\n}\n", "import * as Vec4Func from './functions/Vec4Func.js';\n\nexport class Vec4 extends Array {\n    constructor(x = 0, y = x, z = x, w = x) {\n        super(x, y, z, w);\n        return this;\n    }\n\n    get x() {\n        return this[0];\n    }\n\n    get y() {\n        return this[1];\n    }\n\n    get z() {\n        return this[2];\n    }\n\n    get w() {\n        return this[3];\n    }\n\n    set x(v) {\n        this[0] = v;\n    }\n\n    set y(v) {\n        this[1] = v;\n    }\n\n    set z(v) {\n        this[2] = v;\n    }\n\n    set w(v) {\n        this[3] = v;\n    }\n\n    set(x, y = x, z = x, w = x) {\n        if (x.length) return this.copy(x);\n        Vec4Func.set(this, x, y, z, w);\n        return this;\n    }\n\n    copy(v) {\n        Vec4Func.copy(this, v);\n        return this;\n    }\n\n    normalize() {\n        Vec4Func.normalize(this, this);\n        return this;\n    }\n\n    multiply(v) {\n        Vec4Func.scale(this, this, v);\n        return this;\n    }\n\n    dot(v) {\n        return Vec4Func.dot(this, v);\n    }\n\n    fromArray(a, o = 0) {\n        this[0] = a[o];\n        this[1] = a[o + 1];\n        this[2] = a[o + 2];\n        this[3] = a[o + 3];\n        return this;\n    }\n\n    toArray(a = [], o = 0) {\n        a[o] = this[0];\n        a[o + 1] = this[1];\n        a[o + 2] = this[2];\n        a[o + 3] = this[3];\n        return a;\n    }\n}\n", "import { Geometry } from '../core/Geometry.js';\n\nexport class Plane extends Geometry {\n    constructor(gl, { width = 1, height = 1, widthSegments = 1, heightSegments = 1, attributes = {} } = {}) {\n        const wSegs = widthSegments;\n        const hSegs = heightSegments;\n\n        // Determine length of arrays\n        const num = (wSegs + 1) * (hSegs + 1);\n        const numIndices = wSegs * hSegs * 6;\n\n        // Generate empty arrays once\n        const position = new Float32Array(num * 3);\n        const normal = new Float32Array(num * 3);\n        const uv = new Float32Array(num * 2);\n        const index = numIndices > 65536 ? new Uint32Array(numIndices) : new Uint16Array(numIndices);\n\n        Plane.buildPlane(position, normal, uv, index, width, height, 0, wSegs, hSegs);\n\n        Object.assign(attributes, {\n            position: { size: 3, data: position },\n            normal: { size: 3, data: normal },\n            uv: { size: 2, data: uv },\n            index: { data: index },\n        });\n\n        super(gl, attributes);\n    }\n\n    static buildPlane(position, normal, uv, index, width, height, depth, wSegs, hSegs, u = 0, v = 1, w = 2, uDir = 1, vDir = -1, i = 0, ii = 0) {\n        const io = i;\n        const segW = width / wSegs;\n        const segH = height / hSegs;\n\n        for (let iy = 0; iy <= hSegs; iy++) {\n            let y = iy * segH - height / 2;\n            for (let ix = 0; ix <= wSegs; ix++, i++) {\n                let x = ix * segW - width / 2;\n\n                position[i * 3 + u] = x * uDir;\n                position[i * 3 + v] = y * vDir;\n                position[i * 3 + w] = depth / 2;\n\n                normal[i * 3 + u] = 0;\n                normal[i * 3 + v] = 0;\n                normal[i * 3 + w] = depth >= 0 ? 1 : -1;\n\n                uv[i * 2] = ix / wSegs;\n                uv[i * 2 + 1] = 1 - iy / hSegs;\n\n                if (iy === hSegs || ix === wSegs) continue;\n                let a = io + ix + iy * (wSegs + 1);\n                let b = io + ix + (iy + 1) * (wSegs + 1);\n                let c = io + ix + (iy + 1) * (wSegs + 1) + 1;\n                let d = io + ix + iy * (wSegs + 1) + 1;\n\n                index[ii * 6] = a;\n                index[ii * 6 + 1] = b;\n                index[ii * 6 + 2] = d;\n                index[ii * 6 + 3] = b;\n                index[ii * 6 + 4] = c;\n                index[ii * 6 + 5] = d;\n                ii++;\n            }\n        }\n    }\n}\n", "import { Geometry } from '../core/Geometry.js';\nimport { Plane } from './Plane.js';\n\nexport class Box extends Geometry {\n    constructor(gl, { width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1, attributes = {} } = {}) {\n        const wSegs = widthSegments;\n        const hSegs = heightSegments;\n        const dSegs = depthSegments;\n\n        const num = (wSegs + 1) * (hSegs + 1) * 2 + (wSegs + 1) * (dSegs + 1) * 2 + (hSegs + 1) * (dSegs + 1) * 2;\n        const numIndices = (wSegs * hSegs * 2 + wSegs * dSegs * 2 + hSegs * dSegs * 2) * 6;\n\n        const position = new Float32Array(num * 3);\n        const normal = new Float32Array(num * 3);\n        const uv = new Float32Array(num * 2);\n        const index = num > 65536 ? new Uint32Array(numIndices) : new Uint16Array(numIndices);\n\n        let i = 0;\n        let ii = 0;\n\n        // left, right\n        Plane.buildPlane(position, normal, uv, index, depth, height, width, dSegs, hSegs, 2, 1, 0, -1, -1, i, ii);\n        i += (dSegs + 1) * (hSegs + 1);\n        ii += dSegs * hSegs;\n\n        Plane.buildPlane(position, normal, uv, index, depth, height, -width, dSegs, hSegs, 2, 1, 0, 1, -1, i, ii);\n        i += (dSegs + 1) * (hSegs + 1);\n        ii += dSegs * hSegs;\n\n        // top, bottom\n        Plane.buildPlane(position, normal, uv, index, width, depth, height, dSegs, wSegs, 0, 2, 1, 1, 1, i, ii);\n        i += (wSegs + 1) * (dSegs + 1);\n        ii += wSegs * dSegs;\n\n        Plane.buildPlane(position, normal, uv, index, width, depth, -height, dSegs, wSegs, 0, 2, 1, 1, -1, i, ii);\n        i += (wSegs + 1) * (dSegs + 1);\n        ii += wSegs * dSegs;\n\n        // front, back\n        Plane.buildPlane(position, normal, uv, index, width, height, -depth, wSegs, hSegs, 0, 1, 2, -1, -1, i, ii);\n        i += (wSegs + 1) * (hSegs + 1);\n        ii += wSegs * hSegs;\n\n        Plane.buildPlane(position, normal, uv, index, width, height, depth, wSegs, hSegs, 0, 1, 2, 1, -1, i, ii);\n\n        Object.assign(attributes, {\n            position: { size: 3, data: position },\n            normal: { size: 3, data: normal },\n            uv: { size: 2, data: uv },\n            index: { data: index },\n        });\n\n        super(gl, attributes);\n    }\n}\n", "import { Geometry } from '../core/Geometry.js';\nimport { Vec3 } from '../math/Vec3.js';\n\nexport class Sphere extends Geometry {\n    constructor(\n        gl,\n        {\n            radius = 0.5,\n            widthSegments = 16,\n            heightSegments = Math.ceil(widthSegments * 0.5),\n            phiStart = 0,\n            phiLength = Math.PI * 2,\n            thetaStart = 0,\n            thetaLength = Math.PI,\n            attributes = {},\n        } = {}\n    ) {\n        const wSegs = widthSegments;\n        const hSegs = heightSegments;\n        const pStart = phiStart;\n        const pLength = phiLength;\n        const tStart = thetaStart;\n        const tLength = thetaLength;\n\n        const num = (wSegs + 1) * (hSegs + 1);\n        const numIndices = wSegs * hSegs * 6;\n\n        const position = new Float32Array(num * 3);\n        const normal = new Float32Array(num * 3);\n        const uv = new Float32Array(num * 2);\n        const index = num > 65536 ? new Uint32Array(numIndices) : new Uint16Array(numIndices);\n\n        let i = 0;\n        let iv = 0;\n        let ii = 0;\n        let te = tStart + tLength;\n        const grid = [];\n\n        let n = new Vec3();\n\n        for (let iy = 0; iy <= hSegs; iy++) {\n            let vRow = [];\n            let v = iy / hSegs;\n            for (let ix = 0; ix <= wSegs; ix++, i++) {\n                let u = ix / wSegs;\n                let x = -radius * Math.cos(pStart + u * pLength) * Math.sin(tStart + v * tLength);\n                let y = radius * Math.cos(tStart + v * tLength);\n                let z = radius * Math.sin(pStart + u * pLength) * Math.sin(tStart + v * tLength);\n\n                position[i * 3] = x;\n                position[i * 3 + 1] = y;\n                position[i * 3 + 2] = z;\n\n                n.set(x, y, z).normalize();\n                normal[i * 3] = n.x;\n                normal[i * 3 + 1] = n.y;\n                normal[i * 3 + 2] = n.z;\n\n                uv[i * 2] = u;\n                uv[i * 2 + 1] = 1 - v;\n\n                vRow.push(iv++);\n            }\n\n            grid.push(vRow);\n        }\n\n        for (let iy = 0; iy < hSegs; iy++) {\n            for (let ix = 0; ix < wSegs; ix++) {\n                let a = grid[iy][ix + 1];\n                let b = grid[iy][ix];\n                let c = grid[iy + 1][ix];\n                let d = grid[iy + 1][ix + 1];\n\n                if (iy !== 0 || tStart > 0) {\n                    index[ii * 3] = a;\n                    index[ii * 3 + 1] = b;\n                    index[ii * 3 + 2] = d;\n                    ii++;\n                }\n                if (iy !== hSegs - 1 || te < Math.PI) {\n                    index[ii * 3] = b;\n                    index[ii * 3 + 1] = c;\n                    index[ii * 3 + 2] = d;\n                    ii++;\n                }\n            }\n        }\n\n        Object.assign(attributes, {\n            position: { size: 3, data: position },\n            normal: { size: 3, data: normal },\n            uv: { size: 2, data: uv },\n            index: { data: index },\n        });\n\n        super(gl, attributes);\n    }\n}\n", "// Based from ThreeJS' OrbitControls class, rewritten using es6 with some additions and subtractions.\n// TODO: abstract event handlers so can be fed from other sources\n// TODO: make scroll zoom more accurate than just >/< zero\n// TODO: be able to pass in new camera position\n\nimport { Vec3 } from '../math/Vec3.js';\nimport { Vec2 } from '../math/Vec2.js';\n\nconst STATE = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, DOLLY_PAN: 3 };\nconst tempVec3 = /* @__PURE__ */ new Vec3();\nconst tempVec2a = /* @__PURE__ */ new Vec2();\nconst tempVec2b = /* @__PURE__ */ new Vec2();\n\nexport function Orbit(\n    object,\n    {\n        element = document,\n        enabled = true,\n        target = new Vec3(),\n        ease = 0.25,\n        inertia = 0.85,\n        enableRotate = true,\n        rotateSpeed = 0.1,\n        autoRotate = false,\n        autoRotateSpeed = 1.0,\n        enableZoom = true,\n        zoomSpeed = 1,\n        zoomStyle = 'dolly',\n        enablePan = true,\n        panSpeed = 0.1,\n        minPolarAngle = 0,\n        maxPolarAngle = Math.PI,\n        minAzimuthAngle = -Infinity,\n        maxAzimuthAngle = Infinity,\n        minDistance = 0,\n        maxDistance = Infinity,\n    } = {}\n) {\n    this.enabled = enabled;\n    this.target = target;\n    this.zoomStyle = zoomStyle;\n\n    // Catch attempts to disable - set to 1 so has no effect\n    ease = ease || 1;\n    inertia = inertia || 0;\n\n    this.minDistance = minDistance;\n    this.maxDistance = maxDistance;\n\n    // current position in sphericalTarget coordinates\n    const sphericalDelta = { radius: 1, phi: 0, theta: 0 };\n    const sphericalTarget = { radius: 1, phi: 0, theta: 0 };\n    const spherical = { radius: 1, phi: 0, theta: 0 };\n    const panDelta = new Vec3();\n\n    // Grab initial position values\n    const offset = new Vec3();\n    offset.copy(object.position).sub(this.target);\n    spherical.radius = sphericalTarget.radius = offset.distance();\n    spherical.theta = sphericalTarget.theta = Math.atan2(offset.x, offset.z);\n    spherical.phi = sphericalTarget.phi = Math.acos(Math.min(Math.max(offset.y / sphericalTarget.radius, -1), 1));\n\n    this.offset = offset;\n\n    this.update = () => {\n        if (autoRotate) {\n            handleAutoRotate();\n        }\n\n        // apply delta\n        sphericalTarget.radius *= sphericalDelta.radius;\n        sphericalTarget.theta += sphericalDelta.theta;\n        sphericalTarget.phi += sphericalDelta.phi;\n\n        // apply boundaries\n        sphericalTarget.theta = Math.max(minAzimuthAngle, Math.min(maxAzimuthAngle, sphericalTarget.theta));\n        sphericalTarget.phi = Math.max(minPolarAngle, Math.min(maxPolarAngle, sphericalTarget.phi));\n        sphericalTarget.radius = Math.max(this.minDistance, Math.min(this.maxDistance, sphericalTarget.radius));\n\n        // ease values\n        spherical.phi += (sphericalTarget.phi - spherical.phi) * ease;\n        spherical.theta += (sphericalTarget.theta - spherical.theta) * ease;\n        spherical.radius += (sphericalTarget.radius - spherical.radius) * ease;\n\n        // apply pan to target. As offset is relative to target, it also shifts\n        this.target.add(panDelta);\n\n        // apply rotation to offset\n        let sinPhiRadius = spherical.radius * Math.sin(Math.max(0.000001, spherical.phi));\n        offset.x = sinPhiRadius * Math.sin(spherical.theta);\n        offset.y = spherical.radius * Math.cos(spherical.phi);\n        offset.z = sinPhiRadius * Math.cos(spherical.theta);\n\n        // Apply updated values to object\n        object.position.copy(this.target).add(offset);\n        object.lookAt(this.target);\n\n        // Apply inertia to values\n        sphericalDelta.theta *= inertia;\n        sphericalDelta.phi *= inertia;\n        panDelta.multiply(inertia);\n\n        // Reset scale every frame to avoid applying scale multiple times\n        sphericalDelta.radius = 1;\n    };\n\n    // Updates internals with new position\n    this.forcePosition = () => {\n        offset.copy(object.position).sub(this.target);\n        spherical.radius = sphericalTarget.radius = offset.distance();\n        spherical.theta = sphericalTarget.theta = Math.atan2(offset.x, offset.z);\n        spherical.phi = sphericalTarget.phi = Math.acos(Math.min(Math.max(offset.y / sphericalTarget.radius, -1), 1));\n        object.lookAt(this.target);\n    };\n\n    // Everything below here just updates panDelta and sphericalDelta\n    // Using those two objects' values, the orbit is calculated\n\n    const rotateStart = new Vec2();\n    const panStart = new Vec2();\n    const dollyStart = new Vec2();\n\n    let state = STATE.NONE;\n    this.mouseButtons = { ORBIT: 0, ZOOM: 1, PAN: 2 };\n\n    function getZoomScale() {\n        return Math.pow(0.95, zoomSpeed);\n    }\n\n    function panLeft(distance, m) {\n        tempVec3.set(m[0], m[1], m[2]);\n        tempVec3.multiply(-distance);\n        panDelta.add(tempVec3);\n    }\n\n    function panUp(distance, m) {\n        tempVec3.set(m[4], m[5], m[6]);\n        tempVec3.multiply(distance);\n        panDelta.add(tempVec3);\n    }\n\n    const pan = (deltaX, deltaY) => {\n        let el = element === document ? document.body : element;\n        tempVec3.copy(object.position).sub(this.target);\n        let targetDistance = tempVec3.distance();\n        targetDistance *= Math.tan((((object.fov || 45) / 2) * Math.PI) / 180.0);\n        panLeft((2 * deltaX * targetDistance) / el.clientHeight, object.matrix);\n        panUp((2 * deltaY * targetDistance) / el.clientHeight, object.matrix);\n    };\n\n    const dolly = (dollyScale) => {\n        if (this.zoomStyle === 'dolly') sphericalDelta.radius /= dollyScale;\n        else {\n            object.fov /= dollyScale;\n            if (object.type === 'orthographic') object.orthographic();\n            else object.perspective();\n        }\n    };\n\n    function handleAutoRotate() {\n        const angle = ((2 * Math.PI) / 60 / 60) * autoRotateSpeed;\n        sphericalDelta.theta -= angle;\n    }\n\n    function handleMoveRotate(x, y) {\n        tempVec2a.set(x, y);\n        tempVec2b.sub(tempVec2a, rotateStart).multiply(rotateSpeed);\n        let el = element === document ? document.body : element;\n        sphericalDelta.theta -= (2 * Math.PI * tempVec2b.x) / el.clientHeight;\n        sphericalDelta.phi -= (2 * Math.PI * tempVec2b.y) / el.clientHeight;\n        rotateStart.copy(tempVec2a);\n    }\n\n    function handleMouseMoveDolly(e) {\n        tempVec2a.set(e.clientX, e.clientY);\n        tempVec2b.sub(tempVec2a, dollyStart);\n        if (tempVec2b.y > 0) {\n            dolly(getZoomScale());\n        } else if (tempVec2b.y < 0) {\n            dolly(1 / getZoomScale());\n        }\n        dollyStart.copy(tempVec2a);\n    }\n\n    function handleMovePan(x, y) {\n        tempVec2a.set(x, y);\n        tempVec2b.sub(tempVec2a, panStart).multiply(panSpeed);\n        pan(tempVec2b.x, tempVec2b.y);\n        panStart.copy(tempVec2a);\n    }\n\n    function handleTouchStartDollyPan(e) {\n        if (enableZoom) {\n            let dx = e.touches[0].pageX - e.touches[1].pageX;\n            let dy = e.touches[0].pageY - e.touches[1].pageY;\n            let distance = Math.sqrt(dx * dx + dy * dy);\n            dollyStart.set(0, distance);\n        }\n\n        if (enablePan) {\n            let x = 0.5 * (e.touches[0].pageX + e.touches[1].pageX);\n            let y = 0.5 * (e.touches[0].pageY + e.touches[1].pageY);\n            panStart.set(x, y);\n        }\n    }\n\n    function handleTouchMoveDollyPan(e) {\n        if (enableZoom) {\n            let dx = e.touches[0].pageX - e.touches[1].pageX;\n            let dy = e.touches[0].pageY - e.touches[1].pageY;\n            let distance = Math.sqrt(dx * dx + dy * dy);\n            tempVec2a.set(0, distance);\n            tempVec2b.set(0, Math.pow(tempVec2a.y / dollyStart.y, zoomSpeed));\n            dolly(tempVec2b.y);\n            dollyStart.copy(tempVec2a);\n        }\n\n        if (enablePan) {\n            let x = 0.5 * (e.touches[0].pageX + e.touches[1].pageX);\n            let y = 0.5 * (e.touches[0].pageY + e.touches[1].pageY);\n            handleMovePan(x, y);\n        }\n    }\n\n    const onMouseDown = (e) => {\n        if (!this.enabled) return;\n\n        switch (e.button) {\n            case this.mouseButtons.ORBIT:\n                if (enableRotate === false) return;\n                rotateStart.set(e.clientX, e.clientY);\n                state = STATE.ROTATE;\n                break;\n            case this.mouseButtons.ZOOM:\n                if (enableZoom === false) return;\n                dollyStart.set(e.clientX, e.clientY);\n                state = STATE.DOLLY;\n                break;\n            case this.mouseButtons.PAN:\n                if (enablePan === false) return;\n                panStart.set(e.clientX, e.clientY);\n                state = STATE.PAN;\n                break;\n        }\n\n        if (state !== STATE.NONE) {\n            window.addEventListener('mousemove', onMouseMove, false);\n            window.addEventListener('mouseup', onMouseUp, false);\n        }\n    };\n\n    const onMouseMove = (e) => {\n        if (!this.enabled) return;\n\n        switch (state) {\n            case STATE.ROTATE:\n                if (enableRotate === false) return;\n                handleMoveRotate(e.clientX, e.clientY);\n                break;\n            case STATE.DOLLY:\n                if (enableZoom === false) return;\n                handleMouseMoveDolly(e);\n                break;\n            case STATE.PAN:\n                if (enablePan === false) return;\n                handleMovePan(e.clientX, e.clientY);\n                break;\n        }\n    };\n\n    const onMouseUp = () => {\n        window.removeEventListener('mousemove', onMouseMove, false);\n        window.removeEventListener('mouseup', onMouseUp, false);\n        state = STATE.NONE;\n    };\n\n    const onMouseWheel = (e) => {\n        if (!this.enabled || !enableZoom || (state !== STATE.NONE && state !== STATE.ROTATE)) return;\n        e.stopPropagation();\n        e.preventDefault();\n\n        if (e.deltaY < 0) {\n            dolly(1 / getZoomScale());\n        } else if (e.deltaY > 0) {\n            dolly(getZoomScale());\n        }\n    };\n\n    const onTouchStart = (e) => {\n        if (!this.enabled) return;\n        e.preventDefault();\n\n        switch (e.touches.length) {\n            case 1:\n                if (enableRotate === false) return;\n                rotateStart.set(e.touches[0].pageX, e.touches[0].pageY);\n                state = STATE.ROTATE;\n                break;\n            case 2:\n                if (enableZoom === false && enablePan === false) return;\n                handleTouchStartDollyPan(e);\n                state = STATE.DOLLY_PAN;\n                break;\n            default:\n                state = STATE.NONE;\n        }\n    };\n\n    const onTouchMove = (e) => {\n        if (!this.enabled) return;\n        e.preventDefault();\n        e.stopPropagation();\n\n        switch (e.touches.length) {\n            case 1:\n                if (enableRotate === false) return;\n                handleMoveRotate(e.touches[0].pageX, e.touches[0].pageY);\n                break;\n            case 2:\n                if (enableZoom === false && enablePan === false) return;\n                handleTouchMoveDollyPan(e);\n                break;\n            default:\n                state = STATE.NONE;\n        }\n    };\n\n    const onTouchEnd = () => {\n        if (!this.enabled) return;\n        state = STATE.NONE;\n    };\n\n    const onContextMenu = (e) => {\n        if (!this.enabled) return;\n        e.preventDefault();\n    };\n\n    function addHandlers() {\n        element.addEventListener('contextmenu', onContextMenu, false);\n        element.addEventListener('mousedown', onMouseDown, false);\n        element.addEventListener('wheel', onMouseWheel, { passive: false });\n        element.addEventListener('touchstart', onTouchStart, { passive: false });\n        element.addEventListener('touchend', onTouchEnd, false);\n        element.addEventListener('touchmove', onTouchMove, { passive: false });\n    }\n\n    this.remove = function () {\n        element.removeEventListener('contextmenu', onContextMenu);\n        element.removeEventListener('mousedown', onMouseDown);\n        element.removeEventListener('wheel', onMouseWheel);\n        element.removeEventListener('touchstart', onTouchStart);\n        element.removeEventListener('touchend', onTouchEnd);\n        element.removeEventListener('touchmove', onTouchMove);\n        window.removeEventListener('mousemove', onMouseMove);\n        window.removeEventListener('mouseup', onMouseUp);\n    };\n\n    addHandlers();\n}\n", "import { Program } from '../core/Program.js';\n\nconst vertex = /* glsl */ `\n    precision highp float;\n    precision highp int;\n\n    attribute vec3 position;\n    attribute vec3 normal;\n\n    uniform mat3 normalMatrix;\n    uniform mat4 modelViewMatrix;\n    uniform mat4 projectionMatrix;\n\n    varying vec3 vNormal;\n\n    void main() {\n        vNormal = normalize(normalMatrix * normal);\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n`;\n\nconst fragment = /* glsl */ `\n    precision highp float;\n    precision highp int;\n\n    varying vec3 vNormal;\n\n    void main() {\n        gl_FragColor.rgb = normalize(vNormal);\n        gl_FragColor.a = 1.0;\n    }\n`;\n\nexport function NormalProgram(gl) {\n    return new Program(gl, {\n        vertex: vertex,\n        fragment: fragment,\n        cullFace: false,\n    });\n}\n", "import { Vec3 } from '../math/Vec3.js';\nimport { Quat } from '../math/Quat.js';\n\nconst tmpVec3A = /* @__PURE__ */ new Vec3();\nconst tmpVec3B = /* @__PURE__ */ new Vec3();\nconst tmpVec3C = /* @__PURE__ */ new Vec3();\nconst tmpVec3D = /* @__PURE__ */ new Vec3();\n\nconst tmpQuatA = /* @__PURE__ */ new Quat();\nconst tmpQuatB = /* @__PURE__ */ new Quat();\nconst tmpQuatC = /* @__PURE__ */ new Quat();\nconst tmpQuatD = /* @__PURE__ */ new Quat();\n\nexport class GLTFAnimation {\n    constructor(data, weight = 1) {\n        this.data = data;\n        this.elapsed = 0;\n        this.weight = weight;\n\n        // Set to false to not apply modulo to elapsed against duration\n        this.loop = true;\n\n        // Find starting time as exports from blender (perhaps others too) don't always start from 0\n        this.startTime = data.reduce((a, { times }) => Math.min(a, times[0]), Infinity);\n        // Get largest final time in all channels to calculate duration\n        this.endTime = data.reduce((a, { times }) => Math.max(a, times[times.length - 1]), 0);\n        this.duration = this.endTime - this.startTime;\n    }\n\n    update(totalWeight = 1, isSet) {\n        const weight = isSet ? 1 : this.weight / totalWeight;\n        const elapsed = !this.duration\n            ? 0\n            : (this.loop ? this.elapsed % this.duration : Math.min(this.elapsed, this.duration - 0.001)) + this.startTime;\n\n        this.data.forEach(({ node, transform, interpolation, times, values }) => {\n            if (!this.duration) {\n                let val = tmpVec3A;\n                let size = 3;\n                if (transform === 'quaternion') {\n                    val = tmpQuatA;\n                    size = 4;\n                }\n                val.fromArray(values, 0);\n                if (size === 4) node[transform].slerp(val, weight);\n                else node[transform].lerp(val, weight);\n                return;\n            }\n\n            // Get index of two time values elapsed is between\n            const prevIndex =\n                Math.max(\n                    1,\n                    times.findIndex((t) => t > elapsed)\n                ) - 1;\n            const nextIndex = prevIndex + 1;\n\n            // Get linear blend/alpha between the two\n            let alpha = (elapsed - times[prevIndex]) / (times[nextIndex] - times[prevIndex]);\n            if (interpolation === 'STEP') alpha = 0;\n\n            let prevVal = tmpVec3A;\n            let prevTan = tmpVec3B;\n            let nextTan = tmpVec3C;\n            let nextVal = tmpVec3D;\n            let size = 3;\n\n            if (transform === 'quaternion') {\n                prevVal = tmpQuatA;\n                prevTan = tmpQuatB;\n                nextTan = tmpQuatC;\n                nextVal = tmpQuatD;\n                size = 4;\n            }\n\n            if (interpolation === 'CUBICSPLINE') {\n                // Get the prev and next values from the indices\n                prevVal.fromArray(values, prevIndex * size * 3 + size * 1);\n                prevTan.fromArray(values, prevIndex * size * 3 + size * 2);\n                nextTan.fromArray(values, nextIndex * size * 3 + size * 0);\n                nextVal.fromArray(values, nextIndex * size * 3 + size * 1);\n\n                // interpolate for final value\n                prevVal = this.cubicSplineInterpolate(alpha, prevVal, prevTan, nextTan, nextVal);\n                if (size === 4) prevVal.normalize();\n            } else {\n                // Get the prev and next values from the indices\n                prevVal.fromArray(values, prevIndex * size);\n                nextVal.fromArray(values, nextIndex * size);\n\n                // interpolate for final value\n                if (size === 4) prevVal.slerp(nextVal, alpha);\n                else prevVal.lerp(nextVal, alpha);\n            }\n\n            // interpolate between multiple possible animations\n            if (size === 4) node[transform].slerp(prevVal, weight);\n            else node[transform].lerp(prevVal, weight);\n        });\n    }\n\n    cubicSplineInterpolate(t, prevVal, prevTan, nextTan, nextVal) {\n        const t2 = t * t;\n        const t3 = t2 * t;\n\n        const s2 = 3 * t2 - 2 * t3;\n        const s3 = t3 - t2;\n        const s0 = 1 - s2;\n        const s1 = s3 - t2 + t;\n\n        for (let i = 0; i < prevVal.length; i++) {\n            prevVal[i] = s0 * prevVal[i] + s1 * (1 - t) * prevTan[i] + s2 * nextVal[i] + s3 * t * nextTan[i];\n        }\n\n        return prevVal;\n    }\n}\n", "import { Mesh } from '../core/Mesh.js';\nimport { Mat4 } from '../math/Mat4.js';\nimport { Texture } from '../core/Texture.js';\n\nconst tempMat4 = /* @__PURE__ */ new Mat4();\nconst identity = /* @__PURE__ */ new Mat4();\n\nexport class GLTFSkin extends Mesh {\n    constructor(gl, { skeleton, geometry, program, mode = gl.TRIANGLES } = {}) {\n        super(gl, { geometry, program, mode });\n        this.skeleton = skeleton;\n        this.program = program;\n        this.createBoneTexture();\n    }\n\n    createBoneTexture() {\n        if (!this.skeleton.joints.length) return;\n        const size = Math.max(4, Math.pow(2, Math.ceil(Math.log(Math.sqrt(this.skeleton.joints.length * 4)) / Math.LN2)));\n        this.boneMatrices = new Float32Array(size * size * 4);\n        this.boneTextureSize = size;\n        this.boneTexture = new Texture(this.gl, {\n            image: this.boneMatrices,\n            generateMipmaps: false,\n            type: this.gl.FLOAT,\n            internalFormat: this.gl.renderer.isWebgl2 ? this.gl.RGBA32F : this.gl.RGBA,\n            minFilter: this.gl.NEAREST,\n            magFilter: this.gl.NEAREST,\n            flipY: false,\n            width: size,\n        });\n    }\n\n    updateUniforms() {\n        // Update bone texture\n        this.skeleton.joints.forEach((bone, i) => {\n            // Find difference between current and bind pose\n            tempMat4.multiply(bone.worldMatrix, bone.bindInverse);\n            this.boneMatrices.set(tempMat4, i * 16);\n        });\n        this.boneTexture.needsUpdate = true;\n        // Reset for programs shared between multiple skins\n        this.program.uniforms.boneTexture.value = this.boneTexture;\n        this.program.uniforms.boneTextureSize.value = this.boneTextureSize;\n    }\n\n    draw({ camera } = {}) {\n        if (!this.program.uniforms.boneTexture) {\n            Object.assign(this.program.uniforms, {\n                boneTexture: { value: this.boneTexture },\n                boneTextureSize: { value: this.boneTextureSize },\n            });\n        }\n\n        this.updateUniforms();\n\n        // Switch the world matrix with identity to ignore any transforms\n        // on the mesh itself - only use skeleton's transforms\n        const _worldMatrix = this.worldMatrix;\n        this.worldMatrix = identity;\n\n        super.draw({ camera });\n\n        // Switch back to leave identity untouched\n        this.worldMatrix = _worldMatrix;\n    }\n}\n", "import { Transform } from '../core/Transform.js';\nimport { Mesh } from '../core/Mesh.js';\nimport { Vec4 } from '../math/Vec4.js';\n\nexport class InstancedMesh extends Mesh {\n    constructor(...args) {\n        super(...args);\n\n        // Skip renderer frustum culling\n        this.frustumCulled = false;\n        this.isInstancedMesh = true;\n    }\n\n    addFrustumCull() {\n        this.instanceTransforms = null;\n        this.instanceLightmapScaleOffset = null;\n        this.totalInstanceCount = 0;\n        this.frustumCullFunction = null;\n        this.instanceRenderList = null;\n\n        // Get instanced mesh\n        if (!this.geometry.attributes.instanceMatrix)\n            console.error(`mesh ${this.name ? `\"${this.name}\" ` : ``}missing instanceMatrix attribute; unable to frustum cull`);\n\n        // Make list of transforms from instanceMatrix\n        const matrixData = this.geometry.attributes.instanceMatrix.data;\n        this.instanceTransforms = [];\n        for (let i = 0, j = 0; i < matrixData.length; i += 16, j++) {\n            const transform = new Transform();\n            transform.index = j;\n            transform.matrix.fromArray(matrixData, i);\n            transform.decompose();\n            this.instanceTransforms.push(transform);\n            // Add transforms to parent to update world matrices\n            transform.setParent(this.parent);\n        }\n        this.totalInstanceCount = this.instanceTransforms.length;\n\n        // Check for lightmap attributes - attach to transform\n        if (!!this.geometry.attributes.lightmapScaleOffset) {\n            const lightmapData = this.geometry.attributes.lightmapScaleOffset.data;\n            for (let i = 0, j = 0; i < lightmapData.length; i += 4, j++) {\n                this.instanceTransforms[j].lightmapData = new Vec4().fromArray(lightmapData, i);\n            }\n        }\n\n        this.frustumCullFunction = ({ camera }) => {\n            // frustum cull transforms each frame - pass world matrix\n            this.instanceRenderList = [];\n            this.instanceTransforms.forEach((transform) => {\n                if (!camera.frustumIntersectsMesh(this, transform.worldMatrix)) return;\n                this.instanceRenderList.push(transform);\n            });\n\n            // update instanceMatrix and instancedCount with visible\n            this.instanceRenderList.forEach((transform, i) => {\n                transform.matrix.toArray(this.geometry.attributes.instanceMatrix.data, i * 16);\n\n                // Update lightmap attr\n                if (transform.lightmapData) {\n                    transform.lightmapData.toArray(this.geometry.attributes.lightmapScaleOffset.data, i * 4);\n                    this.geometry.attributes.lightmapScaleOffset.needsUpdate = true;\n                }\n            });\n            this.geometry.instancedCount = this.instanceRenderList.length;\n            this.geometry.attributes.instanceMatrix.needsUpdate = true;\n        };\n\n        this.onBeforeRender(this.frustumCullFunction);\n    }\n\n    removeFrustumCull() {\n        this.offBeforeRender(this.frustumCullFunction);\n        this.geometry.instancedCount = this.totalInstanceCount;\n        this.instanceTransforms.forEach((transform, i) => {\n            transform.matrix.toArray(this.geometry.attributes.instanceMatrix.data, i * 16);\n\n            // Update lightmap attr\n            if (transform.lightmapData) {\n                transform.lightmapData.toArray(this.geometry.attributes.lightmapScaleOffset.data, i * 4);\n                this.geometry.attributes.lightmapScaleOffset.needsUpdate = true;\n            }\n        });\n        this.geometry.attributes.instanceMatrix.needsUpdate = true;\n    }\n}\n", "import { Geometry } from '../core/Geometry.js';\nimport { Transform } from '../core/Transform.js';\nimport { Texture } from '../core/Texture.js';\nimport { Mesh } from '../core/Mesh.js';\nimport { GLTFAnimation } from './GLTFAnimation.js';\nimport { GLTFSkin } from './GLTFSkin.js';\nimport { Mat4 } from '../math/Mat4.js';\nimport { Vec3 } from '../math/Vec3.js';\nimport { NormalProgram } from './NormalProgram.js';\nimport { InstancedMesh } from './InstancedMesh.js';\n\n// Supports\n// [x] glb\n// [x] Geometry\n// [x] Nodes and Hierarchy\n// [x] Instancing\n// [x] Skins\n// [x] Textures\n// [x] Animation\n// [x] GLB support\n// [x] Basis/ktx2\n// [x] KHR_lights_punctual lights\n// [ ] Morph Targets\n// [ ] Materials\n// [ ] Cameras\n\n// TODO: Sparse accessor packing? For morph targets basically\n// TODO: init accessor missing bufferView with 0s\n// TODO: morph target animations\n// TODO: option to turn off GPU instancing\n\nconst TYPE_ARRAY = {\n    5121: Uint8Array,\n    5122: Int16Array,\n    5123: Uint16Array,\n    5125: Uint32Array,\n    5126: Float32Array,\n    'image/jpeg': Uint8Array,\n    'image/png': Uint8Array,\n};\n\nconst TYPE_SIZE = {\n    SCALAR: 1,\n    VEC2: 2,\n    VEC3: 3,\n    VEC4: 4,\n    MAT2: 4,\n    MAT3: 9,\n    MAT4: 16,\n};\n\nconst ATTRIBUTES = {\n    POSITION: 'position',\n    NORMAL: 'normal',\n    TANGENT: 'tangent',\n    TEXCOORD_0: 'uv',\n    TEXCOORD_1: 'uv2',\n    COLOR_0: 'color',\n    WEIGHTS_0: 'skinWeight',\n    JOINTS_0: 'skinIndex',\n};\n\nconst TRANSFORMS = {\n    translation: 'position',\n    rotation: 'quaternion',\n    scale: 'scale',\n};\n\nexport class GLTFLoader {\n    static setBasisManager(manager) {\n        this.basisManager = manager;\n    }\n\n    static async load(gl, src) {\n        const dir = src.split('/').slice(0, -1).join('/') + '/';\n\n        // load main description json\n        const desc = await this.parseDesc(src);\n\n        return this.parse(gl, desc, dir);\n    }\n\n    static async parse(gl, desc, dir) {\n        if (desc.asset === undefined || desc.asset.version[0] < 2) console.warn('Only GLTF >=2.0 supported. Attempting to parse.');\n\n        if (desc.extensionsRequired?.includes('KHR_texture_basisu') && !this.basisManager)\n            console.warn('KHR_texture_basisu extension required but no manager supplied. Use .setBasisManager()');\n\n        // Load buffers async\n        const buffers = await this.loadBuffers(desc, dir);\n\n        // Unbind current VAO so that new buffers don't get added to active mesh\n        gl.renderer.bindVertexArray(null);\n\n        // Create gl buffers from bufferViews\n        const bufferViews = this.parseBufferViews(gl, desc, buffers);\n\n        // Create images from either bufferViews or separate image files\n        const images = await this.parseImages(gl, desc, dir, bufferViews);\n\n        const textures = this.parseTextures(gl, desc, images);\n\n        // Just pass through material data for now\n        const materials = this.parseMaterials(gl, desc, textures);\n\n        // Fetch the inverse bind matrices for skeleton joints\n        const skins = this.parseSkins(gl, desc, bufferViews);\n\n        // Create geometries for each mesh primitive\n        const meshes = this.parseMeshes(gl, desc, bufferViews, materials, skins);\n\n        // Create transforms, meshes and hierarchy\n        const nodes = this.parseNodes(gl, desc, meshes, skins, images);\n\n        // Place nodes in skeletons\n        this.populateSkins(skins, nodes);\n\n        // Create animation handlers\n        const animations = this.parseAnimations(gl, desc, nodes, bufferViews);\n\n        // Get top level nodes for each scene\n        const scenes = this.parseScenes(desc, nodes);\n        const scene = scenes[desc.scene];\n\n        // Create uniforms for scene lights (TODO: light linking?)\n        const lights = this.parseLights(gl, desc, nodes, scenes);\n\n        // Remove null nodes (instanced transforms)\n        for (let i = nodes.length; i >= 0; i--) if (!nodes[i]) nodes.splice(i, 1);\n\n        return {\n            json: desc,\n            buffers,\n            bufferViews,\n            images,\n            textures,\n            materials,\n            meshes,\n            nodes,\n            lights,\n            animations,\n            scenes,\n            scene,\n        };\n    }\n\n    static parseDesc(src) {\n        if (!src.match(/\\.glb/)) {\n            return fetch(src).then((res) => res.json());\n        } else {\n            return fetch(src)\n                .then((res) => res.arrayBuffer())\n                .then((glb) => this.unpackGLB(glb));\n        }\n    }\n\n    // From https://github.com/donmccurdy/glTF-Transform/blob/e4108cc/packages/core/src/io/io.ts#L32\n    static unpackGLB(glb) {\n        // Decode and verify GLB header.\n        const header = new Uint32Array(glb, 0, 3);\n        if (header[0] !== 0x46546c67) {\n            throw new Error('Invalid glTF asset.');\n        } else if (header[1] !== 2) {\n            throw new Error(`Unsupported glTF binary version, \"${header[1]}\".`);\n        }\n        // Decode and verify chunk headers.\n        const jsonChunkHeader = new Uint32Array(glb, 12, 2);\n        const jsonByteOffset = 20;\n        const jsonByteLength = jsonChunkHeader[0];\n        if (jsonChunkHeader[1] !== 0x4e4f534a) {\n            throw new Error('Unexpected GLB layout.');\n        }\n\n        // Decode JSON.\n        const jsonText = new TextDecoder().decode(glb.slice(jsonByteOffset, jsonByteOffset + jsonByteLength));\n        const json = JSON.parse(jsonText);\n        // JSON only\n        if (jsonByteOffset + jsonByteLength === glb.byteLength) return json;\n\n        const binaryChunkHeader = new Uint32Array(glb, jsonByteOffset + jsonByteLength, 2);\n        if (binaryChunkHeader[1] !== 0x004e4942) {\n            throw new Error('Unexpected GLB layout.');\n        }\n        // Decode content.\n        const binaryByteOffset = jsonByteOffset + jsonByteLength + 8;\n        const binaryByteLength = binaryChunkHeader[0];\n        const binary = glb.slice(binaryByteOffset, binaryByteOffset + binaryByteLength);\n        // Attach binary to buffer\n        json.buffers[0].binary = binary;\n        return json;\n    }\n\n    // Threejs GLTF Loader https://github.com/mrdoob/three.js/blob/master/examples/js/loaders/GLTFLoader.js#L1085\n    static resolveURI(uri, dir) {\n        // Invalid URI\n        if (typeof uri !== 'string' || uri === '') return '';\n\n        // Host Relative URI\n        if (/^https?:\\/\\//i.test(dir) && /^\\//.test(uri)) {\n            dir = dir.replace(/(^https?:\\/\\/[^\\/]+).*/i, '$1');\n        }\n\n        // Absolute URI http://, https://, //\n        if (/^(https?:)?\\/\\//i.test(uri)) return uri;\n\n        // Data URI\n        if (/^data:.*,.*$/i.test(uri)) return uri;\n\n        // Blob URI\n        if (/^blob:.*$/i.test(uri)) return uri;\n\n        // Relative URI\n        return dir + uri;\n    }\n\n    static loadBuffers(desc, dir) {\n        if (!desc.buffers) return null;\n        return Promise.all(\n            desc.buffers.map((buffer) => {\n                // For GLB, binary buffer ready to go\n                if (buffer.binary) return buffer.binary;\n                const uri = this.resolveURI(buffer.uri, dir);\n                return fetch(uri).then((res) => res.arrayBuffer());\n            })\n        );\n    }\n\n    static parseBufferViews(gl, desc, buffers) {\n        if (!desc.bufferViews) return null;\n        // Clone to leave description pure\n        const bufferViews = desc.bufferViews.map((o) => Object.assign({}, o));\n\n        desc.meshes &&\n            desc.meshes.forEach(({ primitives }) => {\n                primitives.forEach(({ attributes, indices }) => {\n                    // Flag bufferView as an attribute, so it knows to create a gl buffer\n                    for (let attr in attributes) bufferViews[desc.accessors[attributes[attr]].bufferView].isAttribute = true;\n\n                    if (indices === undefined) return;\n                    bufferViews[desc.accessors[indices].bufferView].isAttribute = true;\n\n                    // Make sure indices bufferView have a target property for gl buffer binding\n                    bufferViews[desc.accessors[indices].bufferView].target = gl.ELEMENT_ARRAY_BUFFER;\n                });\n            });\n\n        // Get componentType of each bufferView from the accessors\n        desc.accessors.forEach(({ bufferView: i, componentType }) => {\n            bufferViews[i].componentType = componentType;\n        });\n\n        // Get mimetype of bufferView from images\n        desc.images &&\n            desc.images.forEach(({ uri, bufferView: i, mimeType }) => {\n                if (i === undefined) return;\n                bufferViews[i].mimeType = mimeType;\n            });\n\n        // Push each bufferView to the GPU as a separate buffer\n        bufferViews.forEach(\n            (\n                {\n                    buffer: bufferIndex, // required\n                    byteOffset = 0, // optional\n                    byteLength, // required\n                    byteStride, // optional\n                    target = gl.ARRAY_BUFFER, // optional, added above for elements\n                    name, // optional\n                    extensions, // optional\n                    extras, // optional\n\n                    componentType, // optional, added from accessor above\n                    mimeType, // optional, added from images above\n                    isAttribute,\n                },\n                i\n            ) => {\n                bufferViews[i].data = buffers[bufferIndex].slice(byteOffset, byteOffset + byteLength);\n\n                if (!isAttribute) return;\n                // Create gl buffers for the bufferView, pushing it to the GPU\n                const buffer = gl.createBuffer();\n                gl.bindBuffer(target, buffer);\n                gl.renderer.state.boundBuffer = buffer;\n                gl.bufferData(target, bufferViews[i].data, gl.STATIC_DRAW);\n                bufferViews[i].buffer = buffer;\n            }\n        );\n\n        return bufferViews;\n    }\n\n    static parseImages(gl, desc, dir, bufferViews) {\n        if (!desc.images) return null;\n        return Promise.all(\n            desc.images.map(async ({ uri, bufferView: bufferViewIndex, mimeType, name }) => {\n                if (mimeType === 'image/ktx2') {\n                    const { data } = bufferViews[bufferViewIndex];\n                    const image = await this.basisManager.parseTexture(data);\n                    return image;\n                }\n\n                // jpg / png\n                const image = new Image();\n                image.name = name;\n                if (uri) {\n                    image.src = this.resolveURI(uri, dir);\n                } else if (bufferViewIndex !== undefined) {\n                    const { data } = bufferViews[bufferViewIndex];\n                    const blob = new Blob([data], { type: mimeType });\n                    image.src = URL.createObjectURL(blob);\n                }\n                image.ready = new Promise((res) => {\n                    image.onload = () => res();\n                });\n                return image;\n            })\n        );\n    }\n\n    static parseTextures(gl, desc, images) {\n        if (!desc.textures) return null;\n        return desc.textures.map((textureInfo) => this.createTexture(gl, desc, images, textureInfo));\n    }\n\n    static createTexture(gl, desc, images, { sampler: samplerIndex, source: sourceIndex, name, extensions, extras }) {\n        if (sourceIndex === undefined && !!extensions) {\n            // Basis extension source index\n            if (extensions.KHR_texture_basisu) sourceIndex = extensions.KHR_texture_basisu.source;\n        }\n\n        const image = images[sourceIndex];\n        if (image.texture) return image.texture;\n\n        const options = {\n            flipY: false,\n            wrapS: gl.REPEAT, // Repeat by default, opposed to OGL's clamp by default\n            wrapT: gl.REPEAT,\n        };\n        const sampler = samplerIndex !== undefined ? desc.samplers[samplerIndex] : null;\n        if (sampler) {\n            ['magFilter', 'minFilter', 'wrapS', 'wrapT'].forEach((prop) => {\n                if (sampler[prop]) options[prop] = sampler[prop];\n            });\n        }\n\n        // For compressed textures\n        if (image.isBasis) {\n            options.image = image;\n            options.internalFormat = image.internalFormat;\n            if (image.isCompressedTexture) {\n                options.generateMipmaps = false;\n                if (image.length > 1) this.minFilter = gl.NEAREST_MIPMAP_LINEAR;\n            }\n            const texture = new Texture(gl, options);\n            texture.name = name;\n            image.texture = texture;\n            return texture;\n        }\n\n        const texture = new Texture(gl, options);\n        texture.name = name;\n        image.texture = texture;\n        image.ready.then(() => {\n            texture.image = image;\n        });\n\n        return texture;\n    }\n\n    static parseMaterials(gl, desc, textures) {\n        if (!desc.materials) return null;\n        return desc.materials.map(\n            ({\n                name,\n                extensions,\n                extras,\n                pbrMetallicRoughness = {},\n                normalTexture,\n                occlusionTexture,\n                emissiveTexture,\n                emissiveFactor = [0, 0, 0],\n                alphaMode = 'OPAQUE',\n                alphaCutoff = 0.5,\n                doubleSided = false,\n            }) => {\n                const {\n                    baseColorFactor = [1, 1, 1, 1],\n                    baseColorTexture,\n                    metallicFactor = 1,\n                    roughnessFactor = 1,\n                    metallicRoughnessTexture,\n                    //   extensions,\n                    //   extras,\n                } = pbrMetallicRoughness;\n\n                if (baseColorTexture) {\n                    baseColorTexture.texture = textures[baseColorTexture.index];\n                    // texCoord\n                }\n                if (normalTexture) {\n                    normalTexture.texture = textures[normalTexture.index];\n                    // scale: 1\n                    // texCoord\n                }\n                if (metallicRoughnessTexture) {\n                    metallicRoughnessTexture.texture = textures[metallicRoughnessTexture.index];\n                    // texCoord\n                }\n                if (occlusionTexture) {\n                    occlusionTexture.texture = textures[occlusionTexture.index];\n                    // strength 1\n                    // texCoord\n                }\n                if (emissiveTexture) {\n                    emissiveTexture.texture = textures[emissiveTexture.index];\n                    // texCoord\n                }\n\n                return {\n                    name,\n                    extensions,\n                    extras,\n                    baseColorFactor,\n                    baseColorTexture,\n                    metallicFactor,\n                    roughnessFactor,\n                    metallicRoughnessTexture,\n                    normalTexture,\n                    occlusionTexture,\n                    emissiveTexture,\n                    emissiveFactor,\n                    alphaMode,\n                    alphaCutoff,\n                    doubleSided,\n                };\n            }\n        );\n    }\n\n    static parseSkins(gl, desc, bufferViews) {\n        if (!desc.skins) return null;\n        return desc.skins.map(\n            ({\n                inverseBindMatrices, // optional\n                skeleton, // optional\n                joints, // required\n                // name,\n                // extensions,\n                // extras,\n            }) => {\n                return {\n                    inverseBindMatrices: this.parseAccessor(inverseBindMatrices, desc, bufferViews),\n                    skeleton,\n                    joints,\n                };\n            }\n        );\n    }\n\n    static parseMeshes(gl, desc, bufferViews, materials, skins) {\n        if (!desc.meshes) return null;\n        return desc.meshes.map(\n            (\n                {\n                    primitives, // required\n                    weights, // optional\n                    name, // optional\n                    extensions, // optional\n                    extras, // optional\n                },\n                meshIndex\n            ) => {\n                // TODO: weights stuff ?\n                // Parse through nodes to see how many instances there are\n                // and if there is a skin attached\n                // If multiple instances of a skin, need to create each\n                let numInstances = 0;\n                let skinIndices = [];\n                let isLightmap = false;\n                desc.nodes &&\n                    desc.nodes.forEach(({ mesh, skin, extras }) => {\n                        if (mesh === meshIndex) {\n                            numInstances++;\n                            if (skin !== undefined) skinIndices.push(skin);\n                            if (extras && extras.lightmap_scale_offset) isLightmap = true;\n                        }\n                    });\n                let isSkin = !!skinIndices.length;\n\n                // For skins, return array of skin meshes to account for multiple instances\n                if (isSkin) {\n                    primitives = skinIndices.map((skinIndex) => {\n                        return this.parsePrimitives(gl, primitives, desc, bufferViews, materials, 1, isLightmap).map(\n                            ({ geometry, program, mode }) => {\n                                const mesh = new GLTFSkin(gl, { skeleton: skins[skinIndex], geometry, program, mode });\n                                mesh.name = name;\n                                // TODO: support skin frustum culling\n                                mesh.frustumCulled = false;\n                                return mesh;\n                            }\n                        );\n                    });\n                    // For retrieval to add to node\n                    primitives.instanceCount = 0;\n                    primitives.numInstances = numInstances;\n                } else {\n                    primitives = this.parsePrimitives(gl, primitives, desc, bufferViews, materials, numInstances, isLightmap).map(\n                        ({ geometry, program, mode }) => {\n                            // InstancedMesh class has custom frustum culling for instances\n                            const meshConstructor = geometry.attributes.instanceMatrix ? InstancedMesh : Mesh;\n                            const mesh = new meshConstructor(gl, { geometry, program, mode });\n                            mesh.name = name;\n                            // Tag mesh so that nodes can add their transforms to the instance attribute\n                            mesh.numInstances = numInstances;\n                            return mesh;\n                        }\n                    );\n                }\n\n                return {\n                    primitives,\n                    weights,\n                    name,\n                };\n            }\n        );\n    }\n\n    static parsePrimitives(gl, primitives, desc, bufferViews, materials, numInstances, isLightmap) {\n        return primitives.map(\n            ({\n                attributes, // required\n                indices, // optional\n                material: materialIndex, // optional\n                mode = 4, // optional\n                targets, // optional\n                extensions, // optional\n                extras, // optional\n            }) => {\n                // TODO: materials\n                const program = new NormalProgram(gl);\n                if (materialIndex !== undefined) {\n                    program.gltfMaterial = materials[materialIndex];\n                }\n\n                const geometry = new Geometry(gl);\n\n                // Add each attribute found in primitive\n                for (let attr in attributes) {\n                    geometry.addAttribute(ATTRIBUTES[attr], this.parseAccessor(attributes[attr], desc, bufferViews));\n                }\n\n                // Add index attribute if found\n                if (indices !== undefined) {\n                    geometry.addAttribute('index', this.parseAccessor(indices, desc, bufferViews));\n                }\n\n                // Add instanced transform attribute if multiple instances\n                // Ignore if skin as we don't support instanced skins out of the box\n                if (numInstances > 1) {\n                    geometry.addAttribute('instanceMatrix', {\n                        instanced: 1,\n                        size: 16,\n                        data: new Float32Array(numInstances * 16),\n                    });\n                }\n\n                // Always supply lightmapScaleOffset as an instanced attribute\n                // Instanced skin lightmaps not supported\n                if (isLightmap) {\n                    geometry.addAttribute('lightmapScaleOffset', {\n                        instanced: 1,\n                        size: 4,\n                        data: new Float32Array(numInstances * 4),\n                    });\n                }\n\n                return {\n                    geometry,\n                    program,\n                    mode,\n                };\n            }\n        );\n    }\n\n    static parseAccessor(index, desc, bufferViews) {\n        // TODO: init missing bufferView with 0s\n        // TODO: support sparse\n\n        const {\n            bufferView: bufferViewIndex, // optional\n            byteOffset = 0, // optional\n            componentType, // required\n            normalized = false, // optional\n            count, // required\n            type, // required\n            min, // optional\n            max, // optional\n            sparse, // optional\n            // name, // optional\n            // extensions, // optional\n            // extras, // optional\n        } = desc.accessors[index];\n\n        const {\n            data, // attached in parseBufferViews\n            buffer, // replaced to be the actual GL buffer\n            byteOffset: bufferByteOffset = 0,\n            // byteLength, // applied in parseBufferViews\n            byteStride = 0,\n            target,\n            // name,\n            // extensions,\n            // extras,\n        } = bufferViews[bufferViewIndex];\n\n        const size = TYPE_SIZE[type];\n\n        // Parse data from joined buffers\n        const TypeArray = TYPE_ARRAY[componentType];\n        const elementBytes = TypeArray.BYTES_PER_ELEMENT;\n        const componentStride = byteStride / elementBytes;\n        const isInterleaved = !!byteStride && componentStride !== size;\n\n        let filteredData;\n\n        // Convert data to typed array for various uses (bounding boxes, raycasting, animation, merging etc)\n        if (isInterleaved) {\n            // First convert entire buffer to type\n            const typedData = new TypeArray(data, byteOffset);\n            // TODO: add length to not copy entire buffer if can help it\n            // const typedData = new TypeArray(data, byteOffset, (count - 1) * componentStride)\n\n            // Create output with length\n            filteredData = new TypeArray(count * size);\n\n            // Add element by element\n            for (let i = 0; i < count; i++) {\n                const start = componentStride * i;\n                const end = start + size;\n                filteredData.set(typedData.slice(start, end), i * size);\n            }\n        } else {\n            // Simply a slice\n            filteredData = new TypeArray(data, byteOffset, count * size);\n        }\n\n        // Return attribute data\n        return {\n            data: filteredData,\n            size,\n            type: componentType,\n            normalized,\n            buffer,\n            stride: byteStride,\n            offset: byteOffset,\n            count,\n            min,\n            max,\n        };\n    }\n\n    static parseNodes(gl, desc, meshes, skins, images) {\n        if (!desc.nodes) return null;\n        const nodes = desc.nodes.map(\n            ({\n                camera, // optional\n                children, // optional\n                skin: skinIndex, // optional\n                matrix, // optional\n                mesh: meshIndex, // optional\n                rotation, // optional\n                scale, // optional\n                translation, // optional\n                weights, // optional\n                name, // optional\n                extensions, // optional\n                extras, // optional\n            }) => {\n                const node = new Transform();\n                if (name) node.name = name;\n                node.extras = extras;\n                node.extensions = extensions;\n\n                // Need to attach to node as may have same material but different lightmap\n                if (extras && extras.lightmapTexture !== undefined) {\n                    extras.lightmapTexture.texture = this.createTexture(gl, desc, images, { source: extras.lightmapTexture.index });\n                }\n\n                // Apply transformations\n                if (matrix) {\n                    node.matrix.copy(matrix);\n                    node.decompose();\n                } else {\n                    if (rotation) node.quaternion.copy(rotation);\n                    if (scale) node.scale.copy(scale);\n                    if (translation) node.position.copy(translation);\n                    node.updateMatrix();\n                }\n\n                // Flags for avoiding duplicate transforms and removing unused instance nodes\n                let isInstanced = false;\n                let isFirstInstance = true;\n                let isInstancedMatrix = false;\n                let isSkin = skinIndex !== undefined;\n\n                // add mesh if included\n                if (meshIndex !== undefined) {\n                    if (isSkin) {\n                        meshes[meshIndex].primitives[meshes[meshIndex].primitives.instanceCount].forEach((mesh) => {\n                            mesh.extras = extras;\n                            mesh.setParent(node);\n                        });\n                        meshes[meshIndex].primitives.instanceCount++;\n                        // Remove properties once all instances added\n                        if (meshes[meshIndex].primitives.instanceCount === meshes[meshIndex].primitives.numInstances) {\n                            delete meshes[meshIndex].primitives.numInstances;\n                            delete meshes[meshIndex].primitives.instanceCount;\n                        }\n                    } else {\n                        meshes[meshIndex].primitives.forEach((mesh) => {\n                            mesh.extras = extras;\n\n                            // instanced mesh might only have 1\n                            if (mesh.geometry.isInstanced) {\n                                isInstanced = true;\n                                if (!mesh.instanceCount) {\n                                    mesh.instanceCount = 0;\n                                } else {\n                                    isFirstInstance = false;\n                                }\n                                if (mesh.geometry.attributes.instanceMatrix) {\n                                    isInstancedMatrix = true;\n                                    node.matrix.toArray(mesh.geometry.attributes.instanceMatrix.data, mesh.instanceCount * 16);\n                                }\n\n                                if (mesh.geometry.attributes.lightmapScaleOffset) {\n                                    mesh.geometry.attributes.lightmapScaleOffset.data.set(extras.lightmap_scale_offset, mesh.instanceCount * 4);\n                                }\n\n                                mesh.instanceCount++;\n\n                                if (mesh.instanceCount === mesh.numInstances) {\n                                    // Remove properties once all instances added\n                                    delete mesh.numInstances;\n                                    delete mesh.instanceCount;\n                                    // Flag attribute as dirty\n                                    if (mesh.geometry.attributes.instanceMatrix) {\n                                        mesh.geometry.attributes.instanceMatrix.needsUpdate = true;\n                                    }\n                                    if (mesh.geometry.attributes.lightmapScaleOffset) {\n                                        mesh.geometry.attributes.lightmapScaleOffset.needsUpdate = true;\n                                    }\n                                }\n                            }\n\n                            // For instances, only the first node will actually have the mesh\n                            if (isInstanced) {\n                                if (isFirstInstance) mesh.setParent(node);\n                            } else {\n                                mesh.setParent(node);\n                            }\n                        });\n                    }\n                }\n\n                // Reset node if instanced to not duplicate transforms\n                if (isInstancedMatrix) {\n                    // Remove unused nodes just providing an instance transform\n                    if (!isFirstInstance) return null;\n                    // Avoid duplicate transform for node containing the instanced mesh\n                    node.matrix.identity();\n                    node.decompose();\n                }\n\n                return node;\n            }\n        );\n\n        desc.nodes.forEach(({ children = [] }, i) => {\n            // Set hierarchy now all nodes created\n            children.forEach((childIndex) => {\n                if (!nodes[childIndex]) return;\n                nodes[childIndex].setParent(nodes[i]);\n            });\n        });\n\n        // Add frustum culling for instances now that instanceMatrix attribute is populated\n        meshes.forEach(({ primitives }, i) => {\n            primitives.forEach((primitive, i) => {\n                if (primitive.isInstancedMesh) primitive.addFrustumCull();\n            });\n        });\n\n        return nodes;\n    }\n\n    static populateSkins(skins, nodes) {\n        if (!skins) return;\n        skins.forEach((skin) => {\n            skin.joints = skin.joints.map((i, index) => {\n                const joint = nodes[i];\n                joint.skin = skin;\n                joint.bindInverse = new Mat4(...skin.inverseBindMatrices.data.slice(index * 16, (index + 1) * 16));\n                return joint;\n            });\n            if (skin.skeleton) skin.skeleton = nodes[skin.skeleton];\n        });\n    }\n\n    static parseAnimations(gl, desc, nodes, bufferViews) {\n        if (!desc.animations) return null;\n        return desc.animations.map(\n            (\n                {\n                    channels, // required\n                    samplers, // required\n                    name, // optional\n                    // extensions, // optional\n                    // extras,  // optional\n                },\n                animationIndex\n            ) => {\n                const data = channels.map(\n                    ({\n                        sampler: samplerIndex, // required\n                        target, // required\n                        // extensions, // optional\n                        // extras, // optional\n                    }) => {\n                        const {\n                            input: inputIndex, // required\n                            interpolation = 'LINEAR',\n                            output: outputIndex, // required\n                            // extensions, // optional\n                            // extras, // optional\n                        } = samplers[samplerIndex];\n\n                        const {\n                            node: nodeIndex, // optional - TODO: when is it not included?\n                            path, // required\n                            // extensions, // optional\n                            // extras, // optional\n                        } = target;\n\n                        const node = nodes[nodeIndex];\n                        const transform = TRANSFORMS[path];\n                        const times = this.parseAccessor(inputIndex, desc, bufferViews).data;\n                        const values = this.parseAccessor(outputIndex, desc, bufferViews).data;\n\n                        // Store reference on node for cyclical retrieval\n                        if (!node.animations) node.animations = [];\n                        if (!node.animations.includes(animationIndex)) node.animations.push(animationIndex);\n\n                        return {\n                            node,\n                            transform,\n                            interpolation,\n                            times,\n                            values,\n                        };\n                    }\n                );\n\n                return {\n                    name,\n                    animation: new GLTFAnimation(data),\n                };\n            }\n        );\n    }\n\n    static parseScenes(desc, nodes) {\n        if (!desc.scenes) return null;\n        return desc.scenes.map(\n            ({\n                nodes: nodesIndices = [],\n                name, // optional\n                extensions,\n                extras,\n            }) => {\n                const scene = nodesIndices.reduce((map, i) => {\n                    // Don't add null nodes (instanced transforms)\n                    if (nodes[i]) map.push(nodes[i]);\n                    return map;\n                }, []);\n                scene.extras = extras;\n                return scene;\n            }\n        );\n    }\n\n    static parseLights(gl, desc, nodes, scenes) {\n        const lights = {\n            directional: [],\n            point: [],\n            spot: [],\n        };\n\n        // Update matrices on root nodes\n        scenes.forEach((scene) => scene.forEach((node) => node.updateMatrixWorld()));\n\n        // uses KHR_lights_punctual extension\n        const lightsDescArray = desc.extensions?.KHR_lights_punctual?.lights || [];\n\n        // Need nodes for transforms\n        nodes.forEach((node) => {\n            if (!node?.extensions?.KHR_lights_punctual) return;\n            const lightIndex = node.extensions.KHR_lights_punctual.light;\n            const lightDesc = lightsDescArray[lightIndex];\n            const light = {\n                name: lightDesc.name || '',\n                color: { value: new Vec3().set(lightDesc.color || 1) },\n            };\n            // Apply intensity directly to color\n            if (lightDesc.intensity !== undefined) light.color.value.multiply(lightDesc.intensity);\n\n            switch (lightDesc.type) {\n                case 'directional':\n                    light.direction = { value: new Vec3(0, 0, 1).transformDirection(node.worldMatrix) };\n                    break;\n                case 'point':\n                    light.position = { value: new Vec3().applyMatrix4(node.worldMatrix) };\n                    light.distance = { value: lightDesc.range };\n                    light.decay = { value: 2 };\n                    break;\n                case 'spot':\n                    // TODO: support spot uniforms\n                    Object.assign(light, lightDesc);\n                    break;\n            }\n\n            lights[lightDesc.type].push(light);\n        });\n\n        return lights;\n    }\n}\n", "import { Program, Mesh, Texture, Box } from 'ogl';\n\nexport class SkyBox extends Mesh {\n    constructor(gl, imgArray) {\n        const texture = new Texture(gl, { image: imgArray, target: gl.TEXTURE_CUBE_MAP });\n        const geometry = new Box(gl);\n        const program = new Program(gl, {\n            vertex: `#version 300 es\n            in vec3 position;\n            out vec3 uv;\n\n            uniform mat4 modelViewMatrix;\n            uniform mat4 projectionMatrix;\n\n            void main() {\n                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n                uv = position;\n            }\n            `,\n            fragment: `#version 300 es\n            precision highp float;\n            //uniform samplerCube tMap;\n            in vec3 uv;\n            out vec4 outColor;\n\n            void main() {\n                float sky = clamp((-uv.y + 0.5) + uv.x, 0.0, 1.0);\n                //outColor = texture(tMap, uv);\n                outColor = vec4(0.1, 0.1, sky/2.0, 1.0);\n            }\n            `,\n            //uniforms: {\n            //    tMap: { value: texture },\n            //},\n            cullFace: null,\n        });\n\n        super(gl, { geometry, program });\n        this.worldMatrix.scale(100);\n        this.beforeRenderCallbacks = [\n            () => {\n                this.program.uniforms.modelViewMatrix.value.setPosition([0, 0, 0]);\n            }\n        ];\n    }\n\n    updateMatrix() {\n        return;\n    }\n    updateMatrixWorld(force) {\n        return;\n    }\n}\n", "#version 300 es\nin vec3 position;\nin vec4 color;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nout vec4 vColor;\n\nvoid main() {\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    vColor = color;\n}\n", "#version 300 es\nprecision highp float;\n\nin vec4 vColor;\n\nout vec4 outColor;\n\nvoid main() {\n    outColor = vColor;\n}\n", "import physDebugVert from './shaders/physDebug.vert';\nimport physDebugFrag from './shaders/physDebug.frag';\nimport { Program, Mesh, Geometry } from 'ogl';\n\nexport class PhysDebugMesh extends Mesh {\n  constructor(gl, world, scene) {\n    const program = new Program(gl, {\n        vertex: physDebugVert,\n        fragment: physDebugFrag,\n    });\n    const renderData = world.debugRender();\n    const attrs = {\n        position: {\n            size: 3,\n            usage: gl.STREAM_DRAW,\n            data: renderData.vertices,\n        },\n        color: {\n            size: 4,\n            usage: gl.STREAM_DRAW,\n            data: renderData.colors,\n        },\n    };\n    const geom = new Geometry(gl, attrs);\n    super(gl, {geometry: geom, program: program, mode: gl.LINES});\n    this.attrs = attrs;\n    this.world = world;\n    this.geometry = geom;\n    this.bufLen = renderData.vertices.length;\n    this.gl = gl;\n    this.scene = scene;\n    this.enabled = true;\n    this.setParent(this.scene);\n  }\n\n  updateBuffers() {\n    const newBuf = this.world.debugRender();\n    this.attrs.position.data = newBuf.vertices;\n    this.attrs.color.data = newBuf.colors;\n    if (newBuf.vertices.length !== this.bufLen) {\n      if (newBuf.vertices.length > this.bufLen) {\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.attrs.position.buffer);\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, newBuf.vertices, this.gl.STREAM_DRAW);\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.attrs.color.buffer);\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, newBuf.colors, this.gl.STREAM_DRAW);\n        this.gl.renderer.state.boundBuffer = this.attrs.color.buffer;\n      }\n      this.attrs.position.count = newBuf.vertices.length / 3;\n      this.attrs.color.count = newBuf.colors.length / 4;\n      this.geometry.drawRange.count = newBuf.vertices.length / 3;\n    }\n    this.bufLen = newBuf.vertices.length;\n    this.geometry.updateAttribute(this.attrs.position);\n    this.geometry.updateAttribute(this.attrs.color);\n  }\n\n  toggle() {\n    if (this.enabled) {\n      this.enabled = false;\n      this.setParent(null);\n    } else {\n      this.enabled = true;\n      this.setParent(this.scene);\n    }\n  }\n}\n", "export class MessageBus {\n  constructor () {\n    this.types = {};\n  }\n\n  register(type, func) {\n    if (this.types[type] === undefined) {this.types[type] = [];}\n    const index = this.types[type].push(func);\n    // (index - 1) because the push method returns the length of the array\n    return () => {delete this.types[type][index-1]};\n  }\n\n  send(type, data) {\n    if(type in this.types) {\n      for (const func of this.types[type]) {\n        func(data);\n      }\n    }\n  }\n}\n", "import * as wasm from \"./rapier_wasm3d_bg.wasm\";\n\nconst heap = new Array(128).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nlet heap_next = heap.length;\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nfunction getObject(idx) { return heap[idx]; }\n\nfunction dropObject(idx) {\n    if (idx < 132) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nlet cachedFloat64Memory0 = null;\n\nfunction getFloat64Memory0() {\n    if (cachedFloat64Memory0 === null || cachedFloat64Memory0.byteLength === 0) {\n        cachedFloat64Memory0 = new Float64Array(wasm.memory.buffer);\n    }\n    return cachedFloat64Memory0;\n}\n\nlet cachedInt32Memory0 = null;\n\nfunction getInt32Memory0() {\n    if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {\n        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachedInt32Memory0;\n}\n\nconst lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;\n\nlet cachedTextDecoder = new lTextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachedUint8Memory0 = null;\n\nfunction getUint8Memory0() {\n    if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {\n        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n/**\n* @returns {string}\n*/\nexport function version() {\n    let deferred1_0;\n    let deferred1_1;\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.version(retptr);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        deferred1_0 = r0;\n        deferred1_1 = r1;\n        return getStringFromWasm0(r0, r1);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n    }\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n    return instance.ptr;\n}\n\nlet cachedFloat32Memory0 = null;\n\nfunction getFloat32Memory0() {\n    if (cachedFloat32Memory0 === null || cachedFloat32Memory0.byteLength === 0) {\n        cachedFloat32Memory0 = new Float32Array(wasm.memory.buffer);\n    }\n    return cachedFloat32Memory0;\n}\n\nlet stack_pointer = 128;\n\nfunction addBorrowedObject(obj) {\n    if (stack_pointer == 1) throw new Error('out of js stack');\n    heap[--stack_pointer] = obj;\n    return stack_pointer;\n}\n\nfunction getArrayF32FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getFloat32Memory0().subarray(ptr / 4, ptr / 4 + len);\n}\n\nlet cachedUint32Memory0 = null;\n\nfunction getUint32Memory0() {\n    if (cachedUint32Memory0 === null || cachedUint32Memory0.byteLength === 0) {\n        cachedUint32Memory0 = new Uint32Array(wasm.memory.buffer);\n    }\n    return cachedUint32Memory0;\n}\n\nfunction getArrayU32FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getUint32Memory0().subarray(ptr / 4, ptr / 4 + len);\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nfunction passArrayF32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4, 4) >>> 0;\n    getFloat32Memory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction passArray32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4, 4) >>> 0;\n    getUint32Memory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        wasm.__wbindgen_exn_store(addHeapObject(e));\n    }\n}\n/**\n*/\nexport const RawJointType = Object.freeze({ Revolute:0,\"0\":\"Revolute\",Fixed:1,\"1\":\"Fixed\",Prismatic:2,\"2\":\"Prismatic\",Spherical:3,\"3\":\"Spherical\",Generic:4,\"4\":\"Generic\", });\n/**\n*/\nexport const RawMotorModel = Object.freeze({ AccelerationBased:0,\"0\":\"AccelerationBased\",ForceBased:1,\"1\":\"ForceBased\", });\n/**\n*/\nexport const RawJointAxis = Object.freeze({ X:0,\"0\":\"X\",Y:1,\"1\":\"Y\",Z:2,\"2\":\"Z\",AngX:3,\"3\":\"AngX\",AngY:4,\"4\":\"AngY\",AngZ:5,\"5\":\"AngZ\", });\n/**\n*/\nexport const RawRigidBodyType = Object.freeze({ Dynamic:0,\"0\":\"Dynamic\",Fixed:1,\"1\":\"Fixed\",KinematicPositionBased:2,\"2\":\"KinematicPositionBased\",KinematicVelocityBased:3,\"3\":\"KinematicVelocityBased\", });\n/**\n*/\nexport const RawFeatureType = Object.freeze({ Vertex:0,\"0\":\"Vertex\",Edge:1,\"1\":\"Edge\",Face:2,\"2\":\"Face\",Unknown:3,\"3\":\"Unknown\", });\n/**\n*/\nexport const RawShapeType = Object.freeze({ Ball:0,\"0\":\"Ball\",Cuboid:1,\"1\":\"Cuboid\",Capsule:2,\"2\":\"Capsule\",Segment:3,\"3\":\"Segment\",Polyline:4,\"4\":\"Polyline\",Triangle:5,\"5\":\"Triangle\",TriMesh:6,\"6\":\"TriMesh\",HeightField:7,\"7\":\"HeightField\",Compound:8,\"8\":\"Compound\",ConvexPolyhedron:9,\"9\":\"ConvexPolyhedron\",Cylinder:10,\"10\":\"Cylinder\",Cone:11,\"11\":\"Cone\",RoundCuboid:12,\"12\":\"RoundCuboid\",RoundTriangle:13,\"13\":\"RoundTriangle\",RoundCylinder:14,\"14\":\"RoundCylinder\",RoundCone:15,\"15\":\"RoundCone\",RoundConvexPolyhedron:16,\"16\":\"RoundConvexPolyhedron\",HalfSpace:17,\"17\":\"HalfSpace\", });\n/**\n*/\nexport class RawBroadPhase {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawBroadPhase.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawbroadphase_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawbroadphase_new();\n        return RawBroadPhase.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawCCDSolver {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawCCDSolver.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawccdsolver_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawccdsolver_new();\n        return RawCCDSolver.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawCharacterCollision {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawCharacterCollision.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcharactercollision_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawcharactercollision_new();\n        return RawCharacterCollision.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    handle() {\n        const ret = wasm.rawcharactercollision_handle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    translationDeltaApplied() {\n        const ret = wasm.rawcharactercollision_translationDeltaApplied(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    translationDeltaRemaining() {\n        const ret = wasm.rawcharactercollision_translationDeltaRemaining(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    toi() {\n        const ret = wasm.rawcharactercollision_toi(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    worldWitness1() {\n        const ret = wasm.rawcharactercollision_worldWitness1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    worldWitness2() {\n        const ret = wasm.rawcharactercollision_worldWitness2(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    worldNormal1() {\n        const ret = wasm.rawcharactercollision_worldNormal1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    worldNormal2() {\n        const ret = wasm.rawcharactercollision_worldNormal2(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawColliderSet {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawColliderSet.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcolliderset_free(ptr);\n    }\n    /**\n    * The world-space translation of this collider.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    coTranslation(handle) {\n        const ret = wasm.rawcolliderset_coTranslation(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The world-space orientation of this collider.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    coRotation(handle) {\n        const ret = wasm.rawcolliderset_coRotation(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * Sets the translation of this collider.\n    *\n    * # Parameters\n    * - `x`: the world-space position of the collider along the `x` axis.\n    * - `y`: the world-space position of the collider along the `y` axis.\n    * - `z`: the world-space position of the collider along the `z` axis.\n    * - `wakeUp`: forces the collider to wake-up so it is properly affected by forces if it\n    * wasn't moving before modifying its position.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    */\n    coSetTranslation(handle, x, y, z) {\n        wasm.rawcolliderset_coSetTranslation(this.__wbg_ptr, handle, x, y, z);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    */\n    coSetTranslationWrtParent(handle, x, y, z) {\n        wasm.rawcolliderset_coSetTranslationWrtParent(this.__wbg_ptr, handle, x, y, z);\n    }\n    /**\n    * Sets the rotation quaternion of this collider.\n    *\n    * This does nothing if a zero quaternion is provided.\n    *\n    * # Parameters\n    * - `x`: the first vector component of the quaternion.\n    * - `y`: the second vector component of the quaternion.\n    * - `z`: the third vector component of the quaternion.\n    * - `w`: the scalar component of the quaternion.\n    * - `wakeUp`: forces the collider to wake-up so it is properly affected by forces if it\n    * wasn't moving before modifying its position.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    * @param {number} w\n    */\n    coSetRotation(handle, x, y, z, w) {\n        wasm.rawcolliderset_coSetRotation(this.__wbg_ptr, handle, x, y, z, w);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    * @param {number} w\n    */\n    coSetRotationWrtParent(handle, x, y, z, w) {\n        wasm.rawcolliderset_coSetRotationWrtParent(this.__wbg_ptr, handle, x, y, z, w);\n    }\n    /**\n    * Is this collider a sensor?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    coIsSensor(handle) {\n        const ret = wasm.rawcolliderset_coIsSensor(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * The type of the shape of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coShapeType(handle) {\n        const ret = wasm.rawcolliderset_coShapeType(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @returns {RawVector | undefined}\n    */\n    coHalfspaceNormal(handle) {\n        const ret = wasm.rawcolliderset_coHalfspaceNormal(this.__wbg_ptr, handle);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * The half-extents of this collider if it is has a cuboid shape.\n    * @param {number} handle\n    * @returns {RawVector | undefined}\n    */\n    coHalfExtents(handle) {\n        const ret = wasm.rawcolliderset_coHalfExtents(this.__wbg_ptr, handle);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * Set the half-extents of this collider if it has a cuboid shape.\n    * @param {number} handle\n    * @param {RawVector} newHalfExtents\n    */\n    coSetHalfExtents(handle, newHalfExtents) {\n        _assertClass(newHalfExtents, RawVector);\n        wasm.rawcolliderset_coSetHalfExtents(this.__wbg_ptr, handle, newHalfExtents.__wbg_ptr);\n    }\n    /**\n    * The radius of this collider if it is a ball, capsule, cylinder, or cone shape.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coRadius(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coRadius(retptr, this.__wbg_ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Set the radius of this collider if it is a ball, capsule, cylinder, or cone shape.\n    * @param {number} handle\n    * @param {number} newRadius\n    */\n    coSetRadius(handle, newRadius) {\n        wasm.rawcolliderset_coSetRadius(this.__wbg_ptr, handle, newRadius);\n    }\n    /**\n    * The half height of this collider if it is a capsule, cylinder, or cone shape.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coHalfHeight(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coHalfHeight(retptr, this.__wbg_ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Set the half height of this collider if it is a capsule, cylinder, or cone shape.\n    * @param {number} handle\n    * @param {number} newHalfheight\n    */\n    coSetHalfHeight(handle, newHalfheight) {\n        wasm.rawcolliderset_coSetHalfHeight(this.__wbg_ptr, handle, newHalfheight);\n    }\n    /**\n    * The radius of the round edges of this collider.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coRoundRadius(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coRoundRadius(retptr, this.__wbg_ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Set the radius of the round edges of this collider.\n    * @param {number} handle\n    * @param {number} newBorderRadius\n    */\n    coSetRoundRadius(handle, newBorderRadius) {\n        wasm.rawcolliderset_coSetRoundRadius(this.__wbg_ptr, handle, newBorderRadius);\n    }\n    /**\n    * The vertices of this triangle mesh, polyline, convex polyhedron, segment, triangle or convex polyhedron, if it is one.\n    * @param {number} handle\n    * @returns {Float32Array | undefined}\n    */\n    coVertices(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coVertices(retptr, this.__wbg_ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v1;\n            if (r0 !== 0) {\n                v1 = getArrayF32FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 4);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The indices of this triangle mesh, polyline, or convex polyhedron, if it is one.\n    * @param {number} handle\n    * @returns {Uint32Array | undefined}\n    */\n    coIndices(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coIndices(retptr, this.__wbg_ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v1;\n            if (r0 !== 0) {\n                v1 = getArrayU32FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 4);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The height of this heightfield if it is one.\n    * @param {number} handle\n    * @returns {Float32Array | undefined}\n    */\n    coHeightfieldHeights(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coHeightfieldHeights(retptr, this.__wbg_ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v1;\n            if (r0 !== 0) {\n                v1 = getArrayF32FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 4);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The scaling factor applied of this heightfield if it is one.\n    * @param {number} handle\n    * @returns {RawVector | undefined}\n    */\n    coHeightfieldScale(handle) {\n        const ret = wasm.rawcolliderset_coHeightfieldScale(this.__wbg_ptr, handle);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * The number of rows on this heightfield's height matrix, if it is one.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coHeightfieldNRows(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coHeightfieldNRows(retptr, this.__wbg_ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The number of columns on this heightfield's height matrix, if it is one.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coHeightfieldNCols(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coHeightfieldNCols(retptr, this.__wbg_ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The unique integer identifier of the collider this collider is attached to.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coParent(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coParent(retptr, this.__wbg_ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r2 = getFloat64Memory0()[retptr / 8 + 1];\n            return r0 === 0 ? undefined : r2;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} enabled\n    */\n    coSetEnabled(handle, enabled) {\n        wasm.rawcolliderset_coSetEnabled(this.__wbg_ptr, handle, enabled);\n    }\n    /**\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    coIsEnabled(handle) {\n        const ret = wasm.rawcolliderset_coIsEnabled(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * The friction coefficient of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coFriction(handle) {\n        const ret = wasm.rawcolliderset_coFriction(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The restitution coefficient of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coRestitution(handle) {\n        const ret = wasm.rawcolliderset_coRestitution(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The density of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coDensity(handle) {\n        const ret = wasm.rawcolliderset_coDensity(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The mass of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coMass(handle) {\n        const ret = wasm.rawcolliderset_coMass(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The volume of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coVolume(handle) {\n        const ret = wasm.rawcolliderset_coVolume(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The collision groups of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coCollisionGroups(handle) {\n        const ret = wasm.rawcolliderset_coCollisionGroups(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * The solver groups of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coSolverGroups(handle) {\n        const ret = wasm.rawcolliderset_coSolverGroups(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * The physics hooks enabled for this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coActiveHooks(handle) {\n        const ret = wasm.rawcolliderset_coActiveHooks(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * The collision types enabled for this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coActiveCollisionTypes(handle) {\n        const ret = wasm.rawcolliderset_coActiveCollisionTypes(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The events enabled for this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coActiveEvents(handle) {\n        const ret = wasm.rawcolliderset_coActiveEvents(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * The total force magnitude beyond which a contact force event can be emitted.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coContactForceEventThreshold(handle) {\n        const ret = wasm.rawcolliderset_coContactForceEventThreshold(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} point\n    * @returns {boolean}\n    */\n    coContainsPoint(handle, point) {\n        _assertClass(point, RawVector);\n        const ret = wasm.rawcolliderset_coContainsPoint(this.__wbg_ptr, handle, point.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} colliderVel\n    * @param {RawShape} shape2\n    * @param {RawVector} shape2Pos\n    * @param {RawRotation} shape2Rot\n    * @param {RawVector} shape2Vel\n    * @param {number} maxToi\n    * @param {boolean} stop_at_penetration\n    * @returns {RawShapeTOI | undefined}\n    */\n    coCastShape(handle, colliderVel, shape2, shape2Pos, shape2Rot, shape2Vel, maxToi, stop_at_penetration) {\n        _assertClass(colliderVel, RawVector);\n        _assertClass(shape2, RawShape);\n        _assertClass(shape2Pos, RawVector);\n        _assertClass(shape2Rot, RawRotation);\n        _assertClass(shape2Vel, RawVector);\n        const ret = wasm.rawcolliderset_coCastShape(this.__wbg_ptr, handle, colliderVel.__wbg_ptr, shape2.__wbg_ptr, shape2Pos.__wbg_ptr, shape2Rot.__wbg_ptr, shape2Vel.__wbg_ptr, maxToi, stop_at_penetration);\n        return ret === 0 ? undefined : RawShapeTOI.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} collider1Vel\n    * @param {number} collider2handle\n    * @param {RawVector} collider2Vel\n    * @param {number} max_toi\n    * @param {boolean} stop_at_penetration\n    * @returns {RawShapeColliderTOI | undefined}\n    */\n    coCastCollider(handle, collider1Vel, collider2handle, collider2Vel, max_toi, stop_at_penetration) {\n        _assertClass(collider1Vel, RawVector);\n        _assertClass(collider2Vel, RawVector);\n        const ret = wasm.rawcolliderset_coCastCollider(this.__wbg_ptr, handle, collider1Vel.__wbg_ptr, collider2handle, collider2Vel.__wbg_ptr, max_toi, stop_at_penetration);\n        return ret === 0 ? undefined : RawShapeColliderTOI.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawShape} shape2\n    * @param {RawVector} shapePos2\n    * @param {RawRotation} shapeRot2\n    * @returns {boolean}\n    */\n    coIntersectsShape(handle, shape2, shapePos2, shapeRot2) {\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        const ret = wasm.rawcolliderset_coIntersectsShape(this.__wbg_ptr, handle, shape2.__wbg_ptr, shapePos2.__wbg_ptr, shapeRot2.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawShape} shape2\n    * @param {RawVector} shapePos2\n    * @param {RawRotation} shapeRot2\n    * @param {number} prediction\n    * @returns {RawShapeContact | undefined}\n    */\n    coContactShape(handle, shape2, shapePos2, shapeRot2, prediction) {\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        const ret = wasm.rawcolliderset_coContactShape(this.__wbg_ptr, handle, shape2.__wbg_ptr, shapePos2.__wbg_ptr, shapeRot2.__wbg_ptr, prediction);\n        return ret === 0 ? undefined : RawShapeContact.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} collider2handle\n    * @param {number} prediction\n    * @returns {RawShapeContact | undefined}\n    */\n    coContactCollider(handle, collider2handle, prediction) {\n        const ret = wasm.rawcolliderset_coContactCollider(this.__wbg_ptr, handle, collider2handle, prediction);\n        return ret === 0 ? undefined : RawShapeContact.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} point\n    * @param {boolean} solid\n    * @returns {RawPointProjection}\n    */\n    coProjectPoint(handle, point, solid) {\n        _assertClass(point, RawVector);\n        const ret = wasm.rawcolliderset_coProjectPoint(this.__wbg_ptr, handle, point.__wbg_ptr, solid);\n        return RawPointProjection.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @returns {boolean}\n    */\n    coIntersectsRay(handle, rayOrig, rayDir, maxToi) {\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawcolliderset_coIntersectsRay(this.__wbg_ptr, handle, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @returns {number}\n    */\n    coCastRay(handle, rayOrig, rayDir, maxToi, solid) {\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawcolliderset_coCastRay(this.__wbg_ptr, handle, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @returns {RawRayIntersection | undefined}\n    */\n    coCastRayAndGetNormal(handle, rayOrig, rayDir, maxToi, solid) {\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawcolliderset_coCastRayAndGetNormal(this.__wbg_ptr, handle, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid);\n        return ret === 0 ? undefined : RawRayIntersection.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} is_sensor\n    */\n    coSetSensor(handle, is_sensor) {\n        wasm.rawcolliderset_coSetSensor(this.__wbg_ptr, handle, is_sensor);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} restitution\n    */\n    coSetRestitution(handle, restitution) {\n        wasm.rawcolliderset_coSetRestitution(this.__wbg_ptr, handle, restitution);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} friction\n    */\n    coSetFriction(handle, friction) {\n        wasm.rawcolliderset_coSetFriction(this.__wbg_ptr, handle, friction);\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n    coFrictionCombineRule(handle) {\n        const ret = wasm.rawcolliderset_coFrictionCombineRule(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} rule\n    */\n    coSetFrictionCombineRule(handle, rule) {\n        wasm.rawcolliderset_coSetFrictionCombineRule(this.__wbg_ptr, handle, rule);\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n    coRestitutionCombineRule(handle) {\n        const ret = wasm.rawcolliderset_coRestitutionCombineRule(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} rule\n    */\n    coSetRestitutionCombineRule(handle, rule) {\n        wasm.rawcolliderset_coSetRestitutionCombineRule(this.__wbg_ptr, handle, rule);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} groups\n    */\n    coSetCollisionGroups(handle, groups) {\n        wasm.rawcolliderset_coSetCollisionGroups(this.__wbg_ptr, handle, groups);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} groups\n    */\n    coSetSolverGroups(handle, groups) {\n        wasm.rawcolliderset_coSetSolverGroups(this.__wbg_ptr, handle, groups);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} hooks\n    */\n    coSetActiveHooks(handle, hooks) {\n        wasm.rawcolliderset_coSetActiveHooks(this.__wbg_ptr, handle, hooks);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} events\n    */\n    coSetActiveEvents(handle, events) {\n        wasm.rawcolliderset_coSetActiveEvents(this.__wbg_ptr, handle, events);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} types\n    */\n    coSetActiveCollisionTypes(handle, types) {\n        wasm.rawcolliderset_coSetActiveCollisionTypes(this.__wbg_ptr, handle, types);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawShape} shape\n    */\n    coSetShape(handle, shape) {\n        _assertClass(shape, RawShape);\n        wasm.rawcolliderset_coSetShape(this.__wbg_ptr, handle, shape.__wbg_ptr);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} threshold\n    */\n    coSetContactForceEventThreshold(handle, threshold) {\n        wasm.rawcolliderset_coSetContactForceEventThreshold(this.__wbg_ptr, handle, threshold);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} density\n    */\n    coSetDensity(handle, density) {\n        wasm.rawcolliderset_coSetDensity(this.__wbg_ptr, handle, density);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} mass\n    */\n    coSetMass(handle, mass) {\n        wasm.rawcolliderset_coSetMass(this.__wbg_ptr, handle, mass);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} mass\n    * @param {RawVector} centerOfMass\n    * @param {RawVector} principalAngularInertia\n    * @param {RawRotation} angularInertiaFrame\n    */\n    coSetMassProperties(handle, mass, centerOfMass, principalAngularInertia, angularInertiaFrame) {\n        _assertClass(centerOfMass, RawVector);\n        _assertClass(principalAngularInertia, RawVector);\n        _assertClass(angularInertiaFrame, RawRotation);\n        wasm.rawcolliderset_coSetMassProperties(this.__wbg_ptr, handle, mass, centerOfMass.__wbg_ptr, principalAngularInertia.__wbg_ptr, angularInertiaFrame.__wbg_ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawcolliderset_new();\n        return RawColliderSet.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.rawcolliderset_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    contains(handle) {\n        const ret = wasm.rawcolliderset_contains(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * @param {boolean} enabled\n    * @param {RawShape} shape\n    * @param {RawVector} translation\n    * @param {RawRotation} rotation\n    * @param {number} massPropsMode\n    * @param {number} mass\n    * @param {RawVector} centerOfMass\n    * @param {RawVector} principalAngularInertia\n    * @param {RawRotation} angularInertiaFrame\n    * @param {number} density\n    * @param {number} friction\n    * @param {number} restitution\n    * @param {number} frictionCombineRule\n    * @param {number} restitutionCombineRule\n    * @param {boolean} isSensor\n    * @param {number} collisionGroups\n    * @param {number} solverGroups\n    * @param {number} activeCollisionTypes\n    * @param {number} activeHooks\n    * @param {number} activeEvents\n    * @param {number} contactForceEventThreshold\n    * @param {boolean} hasParent\n    * @param {number} parent\n    * @param {RawRigidBodySet} bodies\n    * @returns {number | undefined}\n    */\n    createCollider(enabled, shape, translation, rotation, massPropsMode, mass, centerOfMass, principalAngularInertia, angularInertiaFrame, density, friction, restitution, frictionCombineRule, restitutionCombineRule, isSensor, collisionGroups, solverGroups, activeCollisionTypes, activeHooks, activeEvents, contactForceEventThreshold, hasParent, parent, bodies) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(shape, RawShape);\n            _assertClass(translation, RawVector);\n            _assertClass(rotation, RawRotation);\n            _assertClass(centerOfMass, RawVector);\n            _assertClass(principalAngularInertia, RawVector);\n            _assertClass(angularInertiaFrame, RawRotation);\n            _assertClass(bodies, RawRigidBodySet);\n            wasm.rawcolliderset_createCollider(retptr, this.__wbg_ptr, enabled, shape.__wbg_ptr, translation.__wbg_ptr, rotation.__wbg_ptr, massPropsMode, mass, centerOfMass.__wbg_ptr, principalAngularInertia.__wbg_ptr, angularInertiaFrame.__wbg_ptr, density, friction, restitution, frictionCombineRule, restitutionCombineRule, isSensor, collisionGroups, solverGroups, activeCollisionTypes, activeHooks, activeEvents, contactForceEventThreshold, hasParent, parent, bodies.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r2 = getFloat64Memory0()[retptr / 8 + 1];\n            return r0 === 0 ? undefined : r2;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Removes a collider from this set and wake-up the rigid-body it is attached to.\n    * @param {number} handle\n    * @param {RawIslandManager} islands\n    * @param {RawRigidBodySet} bodies\n    * @param {boolean} wakeUp\n    */\n    remove(handle, islands, bodies, wakeUp) {\n        _assertClass(islands, RawIslandManager);\n        _assertClass(bodies, RawRigidBodySet);\n        wasm.rawcolliderset_remove(this.__wbg_ptr, handle, islands.__wbg_ptr, bodies.__wbg_ptr, wakeUp);\n    }\n    /**\n    * Checks if a collider with the given integer handle exists.\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    isHandleValid(handle) {\n        const ret = wasm.rawcolliderset_contains(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each collider managed by this collider set.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each collider managed by this collider set. Called as `f(handle)`.\n    * @param {Function} f\n    */\n    forEachColliderHandle(f) {\n        try {\n            wasm.rawcolliderset_forEachColliderHandle(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n/**\n*/\nexport class RawContactForceEvent {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawContactForceEvent.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcontactforceevent_free(ptr);\n    }\n    /**\n    * The first collider involved in the contact.\n    * @returns {number}\n    */\n    collider1() {\n        const ret = wasm.rawcharactercollision_handle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * The second collider involved in the contact.\n    * @returns {number}\n    */\n    collider2() {\n        const ret = wasm.rawcontactforceevent_collider2(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * The sum of all the forces between the two colliders.\n    * @returns {RawVector}\n    */\n    total_force() {\n        const ret = wasm.rawcontactforceevent_total_force(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The sum of the magnitudes of each force between the two colliders.\n    *\n    * Note that this is **not** the same as the magnitude of `self.total_force`.\n    * Here we are summing the magnitude of all the forces, instead of taking\n    * the magnitude of their sum.\n    * @returns {number}\n    */\n    total_force_magnitude() {\n        const ret = wasm.rawcontactforceevent_total_force_magnitude(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * The world-space (unit) direction of the force with strongest magnitude.\n    * @returns {RawVector}\n    */\n    max_force_direction() {\n        const ret = wasm.rawcontactforceevent_max_force_direction(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The magnitude of the largest force at a contact point of this contact pair.\n    * @returns {number}\n    */\n    max_force_magnitude() {\n        const ret = wasm.rawcontactforceevent_max_force_magnitude(this.__wbg_ptr);\n        return ret;\n    }\n}\n/**\n*/\nexport class RawContactManifold {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawContactManifold.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcontactmanifold_free(ptr);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal() {\n        const ret = wasm.rawcontactmanifold_normal(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    local_n1() {\n        const ret = wasm.rawcontactmanifold_local_n1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    local_n2() {\n        const ret = wasm.rawcontactmanifold_local_n2(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    subshape1() {\n        const ret = wasm.rawcontactmanifold_subshape1(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    subshape2() {\n        const ret = wasm.rawcontactmanifold_subshape2(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    num_contacts() {\n        const ret = wasm.rawcontactmanifold_num_contacts(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector | undefined}\n    */\n    contact_local_p1(i) {\n        const ret = wasm.rawcontactmanifold_contact_local_p1(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector | undefined}\n    */\n    contact_local_p2(i) {\n        const ret = wasm.rawcontactmanifold_contact_local_p2(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_dist(i) {\n        const ret = wasm.rawcontactmanifold_contact_dist(this.__wbg_ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_fid1(i) {\n        const ret = wasm.rawcontactmanifold_contact_fid1(this.__wbg_ptr, i);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_fid2(i) {\n        const ret = wasm.rawcontactmanifold_contact_fid2(this.__wbg_ptr, i);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_impulse(i) {\n        const ret = wasm.rawcontactmanifold_contact_impulse(this.__wbg_ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_tangent_impulse_x(i) {\n        const ret = wasm.rawcontactmanifold_contact_tangent_impulse_x(this.__wbg_ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_tangent_impulse_y(i) {\n        const ret = wasm.rawcontactmanifold_contact_tangent_impulse_y(this.__wbg_ptr, i);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    num_solver_contacts() {\n        const ret = wasm.rawcontactmanifold_num_solver_contacts(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector | undefined}\n    */\n    solver_contact_point(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_point(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    solver_contact_dist(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_dist(this.__wbg_ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    solver_contact_friction(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_friction(this.__wbg_ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    solver_contact_restitution(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_restitution(this.__wbg_ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector}\n    */\n    solver_contact_tangent_velocity(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_tangent_velocity(this.__wbg_ptr, i);\n        return RawVector.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawContactPair {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawContactPair.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcontactpair_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    collider1() {\n        const ret = wasm.rawcontactpair_collider1(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    collider2() {\n        const ret = wasm.rawcontactpair_collider2(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    numContactManifolds() {\n        const ret = wasm.rawcontactpair_numContactManifolds(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {RawContactManifold | undefined}\n    */\n    contactManifold(i) {\n        const ret = wasm.rawcontactpair_contactManifold(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawContactManifold.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawDebugRenderPipeline {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawDebugRenderPipeline.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawdebugrenderpipeline_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawdebugrenderpipeline_new();\n        return RawDebugRenderPipeline.__wrap(ret);\n    }\n    /**\n    * @returns {Float32Array}\n    */\n    vertices() {\n        const ret = wasm.rawdebugrenderpipeline_vertices(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @returns {Float32Array}\n    */\n    colors() {\n        const ret = wasm.rawdebugrenderpipeline_colors(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawImpulseJointSet} impulse_joints\n    * @param {RawMultibodyJointSet} multibody_joints\n    * @param {RawNarrowPhase} narrow_phase\n    */\n    render(bodies, colliders, impulse_joints, multibody_joints, narrow_phase) {\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(impulse_joints, RawImpulseJointSet);\n        _assertClass(multibody_joints, RawMultibodyJointSet);\n        _assertClass(narrow_phase, RawNarrowPhase);\n        wasm.rawdebugrenderpipeline_render(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, impulse_joints.__wbg_ptr, multibody_joints.__wbg_ptr, narrow_phase.__wbg_ptr);\n    }\n}\n/**\n*/\nexport class RawDeserializedWorld {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawDeserializedWorld.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawdeserializedworld_free(ptr);\n    }\n    /**\n    * @returns {RawVector | undefined}\n    */\n    takeGravity() {\n        const ret = wasm.rawdeserializedworld_takeGravity(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawIntegrationParameters | undefined}\n    */\n    takeIntegrationParameters() {\n        const ret = wasm.rawdeserializedworld_takeIntegrationParameters(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawIntegrationParameters.__wrap(ret);\n    }\n    /**\n    * @returns {RawIslandManager | undefined}\n    */\n    takeIslandManager() {\n        const ret = wasm.rawdeserializedworld_takeIslandManager(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawIslandManager.__wrap(ret);\n    }\n    /**\n    * @returns {RawBroadPhase | undefined}\n    */\n    takeBroadPhase() {\n        const ret = wasm.rawdeserializedworld_takeBroadPhase(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawBroadPhase.__wrap(ret);\n    }\n    /**\n    * @returns {RawNarrowPhase | undefined}\n    */\n    takeNarrowPhase() {\n        const ret = wasm.rawdeserializedworld_takeNarrowPhase(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawNarrowPhase.__wrap(ret);\n    }\n    /**\n    * @returns {RawRigidBodySet | undefined}\n    */\n    takeBodies() {\n        const ret = wasm.rawdeserializedworld_takeBodies(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawRigidBodySet.__wrap(ret);\n    }\n    /**\n    * @returns {RawColliderSet | undefined}\n    */\n    takeColliders() {\n        const ret = wasm.rawdeserializedworld_takeColliders(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawColliderSet.__wrap(ret);\n    }\n    /**\n    * @returns {RawImpulseJointSet | undefined}\n    */\n    takeImpulseJoints() {\n        const ret = wasm.rawdeserializedworld_takeImpulseJoints(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawImpulseJointSet.__wrap(ret);\n    }\n    /**\n    * @returns {RawMultibodyJointSet | undefined}\n    */\n    takeMultibodyJoints() {\n        const ret = wasm.rawdeserializedworld_takeMultibodyJoints(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawMultibodyJointSet.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawDynamicRayCastVehicleController {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawDynamicRayCastVehicleController.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawdynamicraycastvehiclecontroller_free(ptr);\n    }\n    /**\n    * @param {number} chassis\n    */\n    constructor(chassis) {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_new(chassis);\n        return RawDynamicRayCastVehicleController.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    current_vehicle_speed() {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_current_vehicle_speed(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    chassis() {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_chassis(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    index_up_axis() {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_index_up_axis(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} axis\n    */\n    set_index_up_axis(axis) {\n        wasm.rawdynamicraycastvehiclecontroller_set_index_up_axis(this.__wbg_ptr, axis);\n    }\n    /**\n    * @returns {number}\n    */\n    index_forward_axis() {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_index_forward_axis(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} axis\n    */\n    set_index_forward_axis(axis) {\n        wasm.rawdynamicraycastvehiclecontroller_set_index_forward_axis(this.__wbg_ptr, axis);\n    }\n    /**\n    * @param {RawVector} chassis_connection_cs\n    * @param {RawVector} direction_cs\n    * @param {RawVector} axle_cs\n    * @param {number} suspension_rest_length\n    * @param {number} radius\n    */\n    add_wheel(chassis_connection_cs, direction_cs, axle_cs, suspension_rest_length, radius) {\n        _assertClass(chassis_connection_cs, RawVector);\n        _assertClass(direction_cs, RawVector);\n        _assertClass(axle_cs, RawVector);\n        wasm.rawdynamicraycastvehiclecontroller_add_wheel(this.__wbg_ptr, chassis_connection_cs.__wbg_ptr, direction_cs.__wbg_ptr, axle_cs.__wbg_ptr, suspension_rest_length, radius);\n    }\n    /**\n    * @returns {number}\n    */\n    num_wheels() {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_num_wheels(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} dt\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawQueryPipeline} queries\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {Function} filter_predicate\n    */\n    update_vehicle(dt, bodies, colliders, queries, filter_flags, filter_groups, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(queries, RawQueryPipeline);\n            wasm.rawdynamicraycastvehiclecontroller_update_vehicle(this.__wbg_ptr, dt, bodies.__wbg_ptr, colliders.__wbg_ptr, queries.__wbg_ptr, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, addBorrowedObject(filter_predicate));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector | undefined}\n    */\n    wheel_chassis_connection_point_cs(i) {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_wheel_chassis_connection_point_cs(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} i\n    * @param {RawVector} value\n    */\n    set_wheel_chassis_connection_point_cs(i, value) {\n        _assertClass(value, RawVector);\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_chassis_connection_point_cs(this.__wbg_ptr, i, value.__wbg_ptr);\n    }\n    /**\n    * @param {number} i\n    * @returns {number | undefined}\n    */\n    wheel_suspension_rest_length(i) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawdynamicraycastvehiclecontroller_wheel_suspension_rest_length(retptr, this.__wbg_ptr, i);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} i\n    * @param {number} value\n    */\n    set_wheel_suspension_rest_length(i, value) {\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_suspension_rest_length(this.__wbg_ptr, i, value);\n    }\n    /**\n    * @param {number} i\n    * @returns {number | undefined}\n    */\n    wheel_max_suspension_travel(i) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawdynamicraycastvehiclecontroller_wheel_max_suspension_travel(retptr, this.__wbg_ptr, i);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} i\n    * @param {number} value\n    */\n    set_wheel_max_suspension_travel(i, value) {\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_max_suspension_travel(this.__wbg_ptr, i, value);\n    }\n    /**\n    * @param {number} i\n    * @returns {number | undefined}\n    */\n    wheel_radius(i) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawdynamicraycastvehiclecontroller_wheel_radius(retptr, this.__wbg_ptr, i);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} i\n    * @param {number} value\n    */\n    set_wheel_radius(i, value) {\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_radius(this.__wbg_ptr, i, value);\n    }\n    /**\n    * @param {number} i\n    * @returns {number | undefined}\n    */\n    wheel_suspension_stiffness(i) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawdynamicraycastvehiclecontroller_wheel_suspension_stiffness(retptr, this.__wbg_ptr, i);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} i\n    * @param {number} value\n    */\n    set_wheel_suspension_stiffness(i, value) {\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_suspension_stiffness(this.__wbg_ptr, i, value);\n    }\n    /**\n    * @param {number} i\n    * @returns {number | undefined}\n    */\n    wheel_suspension_compression(i) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawdynamicraycastvehiclecontroller_wheel_suspension_compression(retptr, this.__wbg_ptr, i);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} i\n    * @param {number} value\n    */\n    set_wheel_suspension_compression(i, value) {\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_suspension_compression(this.__wbg_ptr, i, value);\n    }\n    /**\n    * @param {number} i\n    * @returns {number | undefined}\n    */\n    wheel_suspension_relaxation(i) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawdynamicraycastvehiclecontroller_wheel_suspension_relaxation(retptr, this.__wbg_ptr, i);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} i\n    * @param {number} value\n    */\n    set_wheel_suspension_relaxation(i, value) {\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_suspension_relaxation(this.__wbg_ptr, i, value);\n    }\n    /**\n    * @param {number} i\n    * @returns {number | undefined}\n    */\n    wheel_max_suspension_force(i) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawdynamicraycastvehiclecontroller_wheel_max_suspension_force(retptr, this.__wbg_ptr, i);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} i\n    * @param {number} value\n    */\n    set_wheel_max_suspension_force(i, value) {\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_max_suspension_force(this.__wbg_ptr, i, value);\n    }\n    /**\n    * @param {number} i\n    * @returns {number | undefined}\n    */\n    wheel_brake(i) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawdynamicraycastvehiclecontroller_wheel_brake(retptr, this.__wbg_ptr, i);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} i\n    * @param {number} value\n    */\n    set_wheel_brake(i, value) {\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_brake(this.__wbg_ptr, i, value);\n    }\n    /**\n    * @param {number} i\n    * @returns {number | undefined}\n    */\n    wheel_steering(i) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawdynamicraycastvehiclecontroller_wheel_steering(retptr, this.__wbg_ptr, i);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} i\n    * @param {number} value\n    */\n    set_wheel_steering(i, value) {\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_steering(this.__wbg_ptr, i, value);\n    }\n    /**\n    * @param {number} i\n    * @returns {number | undefined}\n    */\n    wheel_engine_force(i) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawdynamicraycastvehiclecontroller_wheel_engine_force(retptr, this.__wbg_ptr, i);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} i\n    * @param {number} value\n    */\n    set_wheel_engine_force(i, value) {\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_engine_force(this.__wbg_ptr, i, value);\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector | undefined}\n    */\n    wheel_direction_cs(i) {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_wheel_direction_cs(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} i\n    * @param {RawVector} value\n    */\n    set_wheel_direction_cs(i, value) {\n        _assertClass(value, RawVector);\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_direction_cs(this.__wbg_ptr, i, value.__wbg_ptr);\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector | undefined}\n    */\n    wheel_axle_cs(i) {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_wheel_axle_cs(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} i\n    * @param {RawVector} value\n    */\n    set_wheel_axle_cs(i, value) {\n        _assertClass(value, RawVector);\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_axle_cs(this.__wbg_ptr, i, value.__wbg_ptr);\n    }\n    /**\n    * @param {number} i\n    * @returns {number | undefined}\n    */\n    wheel_friction_slip(i) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawdynamicraycastvehiclecontroller_wheel_friction_slip(retptr, this.__wbg_ptr, i);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} i\n    * @param {number} value\n    */\n    set_wheel_friction_slip(i, value) {\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_friction_slip(this.__wbg_ptr, i, value);\n    }\n    /**\n    * @param {number} i\n    * @returns {number | undefined}\n    */\n    wheel_rotation(i) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawdynamicraycastvehiclecontroller_wheel_rotation(retptr, this.__wbg_ptr, i);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} i\n    * @returns {number | undefined}\n    */\n    wheel_forward_impulse(i) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawdynamicraycastvehiclecontroller_wheel_forward_impulse(retptr, this.__wbg_ptr, i);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} i\n    * @returns {number | undefined}\n    */\n    wheel_side_impulse(i) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawdynamicraycastvehiclecontroller_wheel_side_impulse(retptr, this.__wbg_ptr, i);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} i\n    * @returns {number | undefined}\n    */\n    wheel_suspension_force(i) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawdynamicraycastvehiclecontroller_wheel_suspension_force(retptr, this.__wbg_ptr, i);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector | undefined}\n    */\n    wheel_contact_normal_ws(i) {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_wheel_contact_normal_ws(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector | undefined}\n    */\n    wheel_contact_point_ws(i) {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_wheel_contact_point_ws(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} i\n    * @returns {number | undefined}\n    */\n    wheel_suspension_length(i) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawdynamicraycastvehiclecontroller_wheel_suspension_length(retptr, this.__wbg_ptr, i);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector | undefined}\n    */\n    wheel_hard_point_ws(i) {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_wheel_hard_point_ws(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} i\n    * @returns {boolean}\n    */\n    wheel_is_in_contact(i) {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_wheel_is_in_contact(this.__wbg_ptr, i);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {number | undefined}\n    */\n    wheel_ground_object(i) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawdynamicraycastvehiclecontroller_wheel_ground_object(retptr, this.__wbg_ptr, i);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r2 = getFloat64Memory0()[retptr / 8 + 1];\n            return r0 === 0 ? undefined : r2;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* A structure responsible for collecting events generated\n* by the physics engine.\n*/\nexport class RawEventQueue {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawEventQueue.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_raweventqueue_free(ptr);\n    }\n    /**\n    * Creates a new event collector.\n    *\n    * # Parameters\n    * - `autoDrain`: setting this to `true` is strongly recommended. If true, the collector will\n    * be automatically drained before each `world.step(collector)`. If false, the collector will\n    * keep all events in memory unless it is manually drained/cleared; this may lead to unbounded use of\n    * RAM if no drain is performed.\n    * @param {boolean} autoDrain\n    */\n    constructor(autoDrain) {\n        const ret = wasm.raweventqueue_new(autoDrain);\n        return RawEventQueue.__wrap(ret);\n    }\n    /**\n    * Applies the given javascript closure on each collision event of this collector, then clear\n    * the internal collision event buffer.\n    *\n    * # Parameters\n    * - `f(handle1, handle2, started)`:  JavaScript closure applied to each collision event. The\n    * closure should take three arguments: two integers representing the handles of the colliders\n    * involved in the collision, and a boolean indicating if the collision started (true) or stopped\n    * (false).\n    * @param {Function} f\n    */\n    drainCollisionEvents(f) {\n        try {\n            wasm.raweventqueue_drainCollisionEvents(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {Function} f\n    */\n    drainContactForceEvents(f) {\n        try {\n            wasm.raweventqueue_drainContactForceEvents(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Removes all events contained by this collector.\n    */\n    clear() {\n        wasm.raweventqueue_clear(this.__wbg_ptr);\n    }\n}\n/**\n*/\nexport class RawGenericJoint {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawGenericJoint.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawgenericjoint_free(ptr);\n    }\n    /**\n    * Creates a new joint descriptor that builds generic joints.\n    *\n    * Generic joints allow arbitrary axes of freedom to be selected\n    * for the joint from the available 6 degrees of freedom.\n    * @param {RawVector} anchor1\n    * @param {RawVector} anchor2\n    * @param {RawVector} axis\n    * @param {number} lockedAxes\n    * @returns {RawGenericJoint | undefined}\n    */\n    static generic(anchor1, anchor2, axis, lockedAxes) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(anchor2, RawVector);\n        _assertClass(axis, RawVector);\n        const ret = wasm.rawgenericjoint_generic(anchor1.__wbg_ptr, anchor2.__wbg_ptr, axis.__wbg_ptr, lockedAxes);\n        return ret === 0 ? undefined : RawGenericJoint.__wrap(ret);\n    }\n    /**\n    * Create a new joint descriptor that builds spehrical joints.\n    *\n    * A spherical joints allows three relative rotational degrees of freedom\n    * by preventing any relative translation between the anchors of the\n    * two attached rigid-bodies.\n    * @param {RawVector} anchor1\n    * @param {RawVector} anchor2\n    * @returns {RawGenericJoint}\n    */\n    static spherical(anchor1, anchor2) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(anchor2, RawVector);\n        const ret = wasm.rawgenericjoint_spherical(anchor1.__wbg_ptr, anchor2.__wbg_ptr);\n        return RawGenericJoint.__wrap(ret);\n    }\n    /**\n    * Creates a new joint descriptor that builds a Prismatic joint.\n    *\n    * A prismatic joint removes all the degrees of freedom between the\n    * affected bodies, except for the translation along one axis.\n    *\n    * Returns `None` if any of the provided axes cannot be normalized.\n    * @param {RawVector} anchor1\n    * @param {RawVector} anchor2\n    * @param {RawVector} axis\n    * @param {boolean} limitsEnabled\n    * @param {number} limitsMin\n    * @param {number} limitsMax\n    * @returns {RawGenericJoint | undefined}\n    */\n    static prismatic(anchor1, anchor2, axis, limitsEnabled, limitsMin, limitsMax) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(anchor2, RawVector);\n        _assertClass(axis, RawVector);\n        const ret = wasm.rawgenericjoint_prismatic(anchor1.__wbg_ptr, anchor2.__wbg_ptr, axis.__wbg_ptr, limitsEnabled, limitsMin, limitsMax);\n        return ret === 0 ? undefined : RawGenericJoint.__wrap(ret);\n    }\n    /**\n    * Creates a new joint descriptor that builds a Fixed joint.\n    *\n    * A fixed joint removes all the degrees of freedom between the affected bodies.\n    * @param {RawVector} anchor1\n    * @param {RawRotation} axes1\n    * @param {RawVector} anchor2\n    * @param {RawRotation} axes2\n    * @returns {RawGenericJoint}\n    */\n    static fixed(anchor1, axes1, anchor2, axes2) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(axes1, RawRotation);\n        _assertClass(anchor2, RawVector);\n        _assertClass(axes2, RawRotation);\n        const ret = wasm.rawgenericjoint_fixed(anchor1.__wbg_ptr, axes1.__wbg_ptr, anchor2.__wbg_ptr, axes2.__wbg_ptr);\n        return RawGenericJoint.__wrap(ret);\n    }\n    /**\n    * Create a new joint descriptor that builds Revolute joints.\n    *\n    * A revolute joint removes all degrees of freedom between the affected\n    * bodies except for the rotation along one axis.\n    * @param {RawVector} anchor1\n    * @param {RawVector} anchor2\n    * @param {RawVector} axis\n    * @returns {RawGenericJoint | undefined}\n    */\n    static revolute(anchor1, anchor2, axis) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(anchor2, RawVector);\n        _assertClass(axis, RawVector);\n        const ret = wasm.rawgenericjoint_revolute(anchor1.__wbg_ptr, anchor2.__wbg_ptr, axis.__wbg_ptr);\n        return ret === 0 ? undefined : RawGenericJoint.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawImpulseJointSet {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawImpulseJointSet.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawimpulsejointset_free(ptr);\n    }\n    /**\n    * The type of this joint.\n    * @param {number} handle\n    * @returns {number}\n    */\n    jointType(handle) {\n        const ret = wasm.rawimpulsejointset_jointType(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * The unique integer identifier of the first rigid-body this joint it attached to.\n    * @param {number} handle\n    * @returns {number}\n    */\n    jointBodyHandle1(handle) {\n        const ret = wasm.rawimpulsejointset_jointBodyHandle1(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The unique integer identifier of the second rigid-body this joint is attached to.\n    * @param {number} handle\n    * @returns {number}\n    */\n    jointBodyHandle2(handle) {\n        const ret = wasm.rawimpulsejointset_jointBodyHandle2(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The angular part of the joint\u2019s local frame relative to the first rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    jointFrameX1(handle) {\n        const ret = wasm.rawimpulsejointset_jointFrameX1(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The angular part of the joint\u2019s local frame relative to the second rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    jointFrameX2(handle) {\n        const ret = wasm.rawimpulsejointset_jointFrameX2(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The position of the first anchor of this joint.\n    *\n    * The first anchor gives the position of the points application point on the\n    * local frame of the first rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    jointAnchor1(handle) {\n        const ret = wasm.rawimpulsejointset_jointAnchor1(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The position of the second anchor of this joint.\n    *\n    * The second anchor gives the position of the points application point on the\n    * local frame of the second rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    jointAnchor2(handle) {\n        const ret = wasm.rawimpulsejointset_jointAnchor2(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Sets the position of the first local anchor\n    * @param {number} handle\n    * @param {RawVector} newPos\n    */\n    jointSetAnchor1(handle, newPos) {\n        _assertClass(newPos, RawVector);\n        wasm.rawimpulsejointset_jointSetAnchor1(this.__wbg_ptr, handle, newPos.__wbg_ptr);\n    }\n    /**\n    * Sets the position of the second local anchor\n    * @param {number} handle\n    * @param {RawVector} newPos\n    */\n    jointSetAnchor2(handle, newPos) {\n        _assertClass(newPos, RawVector);\n        wasm.rawimpulsejointset_jointSetAnchor2(this.__wbg_ptr, handle, newPos.__wbg_ptr);\n    }\n    /**\n    * Are contacts between the rigid-bodies attached by this joint enabled?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    jointContactsEnabled(handle) {\n        const ret = wasm.rawimpulsejointset_jointContactsEnabled(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Sets whether contacts are enabled between the rigid-bodies attached by this joint.\n    * @param {number} handle\n    * @param {boolean} enabled\n    */\n    jointSetContactsEnabled(handle, enabled) {\n        wasm.rawimpulsejointset_jointSetContactsEnabled(this.__wbg_ptr, handle, enabled);\n    }\n    /**\n    * Are the limits for this joint enabled?\n    * @param {number} handle\n    * @param {number} axis\n    * @returns {boolean}\n    */\n    jointLimitsEnabled(handle, axis) {\n        const ret = wasm.rawimpulsejointset_jointLimitsEnabled(this.__wbg_ptr, handle, axis);\n        return ret !== 0;\n    }\n    /**\n    * Return the lower limit along the given joint axis.\n    * @param {number} handle\n    * @param {number} axis\n    * @returns {number}\n    */\n    jointLimitsMin(handle, axis) {\n        const ret = wasm.rawimpulsejointset_jointLimitsMin(this.__wbg_ptr, handle, axis);\n        return ret;\n    }\n    /**\n    * If this is a prismatic joint, returns its upper limit.\n    * @param {number} handle\n    * @param {number} axis\n    * @returns {number}\n    */\n    jointLimitsMax(handle, axis) {\n        const ret = wasm.rawimpulsejointset_jointLimitsMax(this.__wbg_ptr, handle, axis);\n        return ret;\n    }\n    /**\n    * Enables and sets the joint limits\n    * @param {number} handle\n    * @param {number} axis\n    * @param {number} min\n    * @param {number} max\n    */\n    jointSetLimits(handle, axis, min, max) {\n        wasm.rawimpulsejointset_jointSetLimits(this.__wbg_ptr, handle, axis, min, max);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} axis\n    * @param {number} model\n    */\n    jointConfigureMotorModel(handle, axis, model) {\n        wasm.rawimpulsejointset_jointConfigureMotorModel(this.__wbg_ptr, handle, axis, model);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} axis\n    * @param {number} targetVel\n    * @param {number} factor\n    */\n    jointConfigureMotorVelocity(handle, axis, targetVel, factor) {\n        wasm.rawimpulsejointset_jointConfigureMotorVelocity(this.__wbg_ptr, handle, axis, targetVel, factor);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} axis\n    * @param {number} targetPos\n    * @param {number} stiffness\n    * @param {number} damping\n    */\n    jointConfigureMotorPosition(handle, axis, targetPos, stiffness, damping) {\n        wasm.rawimpulsejointset_jointConfigureMotorPosition(this.__wbg_ptr, handle, axis, targetPos, stiffness, damping);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} axis\n    * @param {number} targetPos\n    * @param {number} targetVel\n    * @param {number} stiffness\n    * @param {number} damping\n    */\n    jointConfigureMotor(handle, axis, targetPos, targetVel, stiffness, damping) {\n        wasm.rawimpulsejointset_jointConfigureMotor(this.__wbg_ptr, handle, axis, targetPos, targetVel, stiffness, damping);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawimpulsejointset_new();\n        return RawImpulseJointSet.__wrap(ret);\n    }\n    /**\n    * @param {RawGenericJoint} params\n    * @param {number} parent1\n    * @param {number} parent2\n    * @param {boolean} wake_up\n    * @returns {number}\n    */\n    createJoint(params, parent1, parent2, wake_up) {\n        _assertClass(params, RawGenericJoint);\n        const ret = wasm.rawimpulsejointset_createJoint(this.__wbg_ptr, params.__wbg_ptr, parent1, parent2, wake_up);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} wakeUp\n    */\n    remove(handle, wakeUp) {\n        wasm.rawimpulsejointset_remove(this.__wbg_ptr, handle, wakeUp);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.rawimpulsejointset_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    contains(handle) {\n        const ret = wasm.rawimpulsejointset_contains(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each joint managed by this physics world.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each joint managed by this set. Called as `f(collider)`.\n    * @param {Function} f\n    */\n    forEachJointHandle(f) {\n        try {\n            wasm.rawimpulsejointset_forEachJointHandle(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each joint attached to the given rigid-body.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each joint attached to the rigid-body. Called as `f(collider)`.\n    * @param {number} body\n    * @param {Function} f\n    */\n    forEachJointAttachedToRigidBody(body, f) {\n        try {\n            wasm.rawimpulsejointset_forEachJointAttachedToRigidBody(this.__wbg_ptr, body, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n/**\n*/\nexport class RawIntegrationParameters {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawIntegrationParameters.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawintegrationparameters_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawintegrationparameters_new();\n        return RawIntegrationParameters.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    get dt() {\n        const ret = wasm.rawintegrationparameters_dt(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    get erp() {\n        const ret = wasm.rawintegrationparameters_erp(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    get allowedLinearError() {\n        const ret = wasm.rawintegrationparameters_allowedLinearError(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    get predictionDistance() {\n        const ret = wasm.rawintegrationparameters_predictionDistance(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    get maxVelocityIterations() {\n        const ret = wasm.rawintegrationparameters_maxVelocityIterations(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    get maxVelocityFrictionIterations() {\n        const ret = wasm.rawintegrationparameters_maxVelocityFrictionIterations(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    get maxStabilizationIterations() {\n        const ret = wasm.rawintegrationparameters_maxStabilizationIterations(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    get minIslandSize() {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_index_up_axis(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    get maxCcdSubsteps() {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_index_forward_axis(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} value\n    */\n    set dt(value) {\n        wasm.rawintegrationparameters_set_dt(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set erp(value) {\n        wasm.rawintegrationparameters_set_erp(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set allowedLinearError(value) {\n        wasm.rawintegrationparameters_set_allowedLinearError(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set predictionDistance(value) {\n        wasm.rawintegrationparameters_set_predictionDistance(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set maxVelocityIterations(value) {\n        wasm.rawintegrationparameters_set_maxVelocityIterations(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set maxVelocityFrictionIterations(value) {\n        wasm.rawintegrationparameters_set_maxVelocityFrictionIterations(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set maxStabilizationIterations(value) {\n        wasm.rawintegrationparameters_set_maxStabilizationIterations(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set minIslandSize(value) {\n        wasm.rawdynamicraycastvehiclecontroller_set_index_up_axis(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set maxCcdSubsteps(value) {\n        wasm.rawdynamicraycastvehiclecontroller_set_index_forward_axis(this.__wbg_ptr, value);\n    }\n}\n/**\n*/\nexport class RawIslandManager {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawIslandManager.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawislandmanager_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawislandmanager_new();\n        return RawIslandManager.__wrap(ret);\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each active rigid-body\n    * managed by this island manager.\n    *\n    * After a short time of inactivity, a rigid-body is automatically deactivated (\"asleep\") by\n    * the physics engine in order to save computational power. A sleeping rigid-body never moves\n    * unless it is moved manually by the user.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each active rigid-body managed by this\n    *   set. Called as `f(collider)`.\n    * @param {Function} f\n    */\n    forEachActiveRigidBodyHandle(f) {\n        try {\n            wasm.rawislandmanager_forEachActiveRigidBodyHandle(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n/**\n*/\nexport class RawKinematicCharacterController {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawKinematicCharacterController.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawkinematiccharactercontroller_free(ptr);\n    }\n    /**\n    * @param {number} offset\n    */\n    constructor(offset) {\n        const ret = wasm.rawkinematiccharactercontroller_new(offset);\n        return RawKinematicCharacterController.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    up() {\n        const ret = wasm.rawcharactercollision_translationDeltaApplied(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} vector\n    */\n    setUp(vector) {\n        _assertClass(vector, RawVector);\n        wasm.rawkinematiccharactercontroller_setUp(this.__wbg_ptr, vector.__wbg_ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    offset() {\n        const ret = wasm.rawkinematiccharactercontroller_offset(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @param {number} value\n    */\n    setOffset(value) {\n        wasm.rawkinematiccharactercontroller_setOffset(this.__wbg_ptr, value);\n    }\n    /**\n    * @returns {boolean}\n    */\n    slideEnabled() {\n        const ret = wasm.rawkinematiccharactercontroller_slideEnabled(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {boolean} enabled\n    */\n    setSlideEnabled(enabled) {\n        wasm.rawkinematiccharactercontroller_setSlideEnabled(this.__wbg_ptr, enabled);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    autostepMaxHeight() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawkinematiccharactercontroller_autostepMaxHeight(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    autostepMinWidth() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawkinematiccharactercontroller_autostepMinWidth(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {boolean | undefined}\n    */\n    autostepIncludesDynamicBodies() {\n        const ret = wasm.rawkinematiccharactercontroller_autostepIncludesDynamicBodies(this.__wbg_ptr);\n        return ret === 0xFFFFFF ? undefined : ret !== 0;\n    }\n    /**\n    * @returns {boolean}\n    */\n    autostepEnabled() {\n        const ret = wasm.rawkinematiccharactercontroller_autostepEnabled(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} maxHeight\n    * @param {number} minWidth\n    * @param {boolean} includeDynamicBodies\n    */\n    enableAutostep(maxHeight, minWidth, includeDynamicBodies) {\n        wasm.rawkinematiccharactercontroller_enableAutostep(this.__wbg_ptr, maxHeight, minWidth, includeDynamicBodies);\n    }\n    /**\n    */\n    disableAutostep() {\n        wasm.rawkinematiccharactercontroller_disableAutostep(this.__wbg_ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    maxSlopeClimbAngle() {\n        const ret = wasm.rawkinematiccharactercontroller_maxSlopeClimbAngle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @param {number} angle\n    */\n    setMaxSlopeClimbAngle(angle) {\n        wasm.rawkinematiccharactercontroller_setMaxSlopeClimbAngle(this.__wbg_ptr, angle);\n    }\n    /**\n    * @returns {number}\n    */\n    minSlopeSlideAngle() {\n        const ret = wasm.rawkinematiccharactercontroller_minSlopeSlideAngle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @param {number} angle\n    */\n    setMinSlopeSlideAngle(angle) {\n        wasm.rawkinematiccharactercontroller_setMinSlopeSlideAngle(this.__wbg_ptr, angle);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    snapToGroundDistance() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawkinematiccharactercontroller_snapToGroundDistance(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} distance\n    */\n    enableSnapToGround(distance) {\n        wasm.rawkinematiccharactercontroller_enableSnapToGround(this.__wbg_ptr, distance);\n    }\n    /**\n    */\n    disableSnapToGround() {\n        wasm.rawkinematiccharactercontroller_disableSnapToGround(this.__wbg_ptr);\n    }\n    /**\n    * @returns {boolean}\n    */\n    snapToGroundEnabled() {\n        const ret = wasm.rawkinematiccharactercontroller_snapToGroundEnabled(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} dt\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawQueryPipeline} queries\n    * @param {number} collider_handle\n    * @param {RawVector} desired_translation_delta\n    * @param {boolean} apply_impulses_to_dynamic_bodies\n    * @param {number | undefined} character_mass\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {Function} filter_predicate\n    */\n    computeColliderMovement(dt, bodies, colliders, queries, collider_handle, desired_translation_delta, apply_impulses_to_dynamic_bodies, character_mass, filter_flags, filter_groups, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(queries, RawQueryPipeline);\n            _assertClass(desired_translation_delta, RawVector);\n            wasm.rawkinematiccharactercontroller_computeColliderMovement(this.__wbg_ptr, dt, bodies.__wbg_ptr, colliders.__wbg_ptr, queries.__wbg_ptr, collider_handle, desired_translation_delta.__wbg_ptr, apply_impulses_to_dynamic_bodies, !isLikeNone(character_mass), isLikeNone(character_mass) ? 0 : character_mass, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, addBorrowedObject(filter_predicate));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @returns {RawVector}\n    */\n    computedMovement() {\n        const ret = wasm.rawkinematiccharactercontroller_computedMovement(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    computedGrounded() {\n        const ret = wasm.rawkinematiccharactercontroller_computedGrounded(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {number}\n    */\n    numComputedCollisions() {\n        const ret = wasm.rawkinematiccharactercontroller_numComputedCollisions(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @param {RawCharacterCollision} collision\n    * @returns {boolean}\n    */\n    computedCollision(i, collision) {\n        _assertClass(collision, RawCharacterCollision);\n        const ret = wasm.rawkinematiccharactercontroller_computedCollision(this.__wbg_ptr, i, collision.__wbg_ptr);\n        return ret !== 0;\n    }\n}\n/**\n*/\nexport class RawMultibodyJointSet {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawMultibodyJointSet.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawmultibodyjointset_free(ptr);\n    }\n    /**\n    * The type of this joint.\n    * @param {number} handle\n    * @returns {number}\n    */\n    jointType(handle) {\n        const ret = wasm.rawmultibodyjointset_jointType(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * The angular part of the joint\u2019s local frame relative to the first rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    jointFrameX1(handle) {\n        const ret = wasm.rawmultibodyjointset_jointFrameX1(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The angular part of the joint\u2019s local frame relative to the second rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    jointFrameX2(handle) {\n        const ret = wasm.rawmultibodyjointset_jointFrameX2(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The position of the first anchor of this joint.\n    *\n    * The first anchor gives the position of the points application point on the\n    * local frame of the first rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    jointAnchor1(handle) {\n        const ret = wasm.rawmultibodyjointset_jointAnchor1(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The position of the second anchor of this joint.\n    *\n    * The second anchor gives the position of the points application point on the\n    * local frame of the second rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    jointAnchor2(handle) {\n        const ret = wasm.rawmultibodyjointset_jointAnchor2(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Are contacts between the rigid-bodies attached by this joint enabled?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    jointContactsEnabled(handle) {\n        const ret = wasm.rawmultibodyjointset_jointContactsEnabled(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Sets whether contacts are enabled between the rigid-bodies attached by this joint.\n    * @param {number} handle\n    * @param {boolean} enabled\n    */\n    jointSetContactsEnabled(handle, enabled) {\n        wasm.rawmultibodyjointset_jointSetContactsEnabled(this.__wbg_ptr, handle, enabled);\n    }\n    /**\n    * Are the limits for this joint enabled?\n    * @param {number} handle\n    * @param {number} axis\n    * @returns {boolean}\n    */\n    jointLimitsEnabled(handle, axis) {\n        const ret = wasm.rawmultibodyjointset_jointLimitsEnabled(this.__wbg_ptr, handle, axis);\n        return ret !== 0;\n    }\n    /**\n    * Return the lower limit along the given joint axis.\n    * @param {number} handle\n    * @param {number} axis\n    * @returns {number}\n    */\n    jointLimitsMin(handle, axis) {\n        const ret = wasm.rawmultibodyjointset_jointLimitsMin(this.__wbg_ptr, handle, axis);\n        return ret;\n    }\n    /**\n    * If this is a prismatic joint, returns its upper limit.\n    * @param {number} handle\n    * @param {number} axis\n    * @returns {number}\n    */\n    jointLimitsMax(handle, axis) {\n        const ret = wasm.rawmultibodyjointset_jointLimitsMax(this.__wbg_ptr, handle, axis);\n        return ret;\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawmultibodyjointset_new();\n        return RawMultibodyJointSet.__wrap(ret);\n    }\n    /**\n    * @param {RawGenericJoint} params\n    * @param {number} parent1\n    * @param {number} parent2\n    * @param {boolean} wakeUp\n    * @returns {number}\n    */\n    createJoint(params, parent1, parent2, wakeUp) {\n        _assertClass(params, RawGenericJoint);\n        const ret = wasm.rawmultibodyjointset_createJoint(this.__wbg_ptr, params.__wbg_ptr, parent1, parent2, wakeUp);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} wakeUp\n    */\n    remove(handle, wakeUp) {\n        wasm.rawmultibodyjointset_remove(this.__wbg_ptr, handle, wakeUp);\n    }\n    /**\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    contains(handle) {\n        const ret = wasm.rawmultibodyjointset_contains(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each joint managed by this physics world.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each joint managed by this set. Called as `f(collider)`.\n    * @param {Function} f\n    */\n    forEachJointHandle(f) {\n        try {\n            wasm.rawmultibodyjointset_forEachJointHandle(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each joint attached to the given rigid-body.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each joint attached to the rigid-body. Called as `f(collider)`.\n    * @param {number} body\n    * @param {Function} f\n    */\n    forEachJointAttachedToRigidBody(body, f) {\n        try {\n            wasm.rawmultibodyjointset_forEachJointAttachedToRigidBody(this.__wbg_ptr, body, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n/**\n*/\nexport class RawNarrowPhase {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawNarrowPhase.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawnarrowphase_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawnarrowphase_new();\n        return RawNarrowPhase.__wrap(ret);\n    }\n    /**\n    * @param {number} handle1\n    * @param {Function} f\n    */\n    contacts_with(handle1, f) {\n        wasm.rawnarrowphase_contacts_with(this.__wbg_ptr, handle1, addHeapObject(f));\n    }\n    /**\n    * @param {number} handle1\n    * @param {number} handle2\n    * @returns {RawContactPair | undefined}\n    */\n    contact_pair(handle1, handle2) {\n        const ret = wasm.rawnarrowphase_contact_pair(this.__wbg_ptr, handle1, handle2);\n        return ret === 0 ? undefined : RawContactPair.__wrap(ret);\n    }\n    /**\n    * @param {number} handle1\n    * @param {Function} f\n    */\n    intersections_with(handle1, f) {\n        wasm.rawnarrowphase_intersections_with(this.__wbg_ptr, handle1, addHeapObject(f));\n    }\n    /**\n    * @param {number} handle1\n    * @param {number} handle2\n    * @returns {boolean}\n    */\n    intersection_pair(handle1, handle2) {\n        const ret = wasm.rawnarrowphase_intersection_pair(this.__wbg_ptr, handle1, handle2);\n        return ret !== 0;\n    }\n}\n/**\n*/\nexport class RawPhysicsPipeline {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawPhysicsPipeline.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawphysicspipeline_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawphysicspipeline_new();\n        return RawPhysicsPipeline.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} gravity\n    * @param {RawIntegrationParameters} integrationParameters\n    * @param {RawIslandManager} islands\n    * @param {RawBroadPhase} broadPhase\n    * @param {RawNarrowPhase} narrowPhase\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawImpulseJointSet} joints\n    * @param {RawMultibodyJointSet} articulations\n    * @param {RawCCDSolver} ccd_solver\n    */\n    step(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, joints, articulations, ccd_solver) {\n        _assertClass(gravity, RawVector);\n        _assertClass(integrationParameters, RawIntegrationParameters);\n        _assertClass(islands, RawIslandManager);\n        _assertClass(broadPhase, RawBroadPhase);\n        _assertClass(narrowPhase, RawNarrowPhase);\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(joints, RawImpulseJointSet);\n        _assertClass(articulations, RawMultibodyJointSet);\n        _assertClass(ccd_solver, RawCCDSolver);\n        wasm.rawphysicspipeline_step(this.__wbg_ptr, gravity.__wbg_ptr, integrationParameters.__wbg_ptr, islands.__wbg_ptr, broadPhase.__wbg_ptr, narrowPhase.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, joints.__wbg_ptr, articulations.__wbg_ptr, ccd_solver.__wbg_ptr);\n    }\n    /**\n    * @param {RawVector} gravity\n    * @param {RawIntegrationParameters} integrationParameters\n    * @param {RawIslandManager} islands\n    * @param {RawBroadPhase} broadPhase\n    * @param {RawNarrowPhase} narrowPhase\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawImpulseJointSet} joints\n    * @param {RawMultibodyJointSet} articulations\n    * @param {RawCCDSolver} ccd_solver\n    * @param {RawEventQueue} eventQueue\n    * @param {object} hookObject\n    * @param {Function} hookFilterContactPair\n    * @param {Function} hookFilterIntersectionPair\n    */\n    stepWithEvents(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, joints, articulations, ccd_solver, eventQueue, hookObject, hookFilterContactPair, hookFilterIntersectionPair) {\n        _assertClass(gravity, RawVector);\n        _assertClass(integrationParameters, RawIntegrationParameters);\n        _assertClass(islands, RawIslandManager);\n        _assertClass(broadPhase, RawBroadPhase);\n        _assertClass(narrowPhase, RawNarrowPhase);\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(joints, RawImpulseJointSet);\n        _assertClass(articulations, RawMultibodyJointSet);\n        _assertClass(ccd_solver, RawCCDSolver);\n        _assertClass(eventQueue, RawEventQueue);\n        wasm.rawphysicspipeline_stepWithEvents(this.__wbg_ptr, gravity.__wbg_ptr, integrationParameters.__wbg_ptr, islands.__wbg_ptr, broadPhase.__wbg_ptr, narrowPhase.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, joints.__wbg_ptr, articulations.__wbg_ptr, ccd_solver.__wbg_ptr, eventQueue.__wbg_ptr, addHeapObject(hookObject), addHeapObject(hookFilterContactPair), addHeapObject(hookFilterIntersectionPair));\n    }\n}\n/**\n*/\nexport class RawPointColliderProjection {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawPointColliderProjection.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawpointcolliderprojection_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    colliderHandle() {\n        const ret = wasm.rawpointcolliderprojection_colliderHandle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    point() {\n        const ret = wasm.rawpointcolliderprojection_point(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    isInside() {\n        const ret = wasm.rawpointcolliderprojection_isInside(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {number}\n    */\n    featureType() {\n        const ret = wasm.rawpointcolliderprojection_featureType(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    featureId() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawpointcolliderprojection_featureId(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nexport class RawPointProjection {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawPointProjection.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawpointprojection_free(ptr);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    point() {\n        const ret = wasm.rawpointprojection_point(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    isInside() {\n        const ret = wasm.rawpointprojection_isInside(this.__wbg_ptr);\n        return ret !== 0;\n    }\n}\n/**\n*/\nexport class RawQueryPipeline {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawQueryPipeline.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawquerypipeline_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawquerypipeline_new();\n        return RawQueryPipeline.__wrap(ret);\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    */\n    update(bodies, colliders) {\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        wasm.rawquerypipeline_update(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr);\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {RawRayColliderToi | undefined}\n    */\n    castRay(bodies, colliders, rayOrig, rayDir, maxToi, solid, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(rayOrig, RawVector);\n            _assertClass(rayDir, RawVector);\n            const ret = wasm.rawquerypipeline_castRay(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawRayColliderToi.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {RawRayColliderIntersection | undefined}\n    */\n    castRayAndGetNormal(bodies, colliders, rayOrig, rayDir, maxToi, solid, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(rayOrig, RawVector);\n            _assertClass(rayDir, RawVector);\n            const ret = wasm.rawquerypipeline_castRayAndGetNormal(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawRayColliderIntersection.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @param {Function} callback\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    */\n    intersectionsWithRay(bodies, colliders, rayOrig, rayDir, maxToi, solid, callback, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(rayOrig, RawVector);\n            _assertClass(rayDir, RawVector);\n            wasm.rawquerypipeline_intersectionsWithRay(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid, addBorrowedObject(callback), filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawShape} shape\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {number | undefined}\n    */\n    intersectionWithShape(bodies, colliders, shapePos, shapeRot, shape, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(shapePos, RawVector);\n            _assertClass(shapeRot, RawRotation);\n            _assertClass(shape, RawShape);\n            wasm.rawquerypipeline_intersectionWithShape(retptr, this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, shape.__wbg_ptr, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r2 = getFloat64Memory0()[retptr / 8 + 1];\n            return r0 === 0 ? undefined : r2;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} point\n    * @param {boolean} solid\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {RawPointColliderProjection | undefined}\n    */\n    projectPoint(bodies, colliders, point, solid, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(point, RawVector);\n            const ret = wasm.rawquerypipeline_projectPoint(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, point.__wbg_ptr, solid, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawPointColliderProjection.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} point\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {RawPointColliderProjection | undefined}\n    */\n    projectPointAndGetFeature(bodies, colliders, point, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(point, RawVector);\n            const ret = wasm.rawquerypipeline_projectPointAndGetFeature(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, point.__wbg_ptr, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawPointColliderProjection.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} point\n    * @param {Function} callback\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    */\n    intersectionsWithPoint(bodies, colliders, point, callback, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(point, RawVector);\n            wasm.rawquerypipeline_intersectionsWithPoint(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, point.__wbg_ptr, addBorrowedObject(callback), filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} shapeVel\n    * @param {RawShape} shape\n    * @param {number} maxToi\n    * @param {boolean} stop_at_penetration\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {RawShapeColliderTOI | undefined}\n    */\n    castShape(bodies, colliders, shapePos, shapeRot, shapeVel, shape, maxToi, stop_at_penetration, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(shapePos, RawVector);\n            _assertClass(shapeRot, RawRotation);\n            _assertClass(shapeVel, RawVector);\n            _assertClass(shape, RawShape);\n            const ret = wasm.rawquerypipeline_castShape(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, shapeVel.__wbg_ptr, shape.__wbg_ptr, maxToi, stop_at_penetration, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawShapeColliderTOI.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawShape} shape\n    * @param {Function} callback\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    */\n    intersectionsWithShape(bodies, colliders, shapePos, shapeRot, shape, callback, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(shapePos, RawVector);\n            _assertClass(shapeRot, RawRotation);\n            _assertClass(shape, RawShape);\n            wasm.rawquerypipeline_intersectionsWithShape(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, shape.__wbg_ptr, addBorrowedObject(callback), filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawVector} aabbCenter\n    * @param {RawVector} aabbHalfExtents\n    * @param {Function} callback\n    */\n    collidersWithAabbIntersectingAabb(aabbCenter, aabbHalfExtents, callback) {\n        try {\n            _assertClass(aabbCenter, RawVector);\n            _assertClass(aabbHalfExtents, RawVector);\n            wasm.rawquerypipeline_collidersWithAabbIntersectingAabb(this.__wbg_ptr, aabbCenter.__wbg_ptr, aabbHalfExtents.__wbg_ptr, addBorrowedObject(callback));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n/**\n*/\nexport class RawRayColliderIntersection {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawRayColliderIntersection.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawraycolliderintersection_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    colliderHandle() {\n        const ret = wasm.rawpointcolliderprojection_colliderHandle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal() {\n        const ret = wasm.rawraycolliderintersection_normal(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    toi() {\n        const ret = wasm.rawintegrationparameters_erp(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    featureType() {\n        const ret = wasm.rawpointcolliderprojection_featureType(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    featureId() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawpointcolliderprojection_featureId(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nexport class RawRayColliderToi {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawRayColliderToi.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawraycollidertoi_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    colliderHandle() {\n        const ret = wasm.rawcharactercollision_handle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    toi() {\n        const ret = wasm.rawintegrationparameters_erp(this.__wbg_ptr);\n        return ret;\n    }\n}\n/**\n*/\nexport class RawRayIntersection {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawRayIntersection.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawrayintersection_free(ptr);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal() {\n        const ret = wasm.rawraycolliderintersection_normal(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    toi() {\n        const ret = wasm.rawintegrationparameters_erp(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    featureType() {\n        const ret = wasm.rawpointcolliderprojection_featureType(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    featureId() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawpointcolliderprojection_featureId(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nexport class RawRigidBodySet {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawRigidBodySet.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawrigidbodyset_free(ptr);\n    }\n    /**\n    * The world-space translation of this rigid-body.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbTranslation(handle) {\n        const ret = wasm.rawrigidbodyset_rbTranslation(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The world-space orientation of this rigid-body.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    rbRotation(handle) {\n        const ret = wasm.rawrigidbodyset_rbRotation(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * Put the given rigid-body to sleep.\n    * @param {number} handle\n    */\n    rbSleep(handle) {\n        wasm.rawrigidbodyset_rbSleep(this.__wbg_ptr, handle);\n    }\n    /**\n    * Is this rigid-body sleeping?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsSleeping(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsSleeping(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Is the velocity of this rigid-body not zero?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsMoving(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsMoving(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * The world-space predicted translation of this rigid-body.\n    *\n    * If this rigid-body is kinematic this value is set by the `setNextKinematicTranslation`\n    * method and is used for estimating the kinematic body velocity at the next timestep.\n    * For non-kinematic bodies, this value is currently unspecified.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbNextTranslation(handle) {\n        const ret = wasm.rawrigidbodyset_rbNextTranslation(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The world-space predicted orientation of this rigid-body.\n    *\n    * If this rigid-body is kinematic this value is set by the `setNextKinematicRotation`\n    * method and is used for estimating the kinematic body velocity at the next timestep.\n    * For non-kinematic bodies, this value is currently unspecified.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    rbNextRotation(handle) {\n        const ret = wasm.rawrigidbodyset_rbNextRotation(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * Sets the translation of this rigid-body.\n    *\n    * # Parameters\n    * - `x`: the world-space position of the rigid-body along the `x` axis.\n    * - `y`: the world-space position of the rigid-body along the `y` axis.\n    * - `z`: the world-space position of the rigid-body along the `z` axis.\n    * - `wakeUp`: forces the rigid-body to wake-up so it is properly affected by forces if it\n    * wasn't moving before modifying its position.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    * @param {boolean} wakeUp\n    */\n    rbSetTranslation(handle, x, y, z, wakeUp) {\n        wasm.rawrigidbodyset_rbSetTranslation(this.__wbg_ptr, handle, x, y, z, wakeUp);\n    }\n    /**\n    * Sets the rotation quaternion of this rigid-body.\n    *\n    * This does nothing if a zero quaternion is provided.\n    *\n    * # Parameters\n    * - `x`: the first vector component of the quaternion.\n    * - `y`: the second vector component of the quaternion.\n    * - `z`: the third vector component of the quaternion.\n    * - `w`: the scalar component of the quaternion.\n    * - `wakeUp`: forces the rigid-body to wake-up so it is properly affected by forces if it\n    * wasn't moving before modifying its position.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    * @param {number} w\n    * @param {boolean} wakeUp\n    */\n    rbSetRotation(handle, x, y, z, w, wakeUp) {\n        wasm.rawrigidbodyset_rbSetRotation(this.__wbg_ptr, handle, x, y, z, w, wakeUp);\n    }\n    /**\n    * Sets the linear velocity of this rigid-body.\n    * @param {number} handle\n    * @param {RawVector} linvel\n    * @param {boolean} wakeUp\n    */\n    rbSetLinvel(handle, linvel, wakeUp) {\n        _assertClass(linvel, RawVector);\n        wasm.rawrigidbodyset_rbSetLinvel(this.__wbg_ptr, handle, linvel.__wbg_ptr, wakeUp);\n    }\n    /**\n    * Sets the angular velocity of this rigid-body.\n    * @param {number} handle\n    * @param {RawVector} angvel\n    * @param {boolean} wakeUp\n    */\n    rbSetAngvel(handle, angvel, wakeUp) {\n        _assertClass(angvel, RawVector);\n        wasm.rawrigidbodyset_rbSetAngvel(this.__wbg_ptr, handle, angvel.__wbg_ptr, wakeUp);\n    }\n    /**\n    * If this rigid body is kinematic, sets its future translation after the next timestep integration.\n    *\n    * This should be used instead of `rigidBody.setTranslation` to make the dynamic object\n    * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n    * an artificial velocity for this rigid-body from its current position and its next kinematic\n    * position. This velocity will be used to compute forces on dynamic bodies interacting with\n    * this body.\n    *\n    * # Parameters\n    * - `x`: the world-space position of the rigid-body along the `x` axis.\n    * - `y`: the world-space position of the rigid-body along the `y` axis.\n    * - `z`: the world-space position of the rigid-body along the `z` axis.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    */\n    rbSetNextKinematicTranslation(handle, x, y, z) {\n        wasm.rawrigidbodyset_rbSetNextKinematicTranslation(this.__wbg_ptr, handle, x, y, z);\n    }\n    /**\n    * If this rigid body is kinematic, sets its future rotation after the next timestep integration.\n    *\n    * This should be used instead of `rigidBody.setRotation` to make the dynamic object\n    * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n    * an artificial velocity for this rigid-body from its current position and its next kinematic\n    * position. This velocity will be used to compute forces on dynamic bodies interacting with\n    * this body.\n    *\n    * # Parameters\n    * - `x`: the first vector component of the quaternion.\n    * - `y`: the second vector component of the quaternion.\n    * - `z`: the third vector component of the quaternion.\n    * - `w`: the scalar component of the quaternion.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    * @param {number} w\n    */\n    rbSetNextKinematicRotation(handle, x, y, z, w) {\n        wasm.rawrigidbodyset_rbSetNextKinematicRotation(this.__wbg_ptr, handle, x, y, z, w);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawColliderSet} colliders\n    */\n    rbRecomputeMassPropertiesFromColliders(handle, colliders) {\n        _assertClass(colliders, RawColliderSet);\n        wasm.rawrigidbodyset_rbRecomputeMassPropertiesFromColliders(this.__wbg_ptr, handle, colliders.__wbg_ptr);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} mass\n    * @param {boolean} wake_up\n    */\n    rbSetAdditionalMass(handle, mass, wake_up) {\n        wasm.rawrigidbodyset_rbSetAdditionalMass(this.__wbg_ptr, handle, mass, wake_up);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} mass\n    * @param {RawVector} centerOfMass\n    * @param {RawVector} principalAngularInertia\n    * @param {RawRotation} angularInertiaFrame\n    * @param {boolean} wake_up\n    */\n    rbSetAdditionalMassProperties(handle, mass, centerOfMass, principalAngularInertia, angularInertiaFrame, wake_up) {\n        _assertClass(centerOfMass, RawVector);\n        _assertClass(principalAngularInertia, RawVector);\n        _assertClass(angularInertiaFrame, RawRotation);\n        wasm.rawrigidbodyset_rbSetAdditionalMassProperties(this.__wbg_ptr, handle, mass, centerOfMass.__wbg_ptr, principalAngularInertia.__wbg_ptr, angularInertiaFrame.__wbg_ptr, wake_up);\n    }\n    /**\n    * The linear velocity of this rigid-body.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbLinvel(handle) {\n        const ret = wasm.rawrigidbodyset_rbLinvel(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The angular velocity of this rigid-body.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbAngvel(handle) {\n        const ret = wasm.rawrigidbodyset_rbAngvel(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} locked\n    * @param {boolean} wake_up\n    */\n    rbLockTranslations(handle, locked, wake_up) {\n        wasm.rawrigidbodyset_rbLockTranslations(this.__wbg_ptr, handle, locked, wake_up);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} allow_x\n    * @param {boolean} allow_y\n    * @param {boolean} allow_z\n    * @param {boolean} wake_up\n    */\n    rbSetEnabledTranslations(handle, allow_x, allow_y, allow_z, wake_up) {\n        wasm.rawrigidbodyset_rbSetEnabledTranslations(this.__wbg_ptr, handle, allow_x, allow_y, allow_z, wake_up);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} locked\n    * @param {boolean} wake_up\n    */\n    rbLockRotations(handle, locked, wake_up) {\n        wasm.rawrigidbodyset_rbLockRotations(this.__wbg_ptr, handle, locked, wake_up);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} allow_x\n    * @param {boolean} allow_y\n    * @param {boolean} allow_z\n    * @param {boolean} wake_up\n    */\n    rbSetEnabledRotations(handle, allow_x, allow_y, allow_z, wake_up) {\n        wasm.rawrigidbodyset_rbSetEnabledRotations(this.__wbg_ptr, handle, allow_x, allow_y, allow_z, wake_up);\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbDominanceGroup(handle) {\n        const ret = wasm.rawrigidbodyset_rbDominanceGroup(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} group\n    */\n    rbSetDominanceGroup(handle, group) {\n        wasm.rawrigidbodyset_rbSetDominanceGroup(this.__wbg_ptr, handle, group);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} enabled\n    */\n    rbEnableCcd(handle, enabled) {\n        wasm.rawrigidbodyset_rbEnableCcd(this.__wbg_ptr, handle, enabled);\n    }\n    /**\n    * The mass of this rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbMass(handle) {\n        const ret = wasm.rawrigidbodyset_rbMass(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The inverse of the mass of a rigid-body.\n    *\n    * If this is zero, the rigid-body is assumed to have infinite mass.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbInvMass(handle) {\n        const ret = wasm.rawrigidbodyset_rbInvMass(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The inverse mass taking into account translation locking.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbEffectiveInvMass(handle) {\n        const ret = wasm.rawrigidbodyset_rbEffectiveInvMass(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The center of mass of a rigid-body expressed in its local-space.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbLocalCom(handle) {\n        const ret = wasm.rawrigidbodyset_rbLocalCom(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The world-space center of mass of the rigid-body.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbWorldCom(handle) {\n        const ret = wasm.rawrigidbodyset_rbWorldCom(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The inverse of the principal angular inertia of the rigid-body.\n    *\n    * Components set to zero are assumed to be infinite along the corresponding principal axis.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbInvPrincipalInertiaSqrt(handle) {\n        const ret = wasm.rawrigidbodyset_rbInvPrincipalInertiaSqrt(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The principal vectors of the local angular inertia tensor of the rigid-body.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    rbPrincipalInertiaLocalFrame(handle) {\n        const ret = wasm.rawrigidbodyset_rbPrincipalInertiaLocalFrame(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The angular inertia along the principal inertia axes of the rigid-body.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbPrincipalInertia(handle) {\n        const ret = wasm.rawrigidbodyset_rbPrincipalInertia(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The square-root of the world-space inverse angular inertia tensor of the rigid-body,\n    * taking into account rotation locking.\n    * @param {number} handle\n    * @returns {RawSdpMatrix3}\n    */\n    rbEffectiveWorldInvInertiaSqrt(handle) {\n        const ret = wasm.rawrigidbodyset_rbEffectiveWorldInvInertiaSqrt(this.__wbg_ptr, handle);\n        return RawSdpMatrix3.__wrap(ret);\n    }\n    /**\n    * The effective world-space angular inertia (that takes the potential rotation locking into account) of\n    * this rigid-body.\n    * @param {number} handle\n    * @returns {RawSdpMatrix3}\n    */\n    rbEffectiveAngularInertia(handle) {\n        const ret = wasm.rawrigidbodyset_rbEffectiveAngularInertia(this.__wbg_ptr, handle);\n        return RawSdpMatrix3.__wrap(ret);\n    }\n    /**\n    * Wakes this rigid-body up.\n    *\n    * A dynamic rigid-body that does not move during several consecutive frames will\n    * be put to sleep by the physics engine, i.e., it will stop being simulated in order\n    * to avoid useless computations.\n    * This methods forces a sleeping rigid-body to wake-up. This is useful, e.g., before modifying\n    * the position of a dynamic body so that it is properly simulated afterwards.\n    * @param {number} handle\n    */\n    rbWakeUp(handle) {\n        wasm.rawrigidbodyset_rbWakeUp(this.__wbg_ptr, handle);\n    }\n    /**\n    * Is Continuous Collision Detection enabled for this rigid-body?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsCcdEnabled(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsCcdEnabled(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * The number of colliders attached to this rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbNumColliders(handle) {\n        const ret = wasm.rawrigidbodyset_rbNumColliders(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * Retrieves the `i-th` collider attached to this rigid-body.\n    *\n    * # Parameters\n    * - `at`: The index of the collider to retrieve. Must be a number in `[0, this.numColliders()[`.\n    *         This index is **not** the same as the unique identifier of the collider.\n    * @param {number} handle\n    * @param {number} at\n    * @returns {number}\n    */\n    rbCollider(handle, at) {\n        const ret = wasm.rawrigidbodyset_rbCollider(this.__wbg_ptr, handle, at);\n        return ret;\n    }\n    /**\n    * The status of this rigid-body: fixed, dynamic, or kinematic.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbBodyType(handle) {\n        const ret = wasm.rawrigidbodyset_rbBodyType(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * Set a new status for this rigid-body: fixed, dynamic, or kinematic.\n    * @param {number} handle\n    * @param {number} status\n    * @param {boolean} wake_up\n    */\n    rbSetBodyType(handle, status, wake_up) {\n        wasm.rawrigidbodyset_rbSetBodyType(this.__wbg_ptr, handle, status, wake_up);\n    }\n    /**\n    * Is this rigid-body fixed?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsFixed(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsFixed(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Is this rigid-body kinematic?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsKinematic(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsKinematic(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Is this rigid-body dynamic?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsDynamic(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsDynamic(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * The linear damping coefficient of this rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbLinearDamping(handle) {\n        const ret = wasm.rawrigidbodyset_rbLinearDamping(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The angular damping coefficient of this rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbAngularDamping(handle) {\n        const ret = wasm.rawrigidbodyset_rbAngularDamping(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} factor\n    */\n    rbSetLinearDamping(handle, factor) {\n        wasm.rawrigidbodyset_rbSetLinearDamping(this.__wbg_ptr, handle, factor);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} factor\n    */\n    rbSetAngularDamping(handle, factor) {\n        wasm.rawrigidbodyset_rbSetAngularDamping(this.__wbg_ptr, handle, factor);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} enabled\n    */\n    rbSetEnabled(handle, enabled) {\n        wasm.rawrigidbodyset_rbSetEnabled(this.__wbg_ptr, handle, enabled);\n    }\n    /**\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsEnabled(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsEnabled(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbGravityScale(handle) {\n        const ret = wasm.rawrigidbodyset_rbGravityScale(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} factor\n    * @param {boolean} wakeUp\n    */\n    rbSetGravityScale(handle, factor, wakeUp) {\n        wasm.rawrigidbodyset_rbSetGravityScale(this.__wbg_ptr, handle, factor, wakeUp);\n    }\n    /**\n    * Resets to zero all user-added forces added to this rigid-body.\n    * @param {number} handle\n    * @param {boolean} wakeUp\n    */\n    rbResetForces(handle, wakeUp) {\n        wasm.rawrigidbodyset_rbResetForces(this.__wbg_ptr, handle, wakeUp);\n    }\n    /**\n    * Resets to zero all user-added torques added to this rigid-body.\n    * @param {number} handle\n    * @param {boolean} wakeUp\n    */\n    rbResetTorques(handle, wakeUp) {\n        wasm.rawrigidbodyset_rbResetTorques(this.__wbg_ptr, handle, wakeUp);\n    }\n    /**\n    * Adds a force at the center-of-mass of this rigid-body.\n    *\n    * # Parameters\n    * - `force`: the world-space force to apply on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} force\n    * @param {boolean} wakeUp\n    */\n    rbAddForce(handle, force, wakeUp) {\n        _assertClass(force, RawVector);\n        wasm.rawrigidbodyset_rbAddForce(this.__wbg_ptr, handle, force.__wbg_ptr, wakeUp);\n    }\n    /**\n    * Applies an impulse at the center-of-mass of this rigid-body.\n    *\n    * # Parameters\n    * - `impulse`: the world-space impulse to apply on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} impulse\n    * @param {boolean} wakeUp\n    */\n    rbApplyImpulse(handle, impulse, wakeUp) {\n        _assertClass(impulse, RawVector);\n        wasm.rawrigidbodyset_rbApplyImpulse(this.__wbg_ptr, handle, impulse.__wbg_ptr, wakeUp);\n    }\n    /**\n    * Adds a torque at the center-of-mass of this rigid-body.\n    *\n    * # Parameters\n    * - `torque`: the world-space torque to apply on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} torque\n    * @param {boolean} wakeUp\n    */\n    rbAddTorque(handle, torque, wakeUp) {\n        _assertClass(torque, RawVector);\n        wasm.rawrigidbodyset_rbAddTorque(this.__wbg_ptr, handle, torque.__wbg_ptr, wakeUp);\n    }\n    /**\n    * Applies an impulsive torque at the center-of-mass of this rigid-body.\n    *\n    * # Parameters\n    * - `torque impulse`: the world-space torque impulse to apply on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} torque_impulse\n    * @param {boolean} wakeUp\n    */\n    rbApplyTorqueImpulse(handle, torque_impulse, wakeUp) {\n        _assertClass(torque_impulse, RawVector);\n        wasm.rawrigidbodyset_rbApplyTorqueImpulse(this.__wbg_ptr, handle, torque_impulse.__wbg_ptr, wakeUp);\n    }\n    /**\n    * Adds a force at the given world-space point of this rigid-body.\n    *\n    * # Parameters\n    * - `force`: the world-space force to apply on the rigid-body.\n    * - `point`: the world-space point where the impulse is to be applied on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} force\n    * @param {RawVector} point\n    * @param {boolean} wakeUp\n    */\n    rbAddForceAtPoint(handle, force, point, wakeUp) {\n        _assertClass(force, RawVector);\n        _assertClass(point, RawVector);\n        wasm.rawrigidbodyset_rbAddForceAtPoint(this.__wbg_ptr, handle, force.__wbg_ptr, point.__wbg_ptr, wakeUp);\n    }\n    /**\n    * Applies an impulse at the given world-space point of this rigid-body.\n    *\n    * # Parameters\n    * - `impulse`: the world-space impulse to apply on the rigid-body.\n    * - `point`: the world-space point where the impulse is to be applied on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} impulse\n    * @param {RawVector} point\n    * @param {boolean} wakeUp\n    */\n    rbApplyImpulseAtPoint(handle, impulse, point, wakeUp) {\n        _assertClass(impulse, RawVector);\n        _assertClass(point, RawVector);\n        wasm.rawrigidbodyset_rbApplyImpulseAtPoint(this.__wbg_ptr, handle, impulse.__wbg_ptr, point.__wbg_ptr, wakeUp);\n    }\n    /**\n    * An arbitrary user-defined 32-bit integer\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbUserData(handle) {\n        const ret = wasm.rawrigidbodyset_rbUserData(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * Sets the user-defined 32-bit integer of this rigid-body.\n    *\n    * # Parameters\n    * - `data`: an arbitrary user-defined 32-bit integer.\n    * @param {number} handle\n    * @param {number} data\n    */\n    rbSetUserData(handle, data) {\n        wasm.rawrigidbodyset_rbSetUserData(this.__wbg_ptr, handle, data);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawrigidbodyset_new();\n        return RawRigidBodySet.__wrap(ret);\n    }\n    /**\n    * @param {boolean} enabled\n    * @param {RawVector} translation\n    * @param {RawRotation} rotation\n    * @param {number} gravityScale\n    * @param {number} mass\n    * @param {boolean} massOnly\n    * @param {RawVector} centerOfMass\n    * @param {RawVector} linvel\n    * @param {RawVector} angvel\n    * @param {RawVector} principalAngularInertia\n    * @param {RawRotation} angularInertiaFrame\n    * @param {boolean} translationEnabledX\n    * @param {boolean} translationEnabledY\n    * @param {boolean} translationEnabledZ\n    * @param {boolean} rotationEnabledX\n    * @param {boolean} rotationEnabledY\n    * @param {boolean} rotationEnabledZ\n    * @param {number} linearDamping\n    * @param {number} angularDamping\n    * @param {number} rb_type\n    * @param {boolean} canSleep\n    * @param {boolean} sleeping\n    * @param {boolean} ccdEnabled\n    * @param {number} dominanceGroup\n    * @returns {number}\n    */\n    createRigidBody(enabled, translation, rotation, gravityScale, mass, massOnly, centerOfMass, linvel, angvel, principalAngularInertia, angularInertiaFrame, translationEnabledX, translationEnabledY, translationEnabledZ, rotationEnabledX, rotationEnabledY, rotationEnabledZ, linearDamping, angularDamping, rb_type, canSleep, sleeping, ccdEnabled, dominanceGroup) {\n        _assertClass(translation, RawVector);\n        _assertClass(rotation, RawRotation);\n        _assertClass(centerOfMass, RawVector);\n        _assertClass(linvel, RawVector);\n        _assertClass(angvel, RawVector);\n        _assertClass(principalAngularInertia, RawVector);\n        _assertClass(angularInertiaFrame, RawRotation);\n        const ret = wasm.rawrigidbodyset_createRigidBody(this.__wbg_ptr, enabled, translation.__wbg_ptr, rotation.__wbg_ptr, gravityScale, mass, massOnly, centerOfMass.__wbg_ptr, linvel.__wbg_ptr, angvel.__wbg_ptr, principalAngularInertia.__wbg_ptr, angularInertiaFrame.__wbg_ptr, translationEnabledX, translationEnabledY, translationEnabledZ, rotationEnabledX, rotationEnabledY, rotationEnabledZ, linearDamping, angularDamping, rb_type, canSleep, sleeping, ccdEnabled, dominanceGroup);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawIslandManager} islands\n    * @param {RawColliderSet} colliders\n    * @param {RawImpulseJointSet} joints\n    * @param {RawMultibodyJointSet} articulations\n    */\n    remove(handle, islands, colliders, joints, articulations) {\n        _assertClass(islands, RawIslandManager);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(joints, RawImpulseJointSet);\n        _assertClass(articulations, RawMultibodyJointSet);\n        wasm.rawrigidbodyset_remove(this.__wbg_ptr, handle, islands.__wbg_ptr, colliders.__wbg_ptr, joints.__wbg_ptr, articulations.__wbg_ptr);\n    }\n    /**\n    * The number of rigid-bodies on this set.\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.rawcolliderset_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Checks if a rigid-body with the given integer handle exists.\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    contains(handle) {\n        const ret = wasm.rawrigidbodyset_contains(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each rigid-body managed by this set.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each rigid-body managed by this set. Called as `f(collider)`.\n    * @param {Function} f\n    */\n    forEachRigidBodyHandle(f) {\n        try {\n            wasm.rawrigidbodyset_forEachRigidBodyHandle(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawColliderSet} colliders\n    */\n    propagateModifiedBodyPositionsToColliders(colliders) {\n        _assertClass(colliders, RawColliderSet);\n        wasm.rawrigidbodyset_propagateModifiedBodyPositionsToColliders(this.__wbg_ptr, colliders.__wbg_ptr);\n    }\n}\n/**\n* A rotation quaternion.\n*/\nexport class RawRotation {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawRotation.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawrotation_free(ptr);\n    }\n    /**\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    * @param {number} w\n    */\n    constructor(x, y, z, w) {\n        const ret = wasm.rawrotation_new(x, y, z, w);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The identity quaternion.\n    * @returns {RawRotation}\n    */\n    static identity() {\n        const ret = wasm.rawrotation_identity();\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The `x` component of this quaternion.\n    * @returns {number}\n    */\n    get x() {\n        const ret = wasm.rawintegrationparameters_dt(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * The `y` component of this quaternion.\n    * @returns {number}\n    */\n    get y() {\n        const ret = wasm.rawkinematiccharactercontroller_offset(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * The `z` component of this quaternion.\n    * @returns {number}\n    */\n    get z() {\n        const ret = wasm.rawintegrationparameters_erp(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * The `w` component of this quaternion.\n    * @returns {number}\n    */\n    get w() {\n        const ret = wasm.rawrotation_w(this.__wbg_ptr);\n        return ret;\n    }\n}\n/**\n*/\nexport class RawSdpMatrix3 {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawSdpMatrix3.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawsdpmatrix3_free(ptr);\n    }\n    /**\n    * Row major list of the upper-triangular part of the symmetric matrix.\n    * @returns {Float32Array}\n    */\n    elements() {\n        const ret = wasm.rawsdpmatrix3_elements(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n}\n/**\n*/\nexport class RawSerializationPipeline {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawSerializationPipeline.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawserializationpipeline_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawserializationpipeline_new();\n        return RawSerializationPipeline.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} gravity\n    * @param {RawIntegrationParameters} integrationParameters\n    * @param {RawIslandManager} islands\n    * @param {RawBroadPhase} broadPhase\n    * @param {RawNarrowPhase} narrowPhase\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawImpulseJointSet} impulse_joints\n    * @param {RawMultibodyJointSet} multibody_joints\n    * @returns {Uint8Array | undefined}\n    */\n    serializeAll(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, impulse_joints, multibody_joints) {\n        _assertClass(gravity, RawVector);\n        _assertClass(integrationParameters, RawIntegrationParameters);\n        _assertClass(islands, RawIslandManager);\n        _assertClass(broadPhase, RawBroadPhase);\n        _assertClass(narrowPhase, RawNarrowPhase);\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(impulse_joints, RawImpulseJointSet);\n        _assertClass(multibody_joints, RawMultibodyJointSet);\n        const ret = wasm.rawserializationpipeline_serializeAll(this.__wbg_ptr, gravity.__wbg_ptr, integrationParameters.__wbg_ptr, islands.__wbg_ptr, broadPhase.__wbg_ptr, narrowPhase.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, impulse_joints.__wbg_ptr, multibody_joints.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {Uint8Array} data\n    * @returns {RawDeserializedWorld | undefined}\n    */\n    deserializeAll(data) {\n        const ret = wasm.rawserializationpipeline_deserializeAll(this.__wbg_ptr, addHeapObject(data));\n        return ret === 0 ? undefined : RawDeserializedWorld.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawShape {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawShape.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawshape_free(ptr);\n    }\n    /**\n    * @param {number} hx\n    * @param {number} hy\n    * @param {number} hz\n    * @returns {RawShape}\n    */\n    static cuboid(hx, hy, hz) {\n        const ret = wasm.rawshape_cuboid(hx, hy, hz);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} hx\n    * @param {number} hy\n    * @param {number} hz\n    * @param {number} borderRadius\n    * @returns {RawShape}\n    */\n    static roundCuboid(hx, hy, hz, borderRadius) {\n        const ret = wasm.rawshape_roundCuboid(hx, hy, hz, borderRadius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} radius\n    * @returns {RawShape}\n    */\n    static ball(radius) {\n        const ret = wasm.rawshape_ball(radius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} normal\n    * @returns {RawShape}\n    */\n    static halfspace(normal) {\n        _assertClass(normal, RawVector);\n        const ret = wasm.rawshape_halfspace(normal.__wbg_ptr);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} halfHeight\n    * @param {number} radius\n    * @returns {RawShape}\n    */\n    static capsule(halfHeight, radius) {\n        const ret = wasm.rawshape_capsule(halfHeight, radius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} halfHeight\n    * @param {number} radius\n    * @returns {RawShape}\n    */\n    static cylinder(halfHeight, radius) {\n        const ret = wasm.rawshape_cylinder(halfHeight, radius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} halfHeight\n    * @param {number} radius\n    * @param {number} borderRadius\n    * @returns {RawShape}\n    */\n    static roundCylinder(halfHeight, radius, borderRadius) {\n        const ret = wasm.rawshape_roundCylinder(halfHeight, radius, borderRadius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} halfHeight\n    * @param {number} radius\n    * @returns {RawShape}\n    */\n    static cone(halfHeight, radius) {\n        const ret = wasm.rawshape_cone(halfHeight, radius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} halfHeight\n    * @param {number} radius\n    * @param {number} borderRadius\n    * @returns {RawShape}\n    */\n    static roundCone(halfHeight, radius, borderRadius) {\n        const ret = wasm.rawshape_roundCone(halfHeight, radius, borderRadius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} vertices\n    * @param {Uint32Array} indices\n    * @returns {RawShape}\n    */\n    static polyline(vertices, indices) {\n        const ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passArray32ToWasm0(indices, wasm.__wbindgen_malloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_polyline(ptr0, len0, ptr1, len1);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} vertices\n    * @param {Uint32Array} indices\n    * @returns {RawShape}\n    */\n    static trimesh(vertices, indices) {\n        const ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passArray32ToWasm0(indices, wasm.__wbindgen_malloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_trimesh(ptr0, len0, ptr1, len1);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} nrows\n    * @param {number} ncols\n    * @param {Float32Array} heights\n    * @param {RawVector} scale\n    * @returns {RawShape}\n    */\n    static heightfield(nrows, ncols, heights, scale) {\n        const ptr0 = passArrayF32ToWasm0(heights, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        _assertClass(scale, RawVector);\n        const ret = wasm.rawshape_heightfield(nrows, ncols, ptr0, len0, scale.__wbg_ptr);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} p1\n    * @param {RawVector} p2\n    * @returns {RawShape}\n    */\n    static segment(p1, p2) {\n        _assertClass(p1, RawVector);\n        _assertClass(p2, RawVector);\n        const ret = wasm.rawshape_segment(p1.__wbg_ptr, p2.__wbg_ptr);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} p1\n    * @param {RawVector} p2\n    * @param {RawVector} p3\n    * @returns {RawShape}\n    */\n    static triangle(p1, p2, p3) {\n        _assertClass(p1, RawVector);\n        _assertClass(p2, RawVector);\n        _assertClass(p3, RawVector);\n        const ret = wasm.rawshape_triangle(p1.__wbg_ptr, p2.__wbg_ptr, p3.__wbg_ptr);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} p1\n    * @param {RawVector} p2\n    * @param {RawVector} p3\n    * @param {number} borderRadius\n    * @returns {RawShape}\n    */\n    static roundTriangle(p1, p2, p3, borderRadius) {\n        _assertClass(p1, RawVector);\n        _assertClass(p2, RawVector);\n        _assertClass(p3, RawVector);\n        const ret = wasm.rawshape_roundTriangle(p1.__wbg_ptr, p2.__wbg_ptr, p3.__wbg_ptr, borderRadius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} points\n    * @returns {RawShape | undefined}\n    */\n    static convexHull(points) {\n        const ptr0 = passArrayF32ToWasm0(points, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_convexHull(ptr0, len0);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} points\n    * @param {number} borderRadius\n    * @returns {RawShape | undefined}\n    */\n    static roundConvexHull(points, borderRadius) {\n        const ptr0 = passArrayF32ToWasm0(points, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_roundConvexHull(ptr0, len0, borderRadius);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} vertices\n    * @param {Uint32Array} indices\n    * @returns {RawShape | undefined}\n    */\n    static convexMesh(vertices, indices) {\n        const ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passArray32ToWasm0(indices, wasm.__wbindgen_malloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_convexMesh(ptr0, len0, ptr1, len1);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} vertices\n    * @param {Uint32Array} indices\n    * @param {number} borderRadius\n    * @returns {RawShape | undefined}\n    */\n    static roundConvexMesh(vertices, indices, borderRadius) {\n        const ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passArray32ToWasm0(indices, wasm.__wbindgen_malloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_roundConvexMesh(ptr0, len0, ptr1, len1, borderRadius);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} shapePos1\n    * @param {RawRotation} shapeRot1\n    * @param {RawVector} shapeVel1\n    * @param {RawShape} shape2\n    * @param {RawVector} shapePos2\n    * @param {RawRotation} shapeRot2\n    * @param {RawVector} shapeVel2\n    * @param {number} maxToi\n    * @param {boolean} stop_at_penetration\n    * @returns {RawShapeTOI | undefined}\n    */\n    castShape(shapePos1, shapeRot1, shapeVel1, shape2, shapePos2, shapeRot2, shapeVel2, maxToi, stop_at_penetration) {\n        _assertClass(shapePos1, RawVector);\n        _assertClass(shapeRot1, RawRotation);\n        _assertClass(shapeVel1, RawVector);\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        _assertClass(shapeVel2, RawVector);\n        const ret = wasm.rawshape_castShape(this.__wbg_ptr, shapePos1.__wbg_ptr, shapeRot1.__wbg_ptr, shapeVel1.__wbg_ptr, shape2.__wbg_ptr, shapePos2.__wbg_ptr, shapeRot2.__wbg_ptr, shapeVel2.__wbg_ptr, maxToi, stop_at_penetration);\n        return ret === 0 ? undefined : RawShapeTOI.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} shapePos1\n    * @param {RawRotation} shapeRot1\n    * @param {RawShape} shape2\n    * @param {RawVector} shapePos2\n    * @param {RawRotation} shapeRot2\n    * @returns {boolean}\n    */\n    intersectsShape(shapePos1, shapeRot1, shape2, shapePos2, shapeRot2) {\n        _assertClass(shapePos1, RawVector);\n        _assertClass(shapeRot1, RawRotation);\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        const ret = wasm.rawshape_intersectsShape(this.__wbg_ptr, shapePos1.__wbg_ptr, shapeRot1.__wbg_ptr, shape2.__wbg_ptr, shapePos2.__wbg_ptr, shapeRot2.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {RawVector} shapePos1\n    * @param {RawRotation} shapeRot1\n    * @param {RawShape} shape2\n    * @param {RawVector} shapePos2\n    * @param {RawRotation} shapeRot2\n    * @param {number} prediction\n    * @returns {RawShapeContact | undefined}\n    */\n    contactShape(shapePos1, shapeRot1, shape2, shapePos2, shapeRot2, prediction) {\n        _assertClass(shapePos1, RawVector);\n        _assertClass(shapeRot1, RawRotation);\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        const ret = wasm.rawshape_contactShape(this.__wbg_ptr, shapePos1.__wbg_ptr, shapeRot1.__wbg_ptr, shape2.__wbg_ptr, shapePos2.__wbg_ptr, shapeRot2.__wbg_ptr, prediction);\n        return ret === 0 ? undefined : RawShapeContact.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} point\n    * @returns {boolean}\n    */\n    containsPoint(shapePos, shapeRot, point) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(point, RawVector);\n        const ret = wasm.rawshape_containsPoint(this.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, point.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} point\n    * @param {boolean} solid\n    * @returns {RawPointProjection}\n    */\n    projectPoint(shapePos, shapeRot, point, solid) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(point, RawVector);\n        const ret = wasm.rawshape_projectPoint(this.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, point.__wbg_ptr, solid);\n        return RawPointProjection.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @returns {boolean}\n    */\n    intersectsRay(shapePos, shapeRot, rayOrig, rayDir, maxToi) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawshape_intersectsRay(this.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi);\n        return ret !== 0;\n    }\n    /**\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @returns {number}\n    */\n    castRay(shapePos, shapeRot, rayOrig, rayDir, maxToi, solid) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawshape_castRay(this.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid);\n        return ret;\n    }\n    /**\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @returns {RawRayIntersection | undefined}\n    */\n    castRayAndGetNormal(shapePos, shapeRot, rayOrig, rayDir, maxToi, solid) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawshape_castRayAndGetNormal(this.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid);\n        return ret === 0 ? undefined : RawRayIntersection.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawShapeColliderTOI {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawShapeColliderTOI.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawshapecollidertoi_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    colliderHandle() {\n        const ret = wasm.rawcharactercollision_handle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    toi() {\n        const ret = wasm.rawintegrationparameters_erp(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    witness1() {\n        const ret = wasm.rawraycolliderintersection_normal(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    witness2() {\n        const ret = wasm.rawshapecollidertoi_witness2(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal1() {\n        const ret = wasm.rawcharactercollision_translationDeltaApplied(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal2() {\n        const ret = wasm.rawcharactercollision_translationDeltaRemaining(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawShapeContact {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawShapeContact.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawshapecontact_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    distance() {\n        const ret = wasm.rawkinematiccharactercontroller_maxSlopeClimbAngle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    point1() {\n        const ret = wasm.rawpointprojection_point(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    point2() {\n        const ret = wasm.rawraycolliderintersection_normal(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal1() {\n        const ret = wasm.rawshapecollidertoi_witness2(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal2() {\n        const ret = wasm.rawcharactercollision_translationDeltaApplied(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawShapeTOI {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawShapeTOI.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawshapetoi_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    toi() {\n        const ret = wasm.rawintegrationparameters_dt(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    witness1() {\n        const ret = wasm.rawshapetoi_witness1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    witness2() {\n        const ret = wasm.rawcontactforceevent_total_force(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal1() {\n        const ret = wasm.rawshapetoi_normal1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal2() {\n        const ret = wasm.rawshapetoi_normal2(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n/**\n* A vector.\n*/\nexport class RawVector {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawVector.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawvector_free(ptr);\n    }\n    /**\n    * Creates a new vector filled with zeros.\n    * @returns {RawVector}\n    */\n    static zero() {\n        const ret = wasm.rawvector_zero();\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Creates a new 3D vector from its two components.\n    *\n    * # Parameters\n    * - `x`: the `x` component of this 3D vector.\n    * - `y`: the `y` component of this 3D vector.\n    * - `z`: the `z` component of this 3D vector.\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    */\n    constructor(x, y, z) {\n        const ret = wasm.rawvector_new(x, y, z);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The `x` component of this vector.\n    * @returns {number}\n    */\n    get x() {\n        const ret = wasm.rawintegrationparameters_dt(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * Sets the `x` component of this vector.\n    * @param {number} x\n    */\n    set x(x) {\n        wasm.rawintegrationparameters_set_dt(this.__wbg_ptr, x);\n    }\n    /**\n    * The `y` component of this vector.\n    * @returns {number}\n    */\n    get y() {\n        const ret = wasm.rawkinematiccharactercontroller_offset(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * Sets the `y` component of this vector.\n    * @param {number} y\n    */\n    set y(y) {\n        wasm.rawvector_set_y(this.__wbg_ptr, y);\n    }\n    /**\n    * The `z` component of this vector.\n    * @returns {number}\n    */\n    get z() {\n        const ret = wasm.rawintegrationparameters_erp(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * Sets the `z` component of this vector.\n    * @param {number} z\n    */\n    set z(z) {\n        wasm.rawintegrationparameters_set_erp(this.__wbg_ptr, z);\n    }\n    /**\n    * Create a new 3D vector from this vector with its components rearranged as `{x, y, z}`.\n    *\n    * This will effectively return a copy of `this`. This method exist for completeness with the\n    * other swizzling functions.\n    * @returns {RawVector}\n    */\n    xyz() {\n        const ret = wasm.rawvector_xyz(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Create a new 3D vector from this vector with its components rearranged as `{y, x, z}`.\n    * @returns {RawVector}\n    */\n    yxz() {\n        const ret = wasm.rawvector_yxz(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Create a new 3D vector from this vector with its components rearranged as `{z, x, y}`.\n    * @returns {RawVector}\n    */\n    zxy() {\n        const ret = wasm.rawvector_zxy(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Create a new 3D vector from this vector with its components rearranged as `{x, z, y}`.\n    * @returns {RawVector}\n    */\n    xzy() {\n        const ret = wasm.rawvector_xzy(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Create a new 3D vector from this vector with its components rearranged as `{y, z, x}`.\n    * @returns {RawVector}\n    */\n    yzx() {\n        const ret = wasm.rawvector_yzx(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Create a new 3D vector from this vector with its components rearranged as `{z, y, x}`.\n    * @returns {RawVector}\n    */\n    zyx() {\n        const ret = wasm.rawvector_zyx(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n\nexport function __wbindgen_number_new(arg0) {\n    const ret = arg0;\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_boolean_get(arg0) {\n    const v = getObject(arg0);\n    const ret = typeof(v) === 'boolean' ? (v ? 1 : 0) : 2;\n    return ret;\n};\n\nexport function __wbindgen_object_drop_ref(arg0) {\n    takeObject(arg0);\n};\n\nexport function __wbindgen_number_get(arg0, arg1) {\n    const obj = getObject(arg1);\n    const ret = typeof(obj) === 'number' ? obj : undefined;\n    getFloat64Memory0()[arg0 / 8 + 1] = isLikeNone(ret) ? 0 : ret;\n    getInt32Memory0()[arg0 / 4 + 0] = !isLikeNone(ret);\n};\n\nexport function __wbindgen_is_function(arg0) {\n    const ret = typeof(getObject(arg0)) === 'function';\n    return ret;\n};\n\nexport function __wbg_rawraycolliderintersection_new(arg0) {\n    const ret = RawRayColliderIntersection.__wrap(arg0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_rawcontactforceevent_new(arg0) {\n    const ret = RawContactForceEvent.__wrap(arg0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_call_01734de55d61e11d() { return handleError(function (arg0, arg1, arg2) {\n    const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_call_4c92f6aec1e1d6e6() { return handleError(function (arg0, arg1, arg2, arg3) {\n    const ret = getObject(arg0).call(getObject(arg1), getObject(arg2), getObject(arg3));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_call_776890ca77946e2f() { return handleError(function (arg0, arg1, arg2, arg3, arg4) {\n    const ret = getObject(arg0).call(getObject(arg1), getObject(arg2), getObject(arg3), getObject(arg4));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_bind_60a9a80cada2f33c(arg0, arg1, arg2, arg3) {\n    const ret = getObject(arg0).bind(getObject(arg1), getObject(arg2), getObject(arg3));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_buffer_085ec1f694018c4f(arg0) {\n    const ret = getObject(arg0).buffer;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_newwithbyteoffsetandlength_6da8e527659b86aa(arg0, arg1, arg2) {\n    const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_new_8125e318e6245eed(arg0) {\n    const ret = new Uint8Array(getObject(arg0));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_set_5cf90238115182c3(arg0, arg1, arg2) {\n    getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n};\n\nexport function __wbg_length_72e2208bbc0efc61(arg0) {\n    const ret = getObject(arg0).length;\n    return ret;\n};\n\nexport function __wbg_newwithbyteoffsetandlength_69193e31c844b792(arg0, arg1, arg2) {\n    const ret = new Float32Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_set_6146c51d49a2c0df(arg0, arg1, arg2) {\n    getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n};\n\nexport function __wbg_length_d7327c75a759af37(arg0) {\n    const ret = getObject(arg0).length;\n    return ret;\n};\n\nexport function __wbg_newwithlength_68d29ab115d0099c(arg0) {\n    const ret = new Float32Array(arg0 >>> 0);\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_throw(arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n};\n\nexport function __wbindgen_memory() {\n    const ret = wasm.memory;\n    return addHeapObject(ret);\n};\n\n", "\n        import wasmModule from \"/home/albatross/src/rapier.js/rapier3d/pkg/rapier_wasm3d_bg.wasm\";\n\n        \n        // Import from JS modules\n        import { __wbindgen_number_new, __wbindgen_boolean_get, __wbindgen_object_drop_ref, __wbindgen_number_get, __wbindgen_is_function, __wbg_rawraycolliderintersection_new, __wbg_rawcontactforceevent_new, __wbg_call_01734de55d61e11d, __wbg_call_4c92f6aec1e1d6e6, __wbg_call_776890ca77946e2f, __wbg_bind_60a9a80cada2f33c, __wbg_buffer_085ec1f694018c4f, __wbg_newwithbyteoffsetandlength_6da8e527659b86aa, __wbg_new_8125e318e6245eed, __wbg_set_5cf90238115182c3, __wbg_length_72e2208bbc0efc61, __wbg_newwithbyteoffsetandlength_69193e31c844b792, __wbg_set_6146c51d49a2c0df, __wbg_length_d7327c75a759af37, __wbg_newwithlength_68d29ab115d0099c, __wbindgen_throw, __wbindgen_memory } from \"./rapier_wasm3d_bg.js\";\n\n        // Build the WASM import object\n        const imports = {\n            [\"./rapier_wasm3d_bg.js\"]: {\n                __wbindgen_number_new,\n__wbindgen_boolean_get,\n__wbindgen_object_drop_ref,\n__wbindgen_number_get,\n__wbindgen_is_function,\n__wbg_rawraycolliderintersection_new,\n__wbg_rawcontactforceevent_new,\n__wbg_call_01734de55d61e11d,\n__wbg_call_4c92f6aec1e1d6e6,\n__wbg_call_776890ca77946e2f,\n__wbg_bind_60a9a80cada2f33c,\n__wbg_buffer_085ec1f694018c4f,\n__wbg_newwithbyteoffsetandlength_6da8e527659b86aa,\n__wbg_new_8125e318e6245eed,\n__wbg_set_5cf90238115182c3,\n__wbg_length_72e2208bbc0efc61,\n__wbg_newwithbyteoffsetandlength_69193e31c844b792,\n__wbg_set_6146c51d49a2c0df,\n__wbg_length_d7327c75a759af37,\n__wbg_newwithlength_68d29ab115d0099c,\n__wbindgen_throw,\n__wbindgen_memory\n            }\n        };\n\n        async function loadWasm(module, imports) {\n            if (typeof module === 'string') {\n\n                // Resolve relative urls from the runtime script path\n                if (module.startsWith('./')) {\n                    module = new URL(module, import.meta.url).href\n                }\n\n                \n\n                const moduleRequest = await fetch(module);\n                if (typeof WebAssembly.instantiateStreaming === 'function') {\n                    try {\n                        return await WebAssembly.instantiateStreaming(moduleRequest, imports);\n                    } catch (e) {\n                        if (moduleRequest.headers.get('Content-Type') != 'application/wasm') {\n                            console.warn(e);\n                        } else {\n                            throw e;\n                        }\n                    }\n                }\n                module = await moduleRequest.arrayBuffer();\n\n                \n            }\n            return await WebAssembly.instantiate(module, imports);\n        }\n\n        export const { instance, module } = await loadWasm(wasmModule, imports);\n\n        export const memory = instance.exports.memory;\nexport const version = instance.exports.version;\nexport const __wbg_rawkinematiccharactercontroller_free = instance.exports.__wbg_rawkinematiccharactercontroller_free;\nexport const rawkinematiccharactercontroller_new = instance.exports.rawkinematiccharactercontroller_new;\nexport const rawkinematiccharactercontroller_setUp = instance.exports.rawkinematiccharactercontroller_setUp;\nexport const rawkinematiccharactercontroller_offset = instance.exports.rawkinematiccharactercontroller_offset;\nexport const rawkinematiccharactercontroller_setOffset = instance.exports.rawkinematiccharactercontroller_setOffset;\nexport const rawkinematiccharactercontroller_slideEnabled = instance.exports.rawkinematiccharactercontroller_slideEnabled;\nexport const rawkinematiccharactercontroller_setSlideEnabled = instance.exports.rawkinematiccharactercontroller_setSlideEnabled;\nexport const rawkinematiccharactercontroller_autostepMaxHeight = instance.exports.rawkinematiccharactercontroller_autostepMaxHeight;\nexport const rawkinematiccharactercontroller_autostepMinWidth = instance.exports.rawkinematiccharactercontroller_autostepMinWidth;\nexport const rawkinematiccharactercontroller_autostepIncludesDynamicBodies = instance.exports.rawkinematiccharactercontroller_autostepIncludesDynamicBodies;\nexport const rawkinematiccharactercontroller_autostepEnabled = instance.exports.rawkinematiccharactercontroller_autostepEnabled;\nexport const rawkinematiccharactercontroller_enableAutostep = instance.exports.rawkinematiccharactercontroller_enableAutostep;\nexport const rawkinematiccharactercontroller_disableAutostep = instance.exports.rawkinematiccharactercontroller_disableAutostep;\nexport const rawkinematiccharactercontroller_maxSlopeClimbAngle = instance.exports.rawkinematiccharactercontroller_maxSlopeClimbAngle;\nexport const rawkinematiccharactercontroller_setMaxSlopeClimbAngle = instance.exports.rawkinematiccharactercontroller_setMaxSlopeClimbAngle;\nexport const rawkinematiccharactercontroller_minSlopeSlideAngle = instance.exports.rawkinematiccharactercontroller_minSlopeSlideAngle;\nexport const rawkinematiccharactercontroller_setMinSlopeSlideAngle = instance.exports.rawkinematiccharactercontroller_setMinSlopeSlideAngle;\nexport const rawkinematiccharactercontroller_snapToGroundDistance = instance.exports.rawkinematiccharactercontroller_snapToGroundDistance;\nexport const rawkinematiccharactercontroller_enableSnapToGround = instance.exports.rawkinematiccharactercontroller_enableSnapToGround;\nexport const rawkinematiccharactercontroller_disableSnapToGround = instance.exports.rawkinematiccharactercontroller_disableSnapToGround;\nexport const rawkinematiccharactercontroller_snapToGroundEnabled = instance.exports.rawkinematiccharactercontroller_snapToGroundEnabled;\nexport const rawkinematiccharactercontroller_computeColliderMovement = instance.exports.rawkinematiccharactercontroller_computeColliderMovement;\nexport const rawkinematiccharactercontroller_computedMovement = instance.exports.rawkinematiccharactercontroller_computedMovement;\nexport const rawkinematiccharactercontroller_computedGrounded = instance.exports.rawkinematiccharactercontroller_computedGrounded;\nexport const rawkinematiccharactercontroller_numComputedCollisions = instance.exports.rawkinematiccharactercontroller_numComputedCollisions;\nexport const rawkinematiccharactercontroller_computedCollision = instance.exports.rawkinematiccharactercontroller_computedCollision;\nexport const __wbg_rawcharactercollision_free = instance.exports.__wbg_rawcharactercollision_free;\nexport const rawcharactercollision_new = instance.exports.rawcharactercollision_new;\nexport const rawcharactercollision_handle = instance.exports.rawcharactercollision_handle;\nexport const rawcharactercollision_translationDeltaApplied = instance.exports.rawcharactercollision_translationDeltaApplied;\nexport const rawcharactercollision_translationDeltaRemaining = instance.exports.rawcharactercollision_translationDeltaRemaining;\nexport const rawcharactercollision_toi = instance.exports.rawcharactercollision_toi;\nexport const rawcharactercollision_worldWitness1 = instance.exports.rawcharactercollision_worldWitness1;\nexport const rawcharactercollision_worldWitness2 = instance.exports.rawcharactercollision_worldWitness2;\nexport const rawcharactercollision_worldNormal1 = instance.exports.rawcharactercollision_worldNormal1;\nexport const rawcharactercollision_worldNormal2 = instance.exports.rawcharactercollision_worldNormal2;\nexport const __wbg_rawdynamicraycastvehiclecontroller_free = instance.exports.__wbg_rawdynamicraycastvehiclecontroller_free;\nexport const rawdynamicraycastvehiclecontroller_new = instance.exports.rawdynamicraycastvehiclecontroller_new;\nexport const rawdynamicraycastvehiclecontroller_current_vehicle_speed = instance.exports.rawdynamicraycastvehiclecontroller_current_vehicle_speed;\nexport const rawdynamicraycastvehiclecontroller_chassis = instance.exports.rawdynamicraycastvehiclecontroller_chassis;\nexport const rawdynamicraycastvehiclecontroller_index_up_axis = instance.exports.rawdynamicraycastvehiclecontroller_index_up_axis;\nexport const rawdynamicraycastvehiclecontroller_set_index_up_axis = instance.exports.rawdynamicraycastvehiclecontroller_set_index_up_axis;\nexport const rawdynamicraycastvehiclecontroller_index_forward_axis = instance.exports.rawdynamicraycastvehiclecontroller_index_forward_axis;\nexport const rawdynamicraycastvehiclecontroller_set_index_forward_axis = instance.exports.rawdynamicraycastvehiclecontroller_set_index_forward_axis;\nexport const rawdynamicraycastvehiclecontroller_add_wheel = instance.exports.rawdynamicraycastvehiclecontroller_add_wheel;\nexport const rawdynamicraycastvehiclecontroller_num_wheels = instance.exports.rawdynamicraycastvehiclecontroller_num_wheels;\nexport const rawdynamicraycastvehiclecontroller_update_vehicle = instance.exports.rawdynamicraycastvehiclecontroller_update_vehicle;\nexport const rawdynamicraycastvehiclecontroller_wheel_chassis_connection_point_cs = instance.exports.rawdynamicraycastvehiclecontroller_wheel_chassis_connection_point_cs;\nexport const rawdynamicraycastvehiclecontroller_set_wheel_chassis_connection_point_cs = instance.exports.rawdynamicraycastvehiclecontroller_set_wheel_chassis_connection_point_cs;\nexport const rawdynamicraycastvehiclecontroller_wheel_suspension_rest_length = instance.exports.rawdynamicraycastvehiclecontroller_wheel_suspension_rest_length;\nexport const rawdynamicraycastvehiclecontroller_set_wheel_suspension_rest_length = instance.exports.rawdynamicraycastvehiclecontroller_set_wheel_suspension_rest_length;\nexport const rawdynamicraycastvehiclecontroller_wheel_max_suspension_travel = instance.exports.rawdynamicraycastvehiclecontroller_wheel_max_suspension_travel;\nexport const rawdynamicraycastvehiclecontroller_set_wheel_max_suspension_travel = instance.exports.rawdynamicraycastvehiclecontroller_set_wheel_max_suspension_travel;\nexport const rawdynamicraycastvehiclecontroller_wheel_radius = instance.exports.rawdynamicraycastvehiclecontroller_wheel_radius;\nexport const rawdynamicraycastvehiclecontroller_set_wheel_radius = instance.exports.rawdynamicraycastvehiclecontroller_set_wheel_radius;\nexport const rawdynamicraycastvehiclecontroller_wheel_suspension_stiffness = instance.exports.rawdynamicraycastvehiclecontroller_wheel_suspension_stiffness;\nexport const rawdynamicraycastvehiclecontroller_set_wheel_suspension_stiffness = instance.exports.rawdynamicraycastvehiclecontroller_set_wheel_suspension_stiffness;\nexport const rawdynamicraycastvehiclecontroller_wheel_suspension_compression = instance.exports.rawdynamicraycastvehiclecontroller_wheel_suspension_compression;\nexport const rawdynamicraycastvehiclecontroller_set_wheel_suspension_compression = instance.exports.rawdynamicraycastvehiclecontroller_set_wheel_suspension_compression;\nexport const rawdynamicraycastvehiclecontroller_wheel_suspension_relaxation = instance.exports.rawdynamicraycastvehiclecontroller_wheel_suspension_relaxation;\nexport const rawdynamicraycastvehiclecontroller_set_wheel_suspension_relaxation = instance.exports.rawdynamicraycastvehiclecontroller_set_wheel_suspension_relaxation;\nexport const rawdynamicraycastvehiclecontroller_wheel_max_suspension_force = instance.exports.rawdynamicraycastvehiclecontroller_wheel_max_suspension_force;\nexport const rawdynamicraycastvehiclecontroller_set_wheel_max_suspension_force = instance.exports.rawdynamicraycastvehiclecontroller_set_wheel_max_suspension_force;\nexport const rawdynamicraycastvehiclecontroller_wheel_brake = instance.exports.rawdynamicraycastvehiclecontroller_wheel_brake;\nexport const rawdynamicraycastvehiclecontroller_set_wheel_brake = instance.exports.rawdynamicraycastvehiclecontroller_set_wheel_brake;\nexport const rawdynamicraycastvehiclecontroller_wheel_steering = instance.exports.rawdynamicraycastvehiclecontroller_wheel_steering;\nexport const rawdynamicraycastvehiclecontroller_set_wheel_steering = instance.exports.rawdynamicraycastvehiclecontroller_set_wheel_steering;\nexport const rawdynamicraycastvehiclecontroller_wheel_engine_force = instance.exports.rawdynamicraycastvehiclecontroller_wheel_engine_force;\nexport const rawdynamicraycastvehiclecontroller_set_wheel_engine_force = instance.exports.rawdynamicraycastvehiclecontroller_set_wheel_engine_force;\nexport const rawdynamicraycastvehiclecontroller_wheel_direction_cs = instance.exports.rawdynamicraycastvehiclecontroller_wheel_direction_cs;\nexport const rawdynamicraycastvehiclecontroller_set_wheel_direction_cs = instance.exports.rawdynamicraycastvehiclecontroller_set_wheel_direction_cs;\nexport const rawdynamicraycastvehiclecontroller_wheel_axle_cs = instance.exports.rawdynamicraycastvehiclecontroller_wheel_axle_cs;\nexport const rawdynamicraycastvehiclecontroller_set_wheel_axle_cs = instance.exports.rawdynamicraycastvehiclecontroller_set_wheel_axle_cs;\nexport const rawdynamicraycastvehiclecontroller_wheel_friction_slip = instance.exports.rawdynamicraycastvehiclecontroller_wheel_friction_slip;\nexport const rawdynamicraycastvehiclecontroller_set_wheel_friction_slip = instance.exports.rawdynamicraycastvehiclecontroller_set_wheel_friction_slip;\nexport const rawdynamicraycastvehiclecontroller_wheel_rotation = instance.exports.rawdynamicraycastvehiclecontroller_wheel_rotation;\nexport const rawdynamicraycastvehiclecontroller_wheel_forward_impulse = instance.exports.rawdynamicraycastvehiclecontroller_wheel_forward_impulse;\nexport const rawdynamicraycastvehiclecontroller_wheel_side_impulse = instance.exports.rawdynamicraycastvehiclecontroller_wheel_side_impulse;\nexport const rawdynamicraycastvehiclecontroller_wheel_suspension_force = instance.exports.rawdynamicraycastvehiclecontroller_wheel_suspension_force;\nexport const rawdynamicraycastvehiclecontroller_wheel_contact_normal_ws = instance.exports.rawdynamicraycastvehiclecontroller_wheel_contact_normal_ws;\nexport const rawdynamicraycastvehiclecontroller_wheel_contact_point_ws = instance.exports.rawdynamicraycastvehiclecontroller_wheel_contact_point_ws;\nexport const rawdynamicraycastvehiclecontroller_wheel_suspension_length = instance.exports.rawdynamicraycastvehiclecontroller_wheel_suspension_length;\nexport const rawdynamicraycastvehiclecontroller_wheel_hard_point_ws = instance.exports.rawdynamicraycastvehiclecontroller_wheel_hard_point_ws;\nexport const rawdynamicraycastvehiclecontroller_wheel_is_in_contact = instance.exports.rawdynamicraycastvehiclecontroller_wheel_is_in_contact;\nexport const rawdynamicraycastvehiclecontroller_wheel_ground_object = instance.exports.rawdynamicraycastvehiclecontroller_wheel_ground_object;\nexport const __wbg_rawccdsolver_free = instance.exports.__wbg_rawccdsolver_free;\nexport const rawccdsolver_new = instance.exports.rawccdsolver_new;\nexport const rawimpulsejointset_jointType = instance.exports.rawimpulsejointset_jointType;\nexport const rawimpulsejointset_jointBodyHandle1 = instance.exports.rawimpulsejointset_jointBodyHandle1;\nexport const rawimpulsejointset_jointBodyHandle2 = instance.exports.rawimpulsejointset_jointBodyHandle2;\nexport const rawimpulsejointset_jointFrameX1 = instance.exports.rawimpulsejointset_jointFrameX1;\nexport const rawimpulsejointset_jointFrameX2 = instance.exports.rawimpulsejointset_jointFrameX2;\nexport const rawimpulsejointset_jointAnchor1 = instance.exports.rawimpulsejointset_jointAnchor1;\nexport const rawimpulsejointset_jointAnchor2 = instance.exports.rawimpulsejointset_jointAnchor2;\nexport const rawimpulsejointset_jointSetAnchor1 = instance.exports.rawimpulsejointset_jointSetAnchor1;\nexport const rawimpulsejointset_jointSetAnchor2 = instance.exports.rawimpulsejointset_jointSetAnchor2;\nexport const rawimpulsejointset_jointContactsEnabled = instance.exports.rawimpulsejointset_jointContactsEnabled;\nexport const rawimpulsejointset_jointSetContactsEnabled = instance.exports.rawimpulsejointset_jointSetContactsEnabled;\nexport const rawimpulsejointset_jointLimitsEnabled = instance.exports.rawimpulsejointset_jointLimitsEnabled;\nexport const rawimpulsejointset_jointLimitsMin = instance.exports.rawimpulsejointset_jointLimitsMin;\nexport const rawimpulsejointset_jointLimitsMax = instance.exports.rawimpulsejointset_jointLimitsMax;\nexport const rawimpulsejointset_jointSetLimits = instance.exports.rawimpulsejointset_jointSetLimits;\nexport const rawimpulsejointset_jointConfigureMotorModel = instance.exports.rawimpulsejointset_jointConfigureMotorModel;\nexport const rawimpulsejointset_jointConfigureMotorVelocity = instance.exports.rawimpulsejointset_jointConfigureMotorVelocity;\nexport const rawimpulsejointset_jointConfigureMotorPosition = instance.exports.rawimpulsejointset_jointConfigureMotorPosition;\nexport const rawimpulsejointset_jointConfigureMotor = instance.exports.rawimpulsejointset_jointConfigureMotor;\nexport const __wbg_rawimpulsejointset_free = instance.exports.__wbg_rawimpulsejointset_free;\nexport const rawimpulsejointset_new = instance.exports.rawimpulsejointset_new;\nexport const rawimpulsejointset_createJoint = instance.exports.rawimpulsejointset_createJoint;\nexport const rawimpulsejointset_remove = instance.exports.rawimpulsejointset_remove;\nexport const rawimpulsejointset_len = instance.exports.rawimpulsejointset_len;\nexport const rawimpulsejointset_contains = instance.exports.rawimpulsejointset_contains;\nexport const rawimpulsejointset_forEachJointHandle = instance.exports.rawimpulsejointset_forEachJointHandle;\nexport const rawimpulsejointset_forEachJointAttachedToRigidBody = instance.exports.rawimpulsejointset_forEachJointAttachedToRigidBody;\nexport const __wbg_rawintegrationparameters_free = instance.exports.__wbg_rawintegrationparameters_free;\nexport const rawintegrationparameters_new = instance.exports.rawintegrationparameters_new;\nexport const rawintegrationparameters_dt = instance.exports.rawintegrationparameters_dt;\nexport const rawintegrationparameters_erp = instance.exports.rawintegrationparameters_erp;\nexport const rawintegrationparameters_allowedLinearError = instance.exports.rawintegrationparameters_allowedLinearError;\nexport const rawintegrationparameters_predictionDistance = instance.exports.rawintegrationparameters_predictionDistance;\nexport const rawintegrationparameters_maxVelocityIterations = instance.exports.rawintegrationparameters_maxVelocityIterations;\nexport const rawintegrationparameters_maxVelocityFrictionIterations = instance.exports.rawintegrationparameters_maxVelocityFrictionIterations;\nexport const rawintegrationparameters_maxStabilizationIterations = instance.exports.rawintegrationparameters_maxStabilizationIterations;\nexport const rawintegrationparameters_set_dt = instance.exports.rawintegrationparameters_set_dt;\nexport const rawintegrationparameters_set_erp = instance.exports.rawintegrationparameters_set_erp;\nexport const rawintegrationparameters_set_allowedLinearError = instance.exports.rawintegrationparameters_set_allowedLinearError;\nexport const rawintegrationparameters_set_predictionDistance = instance.exports.rawintegrationparameters_set_predictionDistance;\nexport const rawintegrationparameters_set_maxVelocityIterations = instance.exports.rawintegrationparameters_set_maxVelocityIterations;\nexport const rawintegrationparameters_set_maxVelocityFrictionIterations = instance.exports.rawintegrationparameters_set_maxVelocityFrictionIterations;\nexport const rawintegrationparameters_set_maxStabilizationIterations = instance.exports.rawintegrationparameters_set_maxStabilizationIterations;\nexport const __wbg_rawislandmanager_free = instance.exports.__wbg_rawislandmanager_free;\nexport const rawislandmanager_new = instance.exports.rawislandmanager_new;\nexport const rawislandmanager_forEachActiveRigidBodyHandle = instance.exports.rawislandmanager_forEachActiveRigidBodyHandle;\nexport const __wbg_rawgenericjoint_free = instance.exports.__wbg_rawgenericjoint_free;\nexport const rawgenericjoint_generic = instance.exports.rawgenericjoint_generic;\nexport const rawgenericjoint_spherical = instance.exports.rawgenericjoint_spherical;\nexport const rawgenericjoint_prismatic = instance.exports.rawgenericjoint_prismatic;\nexport const rawgenericjoint_fixed = instance.exports.rawgenericjoint_fixed;\nexport const rawgenericjoint_revolute = instance.exports.rawgenericjoint_revolute;\nexport const rawmultibodyjointset_jointType = instance.exports.rawmultibodyjointset_jointType;\nexport const rawmultibodyjointset_jointFrameX1 = instance.exports.rawmultibodyjointset_jointFrameX1;\nexport const rawmultibodyjointset_jointFrameX2 = instance.exports.rawmultibodyjointset_jointFrameX2;\nexport const rawmultibodyjointset_jointAnchor1 = instance.exports.rawmultibodyjointset_jointAnchor1;\nexport const rawmultibodyjointset_jointAnchor2 = instance.exports.rawmultibodyjointset_jointAnchor2;\nexport const rawmultibodyjointset_jointContactsEnabled = instance.exports.rawmultibodyjointset_jointContactsEnabled;\nexport const rawmultibodyjointset_jointSetContactsEnabled = instance.exports.rawmultibodyjointset_jointSetContactsEnabled;\nexport const rawmultibodyjointset_jointLimitsEnabled = instance.exports.rawmultibodyjointset_jointLimitsEnabled;\nexport const rawmultibodyjointset_jointLimitsMin = instance.exports.rawmultibodyjointset_jointLimitsMin;\nexport const rawmultibodyjointset_jointLimitsMax = instance.exports.rawmultibodyjointset_jointLimitsMax;\nexport const __wbg_rawmultibodyjointset_free = instance.exports.__wbg_rawmultibodyjointset_free;\nexport const rawmultibodyjointset_new = instance.exports.rawmultibodyjointset_new;\nexport const rawmultibodyjointset_createJoint = instance.exports.rawmultibodyjointset_createJoint;\nexport const rawmultibodyjointset_remove = instance.exports.rawmultibodyjointset_remove;\nexport const rawmultibodyjointset_contains = instance.exports.rawmultibodyjointset_contains;\nexport const rawmultibodyjointset_forEachJointHandle = instance.exports.rawmultibodyjointset_forEachJointHandle;\nexport const rawmultibodyjointset_forEachJointAttachedToRigidBody = instance.exports.rawmultibodyjointset_forEachJointAttachedToRigidBody;\nexport const rawrigidbodyset_rbTranslation = instance.exports.rawrigidbodyset_rbTranslation;\nexport const rawrigidbodyset_rbRotation = instance.exports.rawrigidbodyset_rbRotation;\nexport const rawrigidbodyset_rbSleep = instance.exports.rawrigidbodyset_rbSleep;\nexport const rawrigidbodyset_rbIsSleeping = instance.exports.rawrigidbodyset_rbIsSleeping;\nexport const rawrigidbodyset_rbIsMoving = instance.exports.rawrigidbodyset_rbIsMoving;\nexport const rawrigidbodyset_rbNextTranslation = instance.exports.rawrigidbodyset_rbNextTranslation;\nexport const rawrigidbodyset_rbNextRotation = instance.exports.rawrigidbodyset_rbNextRotation;\nexport const rawrigidbodyset_rbSetTranslation = instance.exports.rawrigidbodyset_rbSetTranslation;\nexport const rawrigidbodyset_rbSetRotation = instance.exports.rawrigidbodyset_rbSetRotation;\nexport const rawrigidbodyset_rbSetLinvel = instance.exports.rawrigidbodyset_rbSetLinvel;\nexport const rawrigidbodyset_rbSetAngvel = instance.exports.rawrigidbodyset_rbSetAngvel;\nexport const rawrigidbodyset_rbSetNextKinematicTranslation = instance.exports.rawrigidbodyset_rbSetNextKinematicTranslation;\nexport const rawrigidbodyset_rbSetNextKinematicRotation = instance.exports.rawrigidbodyset_rbSetNextKinematicRotation;\nexport const rawrigidbodyset_rbRecomputeMassPropertiesFromColliders = instance.exports.rawrigidbodyset_rbRecomputeMassPropertiesFromColliders;\nexport const rawrigidbodyset_rbSetAdditionalMass = instance.exports.rawrigidbodyset_rbSetAdditionalMass;\nexport const rawrigidbodyset_rbSetAdditionalMassProperties = instance.exports.rawrigidbodyset_rbSetAdditionalMassProperties;\nexport const rawrigidbodyset_rbLinvel = instance.exports.rawrigidbodyset_rbLinvel;\nexport const rawrigidbodyset_rbAngvel = instance.exports.rawrigidbodyset_rbAngvel;\nexport const rawrigidbodyset_rbLockTranslations = instance.exports.rawrigidbodyset_rbLockTranslations;\nexport const rawrigidbodyset_rbSetEnabledTranslations = instance.exports.rawrigidbodyset_rbSetEnabledTranslations;\nexport const rawrigidbodyset_rbLockRotations = instance.exports.rawrigidbodyset_rbLockRotations;\nexport const rawrigidbodyset_rbSetEnabledRotations = instance.exports.rawrigidbodyset_rbSetEnabledRotations;\nexport const rawrigidbodyset_rbDominanceGroup = instance.exports.rawrigidbodyset_rbDominanceGroup;\nexport const rawrigidbodyset_rbSetDominanceGroup = instance.exports.rawrigidbodyset_rbSetDominanceGroup;\nexport const rawrigidbodyset_rbEnableCcd = instance.exports.rawrigidbodyset_rbEnableCcd;\nexport const rawrigidbodyset_rbMass = instance.exports.rawrigidbodyset_rbMass;\nexport const rawrigidbodyset_rbInvMass = instance.exports.rawrigidbodyset_rbInvMass;\nexport const rawrigidbodyset_rbEffectiveInvMass = instance.exports.rawrigidbodyset_rbEffectiveInvMass;\nexport const rawrigidbodyset_rbLocalCom = instance.exports.rawrigidbodyset_rbLocalCom;\nexport const rawrigidbodyset_rbWorldCom = instance.exports.rawrigidbodyset_rbWorldCom;\nexport const rawrigidbodyset_rbInvPrincipalInertiaSqrt = instance.exports.rawrigidbodyset_rbInvPrincipalInertiaSqrt;\nexport const rawrigidbodyset_rbPrincipalInertiaLocalFrame = instance.exports.rawrigidbodyset_rbPrincipalInertiaLocalFrame;\nexport const rawrigidbodyset_rbPrincipalInertia = instance.exports.rawrigidbodyset_rbPrincipalInertia;\nexport const rawrigidbodyset_rbEffectiveWorldInvInertiaSqrt = instance.exports.rawrigidbodyset_rbEffectiveWorldInvInertiaSqrt;\nexport const rawrigidbodyset_rbEffectiveAngularInertia = instance.exports.rawrigidbodyset_rbEffectiveAngularInertia;\nexport const rawrigidbodyset_rbWakeUp = instance.exports.rawrigidbodyset_rbWakeUp;\nexport const rawrigidbodyset_rbIsCcdEnabled = instance.exports.rawrigidbodyset_rbIsCcdEnabled;\nexport const rawrigidbodyset_rbNumColliders = instance.exports.rawrigidbodyset_rbNumColliders;\nexport const rawrigidbodyset_rbCollider = instance.exports.rawrigidbodyset_rbCollider;\nexport const rawrigidbodyset_rbBodyType = instance.exports.rawrigidbodyset_rbBodyType;\nexport const rawrigidbodyset_rbSetBodyType = instance.exports.rawrigidbodyset_rbSetBodyType;\nexport const rawrigidbodyset_rbIsFixed = instance.exports.rawrigidbodyset_rbIsFixed;\nexport const rawrigidbodyset_rbIsKinematic = instance.exports.rawrigidbodyset_rbIsKinematic;\nexport const rawrigidbodyset_rbIsDynamic = instance.exports.rawrigidbodyset_rbIsDynamic;\nexport const rawrigidbodyset_rbLinearDamping = instance.exports.rawrigidbodyset_rbLinearDamping;\nexport const rawrigidbodyset_rbAngularDamping = instance.exports.rawrigidbodyset_rbAngularDamping;\nexport const rawrigidbodyset_rbSetLinearDamping = instance.exports.rawrigidbodyset_rbSetLinearDamping;\nexport const rawrigidbodyset_rbSetAngularDamping = instance.exports.rawrigidbodyset_rbSetAngularDamping;\nexport const rawrigidbodyset_rbSetEnabled = instance.exports.rawrigidbodyset_rbSetEnabled;\nexport const rawrigidbodyset_rbIsEnabled = instance.exports.rawrigidbodyset_rbIsEnabled;\nexport const rawrigidbodyset_rbGravityScale = instance.exports.rawrigidbodyset_rbGravityScale;\nexport const rawrigidbodyset_rbSetGravityScale = instance.exports.rawrigidbodyset_rbSetGravityScale;\nexport const rawrigidbodyset_rbResetForces = instance.exports.rawrigidbodyset_rbResetForces;\nexport const rawrigidbodyset_rbResetTorques = instance.exports.rawrigidbodyset_rbResetTorques;\nexport const rawrigidbodyset_rbAddForce = instance.exports.rawrigidbodyset_rbAddForce;\nexport const rawrigidbodyset_rbApplyImpulse = instance.exports.rawrigidbodyset_rbApplyImpulse;\nexport const rawrigidbodyset_rbAddTorque = instance.exports.rawrigidbodyset_rbAddTorque;\nexport const rawrigidbodyset_rbApplyTorqueImpulse = instance.exports.rawrigidbodyset_rbApplyTorqueImpulse;\nexport const rawrigidbodyset_rbAddForceAtPoint = instance.exports.rawrigidbodyset_rbAddForceAtPoint;\nexport const rawrigidbodyset_rbApplyImpulseAtPoint = instance.exports.rawrigidbodyset_rbApplyImpulseAtPoint;\nexport const rawrigidbodyset_rbUserData = instance.exports.rawrigidbodyset_rbUserData;\nexport const rawrigidbodyset_rbSetUserData = instance.exports.rawrigidbodyset_rbSetUserData;\nexport const __wbg_rawrigidbodyset_free = instance.exports.__wbg_rawrigidbodyset_free;\nexport const rawrigidbodyset_new = instance.exports.rawrigidbodyset_new;\nexport const rawrigidbodyset_createRigidBody = instance.exports.rawrigidbodyset_createRigidBody;\nexport const rawrigidbodyset_remove = instance.exports.rawrigidbodyset_remove;\nexport const rawrigidbodyset_contains = instance.exports.rawrigidbodyset_contains;\nexport const rawrigidbodyset_forEachRigidBodyHandle = instance.exports.rawrigidbodyset_forEachRigidBodyHandle;\nexport const rawrigidbodyset_propagateModifiedBodyPositionsToColliders = instance.exports.rawrigidbodyset_propagateModifiedBodyPositionsToColliders;\nexport const __wbg_rawbroadphase_free = instance.exports.__wbg_rawbroadphase_free;\nexport const rawbroadphase_new = instance.exports.rawbroadphase_new;\nexport const rawcolliderset_coTranslation = instance.exports.rawcolliderset_coTranslation;\nexport const rawcolliderset_coRotation = instance.exports.rawcolliderset_coRotation;\nexport const rawcolliderset_coSetTranslation = instance.exports.rawcolliderset_coSetTranslation;\nexport const rawcolliderset_coSetTranslationWrtParent = instance.exports.rawcolliderset_coSetTranslationWrtParent;\nexport const rawcolliderset_coSetRotation = instance.exports.rawcolliderset_coSetRotation;\nexport const rawcolliderset_coSetRotationWrtParent = instance.exports.rawcolliderset_coSetRotationWrtParent;\nexport const rawcolliderset_coIsSensor = instance.exports.rawcolliderset_coIsSensor;\nexport const rawcolliderset_coShapeType = instance.exports.rawcolliderset_coShapeType;\nexport const rawcolliderset_coHalfspaceNormal = instance.exports.rawcolliderset_coHalfspaceNormal;\nexport const rawcolliderset_coHalfExtents = instance.exports.rawcolliderset_coHalfExtents;\nexport const rawcolliderset_coSetHalfExtents = instance.exports.rawcolliderset_coSetHalfExtents;\nexport const rawcolliderset_coRadius = instance.exports.rawcolliderset_coRadius;\nexport const rawcolliderset_coSetRadius = instance.exports.rawcolliderset_coSetRadius;\nexport const rawcolliderset_coHalfHeight = instance.exports.rawcolliderset_coHalfHeight;\nexport const rawcolliderset_coSetHalfHeight = instance.exports.rawcolliderset_coSetHalfHeight;\nexport const rawcolliderset_coRoundRadius = instance.exports.rawcolliderset_coRoundRadius;\nexport const rawcolliderset_coSetRoundRadius = instance.exports.rawcolliderset_coSetRoundRadius;\nexport const rawcolliderset_coVertices = instance.exports.rawcolliderset_coVertices;\nexport const rawcolliderset_coIndices = instance.exports.rawcolliderset_coIndices;\nexport const rawcolliderset_coHeightfieldHeights = instance.exports.rawcolliderset_coHeightfieldHeights;\nexport const rawcolliderset_coHeightfieldScale = instance.exports.rawcolliderset_coHeightfieldScale;\nexport const rawcolliderset_coHeightfieldNRows = instance.exports.rawcolliderset_coHeightfieldNRows;\nexport const rawcolliderset_coHeightfieldNCols = instance.exports.rawcolliderset_coHeightfieldNCols;\nexport const rawcolliderset_coParent = instance.exports.rawcolliderset_coParent;\nexport const rawcolliderset_coSetEnabled = instance.exports.rawcolliderset_coSetEnabled;\nexport const rawcolliderset_coIsEnabled = instance.exports.rawcolliderset_coIsEnabled;\nexport const rawcolliderset_coFriction = instance.exports.rawcolliderset_coFriction;\nexport const rawcolliderset_coRestitution = instance.exports.rawcolliderset_coRestitution;\nexport const rawcolliderset_coDensity = instance.exports.rawcolliderset_coDensity;\nexport const rawcolliderset_coMass = instance.exports.rawcolliderset_coMass;\nexport const rawcolliderset_coVolume = instance.exports.rawcolliderset_coVolume;\nexport const rawcolliderset_coCollisionGroups = instance.exports.rawcolliderset_coCollisionGroups;\nexport const rawcolliderset_coSolverGroups = instance.exports.rawcolliderset_coSolverGroups;\nexport const rawcolliderset_coActiveHooks = instance.exports.rawcolliderset_coActiveHooks;\nexport const rawcolliderset_coActiveCollisionTypes = instance.exports.rawcolliderset_coActiveCollisionTypes;\nexport const rawcolliderset_coActiveEvents = instance.exports.rawcolliderset_coActiveEvents;\nexport const rawcolliderset_coContactForceEventThreshold = instance.exports.rawcolliderset_coContactForceEventThreshold;\nexport const rawcolliderset_coContainsPoint = instance.exports.rawcolliderset_coContainsPoint;\nexport const rawcolliderset_coCastShape = instance.exports.rawcolliderset_coCastShape;\nexport const rawcolliderset_coCastCollider = instance.exports.rawcolliderset_coCastCollider;\nexport const rawcolliderset_coIntersectsShape = instance.exports.rawcolliderset_coIntersectsShape;\nexport const rawcolliderset_coContactShape = instance.exports.rawcolliderset_coContactShape;\nexport const rawcolliderset_coContactCollider = instance.exports.rawcolliderset_coContactCollider;\nexport const rawcolliderset_coProjectPoint = instance.exports.rawcolliderset_coProjectPoint;\nexport const rawcolliderset_coIntersectsRay = instance.exports.rawcolliderset_coIntersectsRay;\nexport const rawcolliderset_coCastRay = instance.exports.rawcolliderset_coCastRay;\nexport const rawcolliderset_coCastRayAndGetNormal = instance.exports.rawcolliderset_coCastRayAndGetNormal;\nexport const rawcolliderset_coSetSensor = instance.exports.rawcolliderset_coSetSensor;\nexport const rawcolliderset_coSetRestitution = instance.exports.rawcolliderset_coSetRestitution;\nexport const rawcolliderset_coSetFriction = instance.exports.rawcolliderset_coSetFriction;\nexport const rawcolliderset_coFrictionCombineRule = instance.exports.rawcolliderset_coFrictionCombineRule;\nexport const rawcolliderset_coSetFrictionCombineRule = instance.exports.rawcolliderset_coSetFrictionCombineRule;\nexport const rawcolliderset_coRestitutionCombineRule = instance.exports.rawcolliderset_coRestitutionCombineRule;\nexport const rawcolliderset_coSetRestitutionCombineRule = instance.exports.rawcolliderset_coSetRestitutionCombineRule;\nexport const rawcolliderset_coSetCollisionGroups = instance.exports.rawcolliderset_coSetCollisionGroups;\nexport const rawcolliderset_coSetSolverGroups = instance.exports.rawcolliderset_coSetSolverGroups;\nexport const rawcolliderset_coSetActiveHooks = instance.exports.rawcolliderset_coSetActiveHooks;\nexport const rawcolliderset_coSetActiveEvents = instance.exports.rawcolliderset_coSetActiveEvents;\nexport const rawcolliderset_coSetActiveCollisionTypes = instance.exports.rawcolliderset_coSetActiveCollisionTypes;\nexport const rawcolliderset_coSetShape = instance.exports.rawcolliderset_coSetShape;\nexport const rawcolliderset_coSetContactForceEventThreshold = instance.exports.rawcolliderset_coSetContactForceEventThreshold;\nexport const rawcolliderset_coSetDensity = instance.exports.rawcolliderset_coSetDensity;\nexport const rawcolliderset_coSetMass = instance.exports.rawcolliderset_coSetMass;\nexport const rawcolliderset_coSetMassProperties = instance.exports.rawcolliderset_coSetMassProperties;\nexport const __wbg_rawcolliderset_free = instance.exports.__wbg_rawcolliderset_free;\nexport const rawcolliderset_new = instance.exports.rawcolliderset_new;\nexport const rawcolliderset_len = instance.exports.rawcolliderset_len;\nexport const rawcolliderset_contains = instance.exports.rawcolliderset_contains;\nexport const rawcolliderset_createCollider = instance.exports.rawcolliderset_createCollider;\nexport const rawcolliderset_remove = instance.exports.rawcolliderset_remove;\nexport const rawcolliderset_forEachColliderHandle = instance.exports.rawcolliderset_forEachColliderHandle;\nexport const __wbg_rawshapecontact_free = instance.exports.__wbg_rawshapecontact_free;\nexport const __wbg_rawnarrowphase_free = instance.exports.__wbg_rawnarrowphase_free;\nexport const rawnarrowphase_new = instance.exports.rawnarrowphase_new;\nexport const rawnarrowphase_contacts_with = instance.exports.rawnarrowphase_contacts_with;\nexport const rawnarrowphase_contact_pair = instance.exports.rawnarrowphase_contact_pair;\nexport const rawnarrowphase_intersections_with = instance.exports.rawnarrowphase_intersections_with;\nexport const rawnarrowphase_intersection_pair = instance.exports.rawnarrowphase_intersection_pair;\nexport const __wbg_rawcontactmanifold_free = instance.exports.__wbg_rawcontactmanifold_free;\nexport const rawcontactpair_collider1 = instance.exports.rawcontactpair_collider1;\nexport const rawcontactpair_collider2 = instance.exports.rawcontactpair_collider2;\nexport const rawcontactpair_numContactManifolds = instance.exports.rawcontactpair_numContactManifolds;\nexport const rawcontactpair_contactManifold = instance.exports.rawcontactpair_contactManifold;\nexport const rawcontactmanifold_normal = instance.exports.rawcontactmanifold_normal;\nexport const rawcontactmanifold_local_n1 = instance.exports.rawcontactmanifold_local_n1;\nexport const rawcontactmanifold_local_n2 = instance.exports.rawcontactmanifold_local_n2;\nexport const rawcontactmanifold_subshape1 = instance.exports.rawcontactmanifold_subshape1;\nexport const rawcontactmanifold_subshape2 = instance.exports.rawcontactmanifold_subshape2;\nexport const rawcontactmanifold_num_contacts = instance.exports.rawcontactmanifold_num_contacts;\nexport const rawcontactmanifold_contact_local_p1 = instance.exports.rawcontactmanifold_contact_local_p1;\nexport const rawcontactmanifold_contact_local_p2 = instance.exports.rawcontactmanifold_contact_local_p2;\nexport const rawcontactmanifold_contact_dist = instance.exports.rawcontactmanifold_contact_dist;\nexport const rawcontactmanifold_contact_fid1 = instance.exports.rawcontactmanifold_contact_fid1;\nexport const rawcontactmanifold_contact_fid2 = instance.exports.rawcontactmanifold_contact_fid2;\nexport const rawcontactmanifold_contact_impulse = instance.exports.rawcontactmanifold_contact_impulse;\nexport const rawcontactmanifold_contact_tangent_impulse_x = instance.exports.rawcontactmanifold_contact_tangent_impulse_x;\nexport const rawcontactmanifold_contact_tangent_impulse_y = instance.exports.rawcontactmanifold_contact_tangent_impulse_y;\nexport const rawcontactmanifold_num_solver_contacts = instance.exports.rawcontactmanifold_num_solver_contacts;\nexport const rawcontactmanifold_solver_contact_point = instance.exports.rawcontactmanifold_solver_contact_point;\nexport const rawcontactmanifold_solver_contact_dist = instance.exports.rawcontactmanifold_solver_contact_dist;\nexport const rawcontactmanifold_solver_contact_friction = instance.exports.rawcontactmanifold_solver_contact_friction;\nexport const rawcontactmanifold_solver_contact_restitution = instance.exports.rawcontactmanifold_solver_contact_restitution;\nexport const rawcontactmanifold_solver_contact_tangent_velocity = instance.exports.rawcontactmanifold_solver_contact_tangent_velocity;\nexport const __wbg_rawpointprojection_free = instance.exports.__wbg_rawpointprojection_free;\nexport const rawpointprojection_point = instance.exports.rawpointprojection_point;\nexport const rawpointprojection_isInside = instance.exports.rawpointprojection_isInside;\nexport const __wbg_rawpointcolliderprojection_free = instance.exports.__wbg_rawpointcolliderprojection_free;\nexport const rawpointcolliderprojection_colliderHandle = instance.exports.rawpointcolliderprojection_colliderHandle;\nexport const rawpointcolliderprojection_point = instance.exports.rawpointcolliderprojection_point;\nexport const rawpointcolliderprojection_isInside = instance.exports.rawpointcolliderprojection_isInside;\nexport const rawpointcolliderprojection_featureType = instance.exports.rawpointcolliderprojection_featureType;\nexport const rawpointcolliderprojection_featureId = instance.exports.rawpointcolliderprojection_featureId;\nexport const __wbg_rawrayintersection_free = instance.exports.__wbg_rawrayintersection_free;\nexport const rawraycolliderintersection_normal = instance.exports.rawraycolliderintersection_normal;\nexport const __wbg_rawraycollidertoi_free = instance.exports.__wbg_rawraycollidertoi_free;\nexport const __wbg_rawshape_free = instance.exports.__wbg_rawshape_free;\nexport const rawshape_cuboid = instance.exports.rawshape_cuboid;\nexport const rawshape_roundCuboid = instance.exports.rawshape_roundCuboid;\nexport const rawshape_ball = instance.exports.rawshape_ball;\nexport const rawshape_halfspace = instance.exports.rawshape_halfspace;\nexport const rawshape_capsule = instance.exports.rawshape_capsule;\nexport const rawshape_cylinder = instance.exports.rawshape_cylinder;\nexport const rawshape_roundCylinder = instance.exports.rawshape_roundCylinder;\nexport const rawshape_cone = instance.exports.rawshape_cone;\nexport const rawshape_roundCone = instance.exports.rawshape_roundCone;\nexport const rawshape_polyline = instance.exports.rawshape_polyline;\nexport const rawshape_trimesh = instance.exports.rawshape_trimesh;\nexport const rawshape_heightfield = instance.exports.rawshape_heightfield;\nexport const rawshape_segment = instance.exports.rawshape_segment;\nexport const rawshape_triangle = instance.exports.rawshape_triangle;\nexport const rawshape_roundTriangle = instance.exports.rawshape_roundTriangle;\nexport const rawshape_convexHull = instance.exports.rawshape_convexHull;\nexport const rawshape_roundConvexHull = instance.exports.rawshape_roundConvexHull;\nexport const rawshape_convexMesh = instance.exports.rawshape_convexMesh;\nexport const rawshape_roundConvexMesh = instance.exports.rawshape_roundConvexMesh;\nexport const rawshape_castShape = instance.exports.rawshape_castShape;\nexport const rawshape_intersectsShape = instance.exports.rawshape_intersectsShape;\nexport const rawshape_contactShape = instance.exports.rawshape_contactShape;\nexport const rawshape_containsPoint = instance.exports.rawshape_containsPoint;\nexport const rawshape_projectPoint = instance.exports.rawshape_projectPoint;\nexport const rawshape_intersectsRay = instance.exports.rawshape_intersectsRay;\nexport const rawshape_castRay = instance.exports.rawshape_castRay;\nexport const rawshape_castRayAndGetNormal = instance.exports.rawshape_castRayAndGetNormal;\nexport const __wbg_rawshapetoi_free = instance.exports.__wbg_rawshapetoi_free;\nexport const rawshapetoi_witness1 = instance.exports.rawshapetoi_witness1;\nexport const rawshapetoi_normal1 = instance.exports.rawshapetoi_normal1;\nexport const rawshapetoi_normal2 = instance.exports.rawshapetoi_normal2;\nexport const __wbg_rawshapecollidertoi_free = instance.exports.__wbg_rawshapecollidertoi_free;\nexport const rawshapecollidertoi_witness2 = instance.exports.rawshapecollidertoi_witness2;\nexport const rawrotation_new = instance.exports.rawrotation_new;\nexport const rawrotation_identity = instance.exports.rawrotation_identity;\nexport const rawrotation_w = instance.exports.rawrotation_w;\nexport const rawvector_zero = instance.exports.rawvector_zero;\nexport const rawvector_new = instance.exports.rawvector_new;\nexport const rawvector_set_y = instance.exports.rawvector_set_y;\nexport const rawvector_xyz = instance.exports.rawvector_xyz;\nexport const rawvector_yxz = instance.exports.rawvector_yxz;\nexport const rawvector_zxy = instance.exports.rawvector_zxy;\nexport const rawvector_xzy = instance.exports.rawvector_xzy;\nexport const rawvector_yzx = instance.exports.rawvector_yzx;\nexport const rawvector_zyx = instance.exports.rawvector_zyx;\nexport const rawsdpmatrix3_elements = instance.exports.rawsdpmatrix3_elements;\nexport const __wbg_rawdebugrenderpipeline_free = instance.exports.__wbg_rawdebugrenderpipeline_free;\nexport const rawdebugrenderpipeline_new = instance.exports.rawdebugrenderpipeline_new;\nexport const rawdebugrenderpipeline_vertices = instance.exports.rawdebugrenderpipeline_vertices;\nexport const rawdebugrenderpipeline_colors = instance.exports.rawdebugrenderpipeline_colors;\nexport const rawdebugrenderpipeline_render = instance.exports.rawdebugrenderpipeline_render;\nexport const __wbg_raweventqueue_free = instance.exports.__wbg_raweventqueue_free;\nexport const __wbg_rawcontactforceevent_free = instance.exports.__wbg_rawcontactforceevent_free;\nexport const rawcontactforceevent_collider2 = instance.exports.rawcontactforceevent_collider2;\nexport const rawcontactforceevent_total_force = instance.exports.rawcontactforceevent_total_force;\nexport const rawcontactforceevent_total_force_magnitude = instance.exports.rawcontactforceevent_total_force_magnitude;\nexport const rawcontactforceevent_max_force_direction = instance.exports.rawcontactforceevent_max_force_direction;\nexport const rawcontactforceevent_max_force_magnitude = instance.exports.rawcontactforceevent_max_force_magnitude;\nexport const raweventqueue_new = instance.exports.raweventqueue_new;\nexport const raweventqueue_drainCollisionEvents = instance.exports.raweventqueue_drainCollisionEvents;\nexport const raweventqueue_drainContactForceEvents = instance.exports.raweventqueue_drainContactForceEvents;\nexport const raweventqueue_clear = instance.exports.raweventqueue_clear;\nexport const __wbg_rawphysicspipeline_free = instance.exports.__wbg_rawphysicspipeline_free;\nexport const rawphysicspipeline_new = instance.exports.rawphysicspipeline_new;\nexport const rawphysicspipeline_step = instance.exports.rawphysicspipeline_step;\nexport const rawphysicspipeline_stepWithEvents = instance.exports.rawphysicspipeline_stepWithEvents;\nexport const __wbg_rawquerypipeline_free = instance.exports.__wbg_rawquerypipeline_free;\nexport const rawquerypipeline_new = instance.exports.rawquerypipeline_new;\nexport const rawquerypipeline_update = instance.exports.rawquerypipeline_update;\nexport const rawquerypipeline_castRay = instance.exports.rawquerypipeline_castRay;\nexport const rawquerypipeline_castRayAndGetNormal = instance.exports.rawquerypipeline_castRayAndGetNormal;\nexport const rawquerypipeline_intersectionsWithRay = instance.exports.rawquerypipeline_intersectionsWithRay;\nexport const rawquerypipeline_intersectionWithShape = instance.exports.rawquerypipeline_intersectionWithShape;\nexport const rawquerypipeline_projectPoint = instance.exports.rawquerypipeline_projectPoint;\nexport const rawquerypipeline_projectPointAndGetFeature = instance.exports.rawquerypipeline_projectPointAndGetFeature;\nexport const rawquerypipeline_intersectionsWithPoint = instance.exports.rawquerypipeline_intersectionsWithPoint;\nexport const rawquerypipeline_castShape = instance.exports.rawquerypipeline_castShape;\nexport const rawquerypipeline_intersectionsWithShape = instance.exports.rawquerypipeline_intersectionsWithShape;\nexport const rawquerypipeline_collidersWithAabbIntersectingAabb = instance.exports.rawquerypipeline_collidersWithAabbIntersectingAabb;\nexport const __wbg_rawdeserializedworld_free = instance.exports.__wbg_rawdeserializedworld_free;\nexport const rawdeserializedworld_takeGravity = instance.exports.rawdeserializedworld_takeGravity;\nexport const rawdeserializedworld_takeIntegrationParameters = instance.exports.rawdeserializedworld_takeIntegrationParameters;\nexport const rawdeserializedworld_takeIslandManager = instance.exports.rawdeserializedworld_takeIslandManager;\nexport const rawdeserializedworld_takeBroadPhase = instance.exports.rawdeserializedworld_takeBroadPhase;\nexport const rawdeserializedworld_takeNarrowPhase = instance.exports.rawdeserializedworld_takeNarrowPhase;\nexport const rawdeserializedworld_takeBodies = instance.exports.rawdeserializedworld_takeBodies;\nexport const rawdeserializedworld_takeColliders = instance.exports.rawdeserializedworld_takeColliders;\nexport const rawdeserializedworld_takeImpulseJoints = instance.exports.rawdeserializedworld_takeImpulseJoints;\nexport const rawdeserializedworld_takeMultibodyJoints = instance.exports.rawdeserializedworld_takeMultibodyJoints;\nexport const rawserializationpipeline_serializeAll = instance.exports.rawserializationpipeline_serializeAll;\nexport const rawserializationpipeline_deserializeAll = instance.exports.rawserializationpipeline_deserializeAll;\nexport const rawintegrationparameters_set_minIslandSize = instance.exports.rawintegrationparameters_set_minIslandSize;\nexport const rawintegrationparameters_set_maxCcdSubsteps = instance.exports.rawintegrationparameters_set_maxCcdSubsteps;\nexport const rawvector_set_x = instance.exports.rawvector_set_x;\nexport const rawvector_set_z = instance.exports.rawvector_set_z;\nexport const rawintegrationparameters_minIslandSize = instance.exports.rawintegrationparameters_minIslandSize;\nexport const rawintegrationparameters_maxCcdSubsteps = instance.exports.rawintegrationparameters_maxCcdSubsteps;\nexport const rawrigidbodyset_len = instance.exports.rawrigidbodyset_len;\nexport const rawshapecontact_distance = instance.exports.rawshapecontact_distance;\nexport const rawrayintersection_toi = instance.exports.rawrayintersection_toi;\nexport const rawrayintersection_featureType = instance.exports.rawrayintersection_featureType;\nexport const rawraycolliderintersection_colliderHandle = instance.exports.rawraycolliderintersection_colliderHandle;\nexport const rawraycolliderintersection_toi = instance.exports.rawraycolliderintersection_toi;\nexport const rawraycolliderintersection_featureType = instance.exports.rawraycolliderintersection_featureType;\nexport const rawraycollidertoi_colliderHandle = instance.exports.rawraycollidertoi_colliderHandle;\nexport const rawraycollidertoi_toi = instance.exports.rawraycollidertoi_toi;\nexport const rawshapetoi_toi = instance.exports.rawshapetoi_toi;\nexport const rawshapecollidertoi_colliderHandle = instance.exports.rawshapecollidertoi_colliderHandle;\nexport const rawshapecollidertoi_toi = instance.exports.rawshapecollidertoi_toi;\nexport const rawrotation_x = instance.exports.rawrotation_x;\nexport const rawrotation_y = instance.exports.rawrotation_y;\nexport const rawrotation_z = instance.exports.rawrotation_z;\nexport const rawvector_x = instance.exports.rawvector_x;\nexport const rawvector_y = instance.exports.rawvector_y;\nexport const rawvector_z = instance.exports.rawvector_z;\nexport const rawcontactforceevent_collider1 = instance.exports.rawcontactforceevent_collider1;\nexport const rawkinematiccharactercontroller_up = instance.exports.rawkinematiccharactercontroller_up;\nexport const rawshapecontact_normal2 = instance.exports.rawshapecontact_normal2;\nexport const rawshapecontact_point1 = instance.exports.rawshapecontact_point1;\nexport const rawshapecontact_point2 = instance.exports.rawshapecontact_point2;\nexport const rawrayintersection_normal = instance.exports.rawrayintersection_normal;\nexport const rawshapecollidertoi_witness1 = instance.exports.rawshapecollidertoi_witness1;\nexport const rawshapecontact_normal1 = instance.exports.rawshapecontact_normal1;\nexport const rawshapecollidertoi_normal1 = instance.exports.rawshapecollidertoi_normal1;\nexport const rawshapecollidertoi_normal2 = instance.exports.rawshapecollidertoi_normal2;\nexport const rawshapetoi_witness2 = instance.exports.rawshapetoi_witness2;\nexport const rawserializationpipeline_new = instance.exports.rawserializationpipeline_new;\nexport const rawrayintersection_featureId = instance.exports.rawrayintersection_featureId;\nexport const rawraycolliderintersection_featureId = instance.exports.rawraycolliderintersection_featureId;\nexport const __wbg_rawserializationpipeline_free = instance.exports.__wbg_rawserializationpipeline_free;\nexport const __wbg_rawcontactpair_free = instance.exports.__wbg_rawcontactpair_free;\nexport const __wbg_rawraycolliderintersection_free = instance.exports.__wbg_rawraycolliderintersection_free;\nexport const __wbg_rawrotation_free = instance.exports.__wbg_rawrotation_free;\nexport const __wbg_rawvector_free = instance.exports.__wbg_rawvector_free;\nexport const __wbg_rawsdpmatrix3_free = instance.exports.__wbg_rawsdpmatrix3_free;\nexport const rawcolliderset_isHandleValid = instance.exports.rawcolliderset_isHandleValid;\nexport const __wbindgen_add_to_stack_pointer = instance.exports.__wbindgen_add_to_stack_pointer;\nexport const __wbindgen_free = instance.exports.__wbindgen_free;\nexport const __wbindgen_malloc = instance.exports.__wbindgen_malloc;\nexport const __wbindgen_exn_store = instance.exports.__wbindgen_exn_store;\n    ", "import {RawVector, RawRotation} from \"./raw\";\n// #if DIM3\nimport {RawSdpMatrix3} from \"./raw\";\n// #endif\n\n\n// #if DIM3\nexport interface Vector {\n    x: number;\n    y: number;\n    z: number;\n}\n\n/**\n * A 3D vector.\n */\nexport class Vector3 implements Vector {\n    x: number;\n    y: number;\n    z: number;\n\n    constructor(x: number, y: number, z: number) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n}\n\nexport class VectorOps {\n    public static new(x: number, y: number, z: number): Vector {\n        return new Vector3(x, y, z);\n    }\n\n    public static intoRaw(v: Vector): RawVector {\n        return new RawVector(v.x, v.y, v.z);\n    }\n\n    public static zeros(): Vector {\n        return VectorOps.new(0.0, 0.0, 0.0);\n    }\n\n    // FIXME: type ram: RawVector?\n    public static fromRaw(raw: RawVector): Vector {\n        if (!raw) return null;\n\n        let res = VectorOps.new(raw.x, raw.y, raw.z);\n        raw.free();\n        return res;\n    }\n\n    public static copy(out: Vector, input: Vector) {\n        out.x = input.x;\n        out.y = input.y;\n        out.z = input.z;\n    }\n}\n\nexport interface Rotation {\n    x: number;\n    y: number;\n    z: number;\n    w: number;\n}\n\n/**\n * A quaternion.\n */\nexport class Quaternion implements Rotation {\n    x: number;\n    y: number;\n    z: number;\n    w: number;\n\n    constructor(x: number, y: number, z: number, w: number) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.w = w;\n    }\n}\n\nexport class RotationOps {\n    public static identity(): Rotation {\n        return new Quaternion(0.0, 0.0, 0.0, 1.0);\n    }\n\n    public static fromRaw(raw: RawRotation): Rotation {\n        if (!raw) return null;\n\n        let res = new Quaternion(raw.x, raw.y, raw.z, raw.w);\n        raw.free();\n        return res;\n    }\n\n    public static intoRaw(rot: Rotation): RawRotation {\n        return new RawRotation(rot.x, rot.y, rot.z, rot.w);\n    }\n\n    public static copy(out: Rotation, input: Rotation) {\n        out.x = input.x;\n        out.y = input.y;\n        out.z = input.z;\n        out.w = input.w;\n    }\n}\n\n/**\n * A 3D symmetric-positive-definite matrix.\n */\nexport class SdpMatrix3 {\n    /**\n     * Row major list of the upper-triangular part of the symmetric matrix.\n     */\n    elements: Float32Array;\n\n    /**\n     * Matrix element at row 1, column 1.\n     */\n    public get m11(): number {\n        return this.elements[0];\n    }\n\n    /**\n     * Matrix element at row 1, column 2.\n     */\n    public get m12(): number {\n        return this.elements[1];\n    }\n\n    /**\n     * Matrix element at row 2, column 1.\n     */\n    public get m21(): number {\n        return this.m12;\n    }\n\n    /**\n     * Matrix element at row 1, column 3.\n     */\n    public get m13(): number {\n        return this.elements[2];\n    }\n\n    /**\n     * Matrix element at row 3, column 1.\n     */\n    public get m31(): number {\n        return this.m13;\n    }\n\n    /**\n     * Matrix element at row 2, column 2.\n     */\n    public get m22(): number {\n        return this.elements[3];\n    }\n\n    /**\n     * Matrix element at row 2, column 3.\n     */\n    public get m23(): number {\n        return this.elements[4];\n    }\n\n    /**\n     * Matrix element at row 3, column 2.\n     */\n    public get m32(): number {\n        return this.m23;\n    }\n\n    /**\n     * Matrix element at row 3, column 3.\n     */\n    public get m33(): number {\n        return this.elements[5];\n    }\n\n    constructor(elements: Float32Array) {\n        this.elements = elements;\n    }\n}\n\nexport class SdpMatrix3Ops {\n    public static fromRaw(raw: RawSdpMatrix3): SdpMatrix3 {\n        const sdpMatrix3 = new SdpMatrix3(raw.elements());\n        raw.free();\n        return sdpMatrix3;\n    }\n}\n\n// #endif\n", "import {RawRigidBodySet} from \"../raw\";\nimport {Rotation, RotationOps, Vector, VectorOps} from \"../math\";\n// #if DIM3\nimport {SdpMatrix3, SdpMatrix3Ops} from \"../math\";\n// #endif\nimport {Collider, ColliderSet} from \"../geometry\";\n\n/**\n * The integer identifier of a collider added to a `ColliderSet`.\n */\nexport type RigidBodyHandle = number;\n\n/**\n * The simulation status of a rigid-body.\n */\n// TODO: rename this to RigidBodyType\nexport enum RigidBodyType {\n    /**\n     * A `RigidBodyType::Dynamic` body can be affected by all external forces.\n     */\n    Dynamic = 0,\n    /**\n     * A `RigidBodyType::Fixed` body cannot be affected by external forces.\n     */\n    Fixed,\n    /**\n     * A `RigidBodyType::KinematicPositionBased` body cannot be affected by any external forces but can be controlled\n     * by the user at the position level while keeping realistic one-way interaction with dynamic bodies.\n     *\n     * One-way interaction means that a kinematic body can push a dynamic body, but a kinematic body\n     * cannot be pushed by anything. In other words, the trajectory of a kinematic body can only be\n     * modified by the user and is independent from any contact or joint it is involved in.\n     */\n    KinematicPositionBased,\n    /**\n     * A `RigidBodyType::KinematicVelocityBased` body cannot be affected by any external forces but can be controlled\n     * by the user at the velocity level while keeping realistic one-way interaction with dynamic bodies.\n     *\n     * One-way interaction means that a kinematic body can push a dynamic body, but a kinematic body\n     * cannot be pushed by anything. In other words, the trajectory of a kinematic body can only be\n     * modified by the user and is independent from any contact or joint it is involved in.\n     */\n    KinematicVelocityBased,\n}\n\n/**\n * A rigid-body.\n */\nexport class RigidBody {\n    private rawSet: RawRigidBodySet; // The RigidBody won't need to free this.\n    private colliderSet: ColliderSet;\n    readonly handle: RigidBodyHandle;\n\n    /**\n     * An arbitrary user-defined object associated with this rigid-body.\n     */\n    public userData?: unknown;\n\n    constructor(\n        rawSet: RawRigidBodySet,\n        colliderSet: ColliderSet,\n        handle: RigidBodyHandle,\n    ) {\n        this.rawSet = rawSet;\n        this.colliderSet = colliderSet;\n        this.handle = handle;\n    }\n\n    /** @internal */\n    public finalizeDeserialization(colliderSet: ColliderSet) {\n        this.colliderSet = colliderSet;\n    }\n\n    /**\n     * Checks if this rigid-body is still valid (i.e. that it has\n     * not been deleted from the rigid-body set yet.\n     */\n    public isValid(): boolean {\n        return this.rawSet.contains(this.handle);\n    }\n\n    /**\n     * Locks or unlocks the ability of this rigid-body to translate.\n     *\n     * @param locked - If `true`, this rigid-body will no longer translate due to forces and impulses.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     */\n    public lockTranslations(locked: boolean, wakeUp: boolean) {\n        return this.rawSet.rbLockTranslations(this.handle, locked, wakeUp);\n    }\n\n    /**\n     * Locks or unlocks the ability of this rigid-body to rotate.\n     *\n     * @param locked - If `true`, this rigid-body will no longer rotate due to torques and impulses.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     */\n    public lockRotations(locked: boolean, wakeUp: boolean) {\n        return this.rawSet.rbLockRotations(this.handle, locked, wakeUp);\n    }\n\n    // #if DIM3\n    /**\n     * Locks or unlocks the ability of this rigid-body to translate along individual coordinate axes.\n     *\n     * @param enableX - If `false`, this rigid-body will no longer translate due to torques and impulses, along the X coordinate axis.\n     * @param enableY - If `false`, this rigid-body will no longer translate due to torques and impulses, along the Y coordinate axis.\n     * @param enableZ - If `false`, this rigid-body will no longer translate due to torques and impulses, along the Z coordinate axis.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     */\n    public setEnabledTranslations(\n        enableX: boolean,\n        enableY: boolean,\n        enableZ: boolean,\n        wakeUp: boolean,\n    ) {\n        return this.rawSet.rbSetEnabledTranslations(\n            this.handle,\n            enableX,\n            enableY,\n            enableZ,\n            wakeUp,\n        );\n    }\n\n    /**\n     * Locks or unlocks the ability of this rigid-body to translate along individual coordinate axes.\n     *\n     * @param enableX - If `false`, this rigid-body will no longer translate due to torques and impulses, along the X coordinate axis.\n     * @param enableY - If `false`, this rigid-body will no longer translate due to torques and impulses, along the Y coordinate axis.\n     * @param enableZ - If `false`, this rigid-body will no longer translate due to torques and impulses, along the Z coordinate axis.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     * @deprecated use `this.setEnabledTranslations` with the same arguments instead.\n     */\n    public restrictTranslations(\n        enableX: boolean,\n        enableY: boolean,\n        enableZ: boolean,\n        wakeUp: boolean,\n    ) {\n        this.setEnabledTranslations(enableX, enableY, enableZ, wakeUp);\n    }\n\n    /**\n     * Locks or unlocks the ability of this rigid-body to rotate along individual coordinate axes.\n     *\n     * @param enableX - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the X coordinate axis.\n     * @param enableY - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the Y coordinate axis.\n     * @param enableZ - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the Z coordinate axis.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     */\n    public setEnabledRotations(\n        enableX: boolean,\n        enableY: boolean,\n        enableZ: boolean,\n        wakeUp: boolean,\n    ) {\n        return this.rawSet.rbSetEnabledRotations(\n            this.handle,\n            enableX,\n            enableY,\n            enableZ,\n            wakeUp,\n        );\n    }\n\n    /**\n     * Locks or unlocks the ability of this rigid-body to rotate along individual coordinate axes.\n     *\n     * @param enableX - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the X coordinate axis.\n     * @param enableY - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the Y coordinate axis.\n     * @param enableZ - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the Z coordinate axis.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     * @deprecated use `this.setEnabledRotations` with the same arguments instead.\n     */\n    public restrictRotations(\n        enableX: boolean,\n        enableY: boolean,\n        enableZ: boolean,\n        wakeUp: boolean,\n    ) {\n        this.setEnabledRotations(enableX, enableY, enableZ, wakeUp);\n    }\n    // #endif\n\n    /**\n     * The dominance group, in [-127, +127] this rigid-body is part of.\n     */\n    public dominanceGroup(): number {\n        return this.rawSet.rbDominanceGroup(this.handle);\n    }\n\n    /**\n     * Sets the dominance group of this rigid-body.\n     *\n     * @param group - The dominance group of this rigid-body. Must be a signed integer in the range [-127, +127].\n     */\n    public setDominanceGroup(group: number) {\n        this.rawSet.rbSetDominanceGroup(this.handle, group);\n    }\n\n    /**\n     * Enable or disable CCD (Continuous Collision Detection) for this rigid-body.\n     *\n     * @param enabled - If `true`, CCD will be enabled for this rigid-body.\n     */\n    public enableCcd(enabled: boolean) {\n        this.rawSet.rbEnableCcd(this.handle, enabled);\n    }\n\n    /**\n     * The world-space translation of this rigid-body.\n     */\n    public translation(): Vector {\n        let res = this.rawSet.rbTranslation(this.handle);\n        return VectorOps.fromRaw(res);\n    }\n\n    /**\n     * The world-space orientation of this rigid-body.\n     */\n    public rotation(): Rotation {\n        let res = this.rawSet.rbRotation(this.handle);\n        return RotationOps.fromRaw(res);\n    }\n\n    /**\n     * The world-space next translation of this rigid-body.\n     *\n     * If this rigid-body is kinematic this value is set by the `setNextKinematicTranslation`\n     * method and is used for estimating the kinematic body velocity at the next timestep.\n     * For non-kinematic bodies, this value is currently unspecified.\n     */\n    public nextTranslation(): Vector {\n        let res = this.rawSet.rbNextTranslation(this.handle);\n        return VectorOps.fromRaw(res);\n    }\n\n    /**\n     * The world-space next orientation of this rigid-body.\n     *\n     * If this rigid-body is kinematic this value is set by the `setNextKinematicRotation`\n     * method and is used for estimating the kinematic body velocity at the next timestep.\n     * For non-kinematic bodies, this value is currently unspecified.\n     */\n    public nextRotation(): Rotation {\n        let res = this.rawSet.rbNextRotation(this.handle);\n        return RotationOps.fromRaw(res);\n    }\n\n    /**\n     * Sets the translation of this rigid-body.\n     *\n     * @param tra - The world-space position of the rigid-body.\n     * @param wakeUp - Forces the rigid-body to wake-up so it is properly affected by forces if it\n     *                 wasn't moving before modifying its position.\n     */\n    public setTranslation(tra: Vector, wakeUp: boolean) {\n        // #if DIM3\n        this.rawSet.rbSetTranslation(this.handle, tra.x, tra.y, tra.z, wakeUp);\n        // #endif\n    }\n\n    /**\n     * Sets the linear velocity of this rigid-body.\n     *\n     * @param vel - The linear velocity to set.\n     * @param wakeUp - Forces the rigid-body to wake-up if it was asleep.\n     */\n    public setLinvel(vel: Vector, wakeUp: boolean) {\n        let rawVel = VectorOps.intoRaw(vel);\n        this.rawSet.rbSetLinvel(this.handle, rawVel, wakeUp);\n        rawVel.free();\n    }\n\n    /**\n     * The scale factor applied to the gravity affecting\n     * this rigid-body.\n     */\n    public gravityScale(): number {\n        return this.rawSet.rbGravityScale(this.handle);\n    }\n\n    /**\n     * Sets the scale factor applied to the gravity affecting\n     * this rigid-body.\n     *\n     * @param factor - The scale factor to set. A value of 0.0 means\n     *   that this rigid-body will on longer be affected by gravity.\n     * @param wakeUp - Forces the rigid-body to wake-up if it was asleep.\n     */\n    public setGravityScale(factor: number, wakeUp: boolean) {\n        this.rawSet.rbSetGravityScale(this.handle, factor, wakeUp);\n    }\n\n    // #if DIM3\n    /**\n     * Sets the rotation quaternion of this rigid-body.\n     *\n     * This does nothing if a zero quaternion is provided.\n     *\n     * @param rotation - The rotation to set.\n     * @param wakeUp - Forces the rigid-body to wake-up so it is properly affected by forces if it\n     * wasn't moving before modifying its position.\n     */\n    public setRotation(rot: Rotation, wakeUp: boolean) {\n        this.rawSet.rbSetRotation(\n            this.handle,\n            rot.x,\n            rot.y,\n            rot.z,\n            rot.w,\n            wakeUp,\n        );\n    }\n\n    /**\n     * Sets the angular velocity fo this rigid-body.\n     *\n     * @param vel - The angular velocity to set.\n     * @param wakeUp - Forces the rigid-body to wake-up if it was asleep.\n     */\n    public setAngvel(vel: Vector, wakeUp: boolean) {\n        let rawVel = VectorOps.intoRaw(vel);\n        this.rawSet.rbSetAngvel(this.handle, rawVel, wakeUp);\n        rawVel.free();\n    }\n\n    // #endif\n\n\n    /**\n     * If this rigid body is kinematic, sets its future translation after the next timestep integration.\n     *\n     * This should be used instead of `rigidBody.setTranslation` to make the dynamic object\n     * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n     * an artificial velocity for this rigid-body from its current position and its next kinematic\n     * position. This velocity will be used to compute forces on dynamic bodies interacting with\n     * this body.\n     *\n     * @param t - The kinematic translation to set.\n     */\n    public setNextKinematicTranslation(t: Vector) {\n        // #if DIM3\n        this.rawSet.rbSetNextKinematicTranslation(this.handle, t.x, t.y, t.z);\n        // #endif\n    }\n\n    // #if DIM3\n    /**\n     * If this rigid body is kinematic, sets its future rotation after the next timestep integration.\n     *\n     * This should be used instead of `rigidBody.setRotation` to make the dynamic object\n     * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n     * an artificial velocity for this rigid-body from its current position and its next kinematic\n     * position. This velocity will be used to compute forces on dynamic bodies interacting with\n     * this body.\n     *\n     * @param rot - The kinematic rotation to set.\n     */\n    public setNextKinematicRotation(rot: Rotation) {\n        this.rawSet.rbSetNextKinematicRotation(\n            this.handle,\n            rot.x,\n            rot.y,\n            rot.z,\n            rot.w,\n        );\n    }\n\n    // #endif\n\n\n    /**\n     * The linear velocity of this rigid-body.\n     */\n    public linvel(): Vector {\n        return VectorOps.fromRaw(this.rawSet.rbLinvel(this.handle));\n    }\n\n    // #if DIM3\n    /**\n     * The angular velocity of this rigid-body.\n     */\n    public angvel(): Vector {\n        return VectorOps.fromRaw(this.rawSet.rbAngvel(this.handle));\n    }\n\n    // #endif\n\n\n    /**\n     * The mass of this rigid-body.\n     */\n    public mass(): number {\n        return this.rawSet.rbMass(this.handle);\n    }\n\n    /**\n     * The inverse mass taking into account translation locking.\n     */\n    public effectiveInvMass(): Vector {\n        return VectorOps.fromRaw(this.rawSet.rbEffectiveInvMass(this.handle));\n    }\n\n    /**\n     * The inverse of the mass of a rigid-body.\n     *\n     * If this is zero, the rigid-body is assumed to have infinite mass.\n     */\n    public invMass(): number {\n        return this.rawSet.rbInvMass(this.handle);\n    }\n\n    /**\n     * The center of mass of a rigid-body expressed in its local-space.\n     */\n    public localCom(): Vector {\n        return VectorOps.fromRaw(this.rawSet.rbLocalCom(this.handle));\n    }\n\n    /**\n     * The world-space center of mass of the rigid-body.\n     */\n    public worldCom(): Vector {\n        return VectorOps.fromRaw(this.rawSet.rbWorldCom(this.handle));\n    }\n\n\n    // #if DIM3\n    /**\n     * The inverse of the principal angular inertia of the rigid-body.\n     *\n     * Components set to zero are assumed to be infinite along the corresponding principal axis.\n     */\n    public invPrincipalInertiaSqrt(): Vector {\n        return VectorOps.fromRaw(\n            this.rawSet.rbInvPrincipalInertiaSqrt(this.handle),\n        );\n    }\n    // #endif\n\n\n    // #if DIM3\n    /**\n     * The angular inertia along the principal inertia axes of the rigid-body.\n     */\n    public principalInertia(): Vector {\n        return VectorOps.fromRaw(this.rawSet.rbPrincipalInertia(this.handle));\n    }\n    // #endif\n\n    // #if DIM3\n    /**\n     * The principal vectors of the local angular inertia tensor of the rigid-body.\n     */\n    public principalInertiaLocalFrame(): Rotation {\n        return RotationOps.fromRaw(\n            this.rawSet.rbPrincipalInertiaLocalFrame(this.handle),\n        );\n    }\n    // #endif\n\n\n    // #if DIM3\n    /**\n     * The square-root of the world-space inverse angular inertia tensor of the rigid-body,\n     * taking into account rotation locking.\n     */\n    public effectiveWorldInvInertiaSqrt(): SdpMatrix3 {\n        return SdpMatrix3Ops.fromRaw(\n            this.rawSet.rbEffectiveWorldInvInertiaSqrt(this.handle),\n        );\n    }\n    // #endif\n\n\n    // #if DIM3\n    /**\n     * The effective world-space angular inertia (that takes the potential rotation locking into account) of\n     * this rigid-body.\n     */\n    public effectiveAngularInertia(): SdpMatrix3 {\n        return SdpMatrix3Ops.fromRaw(\n            this.rawSet.rbEffectiveAngularInertia(this.handle),\n        );\n    }\n    // #endif\n\n    /**\n     * Put this rigid body to sleep.\n     *\n     * A sleeping body no longer moves and is no longer simulated by the physics engine unless\n     * it is waken up. It can be woken manually with `this.wakeUp()` or automatically due to\n     * external forces like contacts.\n     */\n    public sleep() {\n        this.rawSet.rbSleep(this.handle);\n    }\n\n    /**\n     * Wakes this rigid-body up.\n     *\n     * A dynamic rigid-body that does not move during several consecutive frames will\n     * be put to sleep by the physics engine, i.e., it will stop being simulated in order\n     * to avoid useless computations.\n     * This methods forces a sleeping rigid-body to wake-up. This is useful, e.g., before modifying\n     * the position of a dynamic body so that it is properly simulated afterwards.\n     */\n    public wakeUp() {\n        this.rawSet.rbWakeUp(this.handle);\n    }\n\n    /**\n     * Is CCD enabled for this rigid-body?\n     */\n    public isCcdEnabled(): boolean {\n        return this.rawSet.rbIsCcdEnabled(this.handle);\n    }\n\n    /**\n     * The number of colliders attached to this rigid-body.\n     */\n    public numColliders(): number {\n        return this.rawSet.rbNumColliders(this.handle);\n    }\n\n    /**\n     * Retrieves the `i-th` collider attached to this rigid-body.\n     *\n     * @param i - The index of the collider to retrieve. Must be a number in `[0, this.numColliders()[`.\n     *         This index is **not** the same as the unique identifier of the collider.\n     */\n    public collider(i: number): Collider {\n        return this.colliderSet.get(this.rawSet.rbCollider(this.handle, i));\n    }\n\n    /**\n     * Sets whether this rigid-body is enabled or not.\n     *\n     * @param enabled - Set to `false` to disable this rigid-body and all its attached colliders.\n     */\n    public setEnabled(enabled: boolean) {\n        this.rawSet.rbSetEnabled(this.handle, enabled);\n    }\n\n    /**\n     * Is this rigid-body enabled?\n     */\n    public isEnabled(): boolean {\n        return this.rawSet.rbIsEnabled(this.handle);\n    }\n\n    /**\n     * The status of this rigid-body: static, dynamic, or kinematic.\n     */\n    public bodyType(): RigidBodyType {\n        return this.rawSet.rbBodyType(this.handle);\n    }\n\n    /**\n     * Set a new status for this rigid-body: static, dynamic, or kinematic.\n     */\n    public setBodyType(type: RigidBodyType, wakeUp: boolean) {\n        return this.rawSet.rbSetBodyType(this.handle, type, wakeUp);\n    }\n\n    /**\n     * Is this rigid-body sleeping?\n     */\n    public isSleeping(): boolean {\n        return this.rawSet.rbIsSleeping(this.handle);\n    }\n\n    /**\n     * Is the velocity of this rigid-body not zero?\n     */\n    public isMoving(): boolean {\n        return this.rawSet.rbIsMoving(this.handle);\n    }\n\n    /**\n     * Is this rigid-body static?\n     */\n    public isFixed(): boolean {\n        return this.rawSet.rbIsFixed(this.handle);\n    }\n\n    /**\n     * Is this rigid-body kinematic?\n     */\n    public isKinematic(): boolean {\n        return this.rawSet.rbIsKinematic(this.handle);\n    }\n\n    /**\n     * Is this rigid-body dynamic?\n     */\n    public isDynamic(): boolean {\n        return this.rawSet.rbIsDynamic(this.handle);\n    }\n\n    /**\n     * The linear damping coefficient of this rigid-body.\n     */\n    public linearDamping(): number {\n        return this.rawSet.rbLinearDamping(this.handle);\n    }\n\n    /**\n     * The angular damping coefficient of this rigid-body.\n     */\n    public angularDamping(): number {\n        return this.rawSet.rbAngularDamping(this.handle);\n    }\n\n    /**\n     * Sets the linear damping factor applied to this rigid-body.\n     *\n     * @param factor - The damping factor to set.\n     */\n    public setLinearDamping(factor: number) {\n        this.rawSet.rbSetLinearDamping(this.handle, factor);\n    }\n\n    /**\n     * Recompute the mass-properties of this rigid-bodies based on its currently attached colliders.\n     */\n    public recomputeMassPropertiesFromColliders() {\n        this.rawSet.rbRecomputeMassPropertiesFromColliders(\n            this.handle,\n            this.colliderSet.raw,\n        );\n    }\n\n    /**\n     * Sets the rigid-body's additional mass.\n     *\n     * The total angular inertia of the rigid-body will be scaled automatically based on this additional mass. If this\n     * scaling effect isn\u2019t desired, use Self::additional_mass_properties instead of this method.\n     *\n     * This is only the \"additional\" mass because the total mass of the rigid-body is equal to the sum of this\n     * additional mass and the mass computed from the colliders (with non-zero densities) attached to this rigid-body.\n     *\n     * That total mass (which includes the attached colliders\u2019 contributions) will be updated at the name physics step,\n     * or can be updated manually with `this.recomputeMassPropertiesFromColliders`.\n     *\n     * This will override any previous additional mass-properties set by `this.setAdditionalMass`,\n     * `this.setAdditionalMassProperties`, `RigidBodyDesc::setAdditionalMass`, or\n     * `RigidBodyDesc.setAdditionalMassfProperties` for this rigid-body.\n     *\n     * @param mass - The additional mass to set.\n     * @param wakeUp - If `true` then the rigid-body will be woken up if it was put to sleep because it did not move for a while.\n     */\n    public setAdditionalMass(mass: number, wakeUp: boolean) {\n        this.rawSet.rbSetAdditionalMass(this.handle, mass, wakeUp);\n    }\n\n    // #if DIM3\n    /**\n     * Sets the rigid-body's additional mass-properties.\n     *\n     * This is only the \"additional\" mass-properties because the total mass-properties of the rigid-body is equal to the\n     * sum of this additional mass-properties and the mass computed from the colliders (with non-zero densities) attached\n     * to this rigid-body.\n     *\n     * That total mass-properties (which include the attached colliders\u2019 contributions) will be updated at the name\n     * physics step, or can be updated manually with `this.recomputeMassPropertiesFromColliders`.\n     *\n     * This will override any previous mass-properties set by `this.setAdditionalMass`,\n     * `this.setAdditionalMassProperties`, `RigidBodyDesc.setAdditionalMass`, or `RigidBodyDesc.setAdditionalMassProperties`\n     * for this rigid-body.\n     *\n     * If `wake_up` is true then the rigid-body will be woken up if it was put to sleep because it did not move for a while.\n     */\n    public setAdditionalMassProperties(\n        mass: number,\n        centerOfMass: Vector,\n        principalAngularInertia: Vector,\n        angularInertiaLocalFrame: Rotation,\n        wakeUp: boolean,\n    ) {\n        let rawCom = VectorOps.intoRaw(centerOfMass);\n        let rawPrincipalInertia = VectorOps.intoRaw(principalAngularInertia);\n        let rawInertiaFrame = RotationOps.intoRaw(angularInertiaLocalFrame);\n\n        this.rawSet.rbSetAdditionalMassProperties(\n            this.handle,\n            mass,\n            rawCom,\n            rawPrincipalInertia,\n            rawInertiaFrame,\n            wakeUp,\n        );\n\n        rawCom.free();\n        rawPrincipalInertia.free();\n        rawInertiaFrame.free();\n    }\n    // #endif\n\n\n    /**\n     * Sets the linear damping factor applied to this rigid-body.\n     *\n     * @param factor - The damping factor to set.\n     */\n    public setAngularDamping(factor: number) {\n        this.rawSet.rbSetAngularDamping(this.handle, factor);\n    }\n\n    /**\n     * Resets to zero the user forces (but not torques) applied to this rigid-body.\n     *\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    public resetForces(wakeUp: boolean) {\n        this.rawSet.rbResetForces(this.handle, wakeUp);\n    }\n\n    /**\n     * Resets to zero the user torques applied to this rigid-body.\n     *\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    public resetTorques(wakeUp: boolean) {\n        this.rawSet.rbResetTorques(this.handle, wakeUp);\n    }\n\n    /**\n     * Adds a force at the center-of-mass of this rigid-body.\n     *\n     * @param force - the world-space force to add to the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    public addForce(force: Vector, wakeUp: boolean) {\n        const rawForce = VectorOps.intoRaw(force);\n        this.rawSet.rbAddForce(this.handle, rawForce, wakeUp);\n        rawForce.free();\n    }\n\n    /**\n     * Applies an impulse at the center-of-mass of this rigid-body.\n     *\n     * @param impulse - the world-space impulse to apply on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    public applyImpulse(impulse: Vector, wakeUp: boolean) {\n        const rawImpulse = VectorOps.intoRaw(impulse);\n        this.rawSet.rbApplyImpulse(this.handle, rawImpulse, wakeUp);\n        rawImpulse.free();\n    }\n\n\n    // #if DIM3\n    /**\n     * Adds a torque at the center-of-mass of this rigid-body.\n     *\n     * @param torque - the world-space torque to add to the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    public addTorque(torque: Vector, wakeUp: boolean) {\n        const rawTorque = VectorOps.intoRaw(torque);\n        this.rawSet.rbAddTorque(this.handle, rawTorque, wakeUp);\n        rawTorque.free();\n    }\n\n    // #endif\n\n\n    // #if DIM3\n    /**\n     * Applies an impulsive torque at the center-of-mass of this rigid-body.\n     *\n     * @param torqueImpulse - the world-space torque impulse to apply on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    public applyTorqueImpulse(torqueImpulse: Vector, wakeUp: boolean) {\n        const rawTorqueImpulse = VectorOps.intoRaw(torqueImpulse);\n        this.rawSet.rbApplyTorqueImpulse(this.handle, rawTorqueImpulse, wakeUp);\n        rawTorqueImpulse.free();\n    }\n\n    // #endif\n\n    /**\n     * Adds a force at the given world-space point of this rigid-body.\n     *\n     * @param force - the world-space force to add to the rigid-body.\n     * @param point - the world-space point where the impulse is to be applied on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    public addForceAtPoint(force: Vector, point: Vector, wakeUp: boolean) {\n        const rawForce = VectorOps.intoRaw(force);\n        const rawPoint = VectorOps.intoRaw(point);\n        this.rawSet.rbAddForceAtPoint(this.handle, rawForce, rawPoint, wakeUp);\n        rawForce.free();\n        rawPoint.free();\n    }\n\n    /**\n     * Applies an impulse at the given world-space point of this rigid-body.\n     *\n     * @param impulse - the world-space impulse to apply on the rigid-body.\n     * @param point - the world-space point where the impulse is to be applied on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    public applyImpulseAtPoint(\n        impulse: Vector,\n        point: Vector,\n        wakeUp: boolean,\n    ) {\n        const rawImpulse = VectorOps.intoRaw(impulse);\n        const rawPoint = VectorOps.intoRaw(point);\n        this.rawSet.rbApplyImpulseAtPoint(\n            this.handle,\n            rawImpulse,\n            rawPoint,\n            wakeUp,\n        );\n        rawImpulse.free();\n        rawPoint.free();\n    }\n}\n\nexport class RigidBodyDesc {\n    enabled: boolean;\n    translation: Vector;\n    rotation: Rotation;\n    gravityScale: number;\n    mass: number;\n    massOnly: boolean;\n    centerOfMass: Vector;\n    translationsEnabledX: boolean;\n    translationsEnabledY: boolean;\n    linvel: Vector;\n    // #if DIM3\n    angvel: Vector;\n    principalAngularInertia: Vector;\n    angularInertiaLocalFrame: Rotation;\n    translationsEnabledZ: boolean;\n    rotationsEnabledX: boolean;\n    rotationsEnabledY: boolean;\n    rotationsEnabledZ: boolean;\n    // #endif\n    linearDamping: number;\n    angularDamping: number;\n    status: RigidBodyType;\n    canSleep: boolean;\n    sleeping: boolean;\n    ccdEnabled: boolean;\n    dominanceGroup: number;\n    userData?: unknown;\n\n    constructor(status: RigidBodyType) {\n        this.enabled = true;\n        this.status = status;\n        this.translation = VectorOps.zeros();\n        this.rotation = RotationOps.identity();\n        this.gravityScale = 1.0;\n        this.linvel = VectorOps.zeros();\n        this.mass = 0.0;\n        this.massOnly = false;\n        this.centerOfMass = VectorOps.zeros();\n        this.translationsEnabledX = true;\n        this.translationsEnabledY = true;\n        // #if DIM3\n        this.angvel = VectorOps.zeros();\n        this.principalAngularInertia = VectorOps.zeros();\n        this.angularInertiaLocalFrame = RotationOps.identity();\n        this.translationsEnabledZ = true;\n        this.rotationsEnabledX = true;\n        this.rotationsEnabledY = true;\n        this.rotationsEnabledZ = true;\n        // #endif\n        this.linearDamping = 0.0;\n        this.angularDamping = 0.0;\n        this.canSleep = true;\n        this.sleeping = false;\n        this.ccdEnabled = false;\n        this.dominanceGroup = 0;\n    }\n\n    /**\n     * A rigid-body descriptor used to build a dynamic rigid-body.\n     */\n    public static dynamic(): RigidBodyDesc {\n        return new RigidBodyDesc(RigidBodyType.Dynamic);\n    }\n\n    /**\n     * A rigid-body descriptor used to build a position-based kinematic rigid-body.\n     */\n    public static kinematicPositionBased(): RigidBodyDesc {\n        return new RigidBodyDesc(RigidBodyType.KinematicPositionBased);\n    }\n\n    /**\n     * A rigid-body descriptor used to build a velocity-based kinematic rigid-body.\n     */\n    public static kinematicVelocityBased(): RigidBodyDesc {\n        return new RigidBodyDesc(RigidBodyType.KinematicVelocityBased);\n    }\n\n    /**\n     * A rigid-body descriptor used to build a fixed rigid-body.\n     */\n    public static fixed(): RigidBodyDesc {\n        return new RigidBodyDesc(RigidBodyType.Fixed);\n    }\n\n    /**\n     * A rigid-body descriptor used to build a dynamic rigid-body.\n     *\n     * @deprecated The method has been renamed to `.dynamic()`.\n     */\n    public static newDynamic(): RigidBodyDesc {\n        return new RigidBodyDesc(RigidBodyType.Dynamic);\n    }\n\n    /**\n     * A rigid-body descriptor used to build a position-based kinematic rigid-body.\n     *\n     * @deprecated The method has been renamed to `.kinematicPositionBased()`.\n     */\n    public static newKinematicPositionBased(): RigidBodyDesc {\n        return new RigidBodyDesc(RigidBodyType.KinematicPositionBased);\n    }\n\n    /**\n     * A rigid-body descriptor used to build a velocity-based kinematic rigid-body.\n     *\n     * @deprecated The method has been renamed to `.kinematicVelocityBased()`.\n     */\n    public static newKinematicVelocityBased(): RigidBodyDesc {\n        return new RigidBodyDesc(RigidBodyType.KinematicVelocityBased);\n    }\n\n    /**\n     * A rigid-body descriptor used to build a fixed rigid-body.\n     *\n     * @deprecated The method has been renamed to `.fixed()`.\n     */\n    public static newStatic(): RigidBodyDesc {\n        return new RigidBodyDesc(RigidBodyType.Fixed);\n    }\n\n    public setDominanceGroup(group: number): RigidBodyDesc {\n        this.dominanceGroup = group;\n        return this;\n    }\n\n    /**\n     * Sets whether the created rigid-body will be enabled or disabled.\n     * @param enabled \u2212 If set to `false` the rigid-body will be disabled at creation.\n     */\n    public setEnabled(enabled: boolean): RigidBodyDesc {\n        this.enabled = enabled;\n        return this;\n    }\n\n\n    // #if DIM3\n    /**\n     * Sets the initial translation of the rigid-body to create.\n     *\n     * @param tra - The translation to set.\n     */\n    public setTranslation(x: number, y: number, z: number): RigidBodyDesc {\n        if (\n            typeof x != \"number\" ||\n            typeof y != \"number\" ||\n            typeof z != \"number\"\n        )\n            throw TypeError(\"The translation components must be numbers.\");\n\n        this.translation = {x: x, y: y, z: z};\n        return this;\n    }\n\n    // #endif\n\n    /**\n     * Sets the initial rotation of the rigid-body to create.\n     *\n     * @param rot - The rotation to set.\n     */\n    public setRotation(rot: Rotation): RigidBodyDesc {\n        // #if DIM3\n        RotationOps.copy(this.rotation, rot);\n        // #endif\n        return this;\n    }\n\n    /**\n     * Sets the scale factor applied to the gravity affecting\n     * the rigid-body being built.\n     *\n     * @param scale - The scale factor. Set this to `0.0` if the rigid-body\n     *   needs to ignore gravity.\n     */\n    public setGravityScale(scale: number): RigidBodyDesc {\n        this.gravityScale = scale;\n        return this;\n    }\n\n    /**\n     * Sets the initial mass of the rigid-body being built, before adding colliders' contributions.\n     *\n     * @param mass \u2212 The initial mass of the rigid-body to create.\n     */\n    public setAdditionalMass(mass: number): RigidBodyDesc {\n        this.mass = mass;\n        this.massOnly = true;\n        return this;\n    }\n\n\n    // #if DIM3\n    /**\n     * Sets the initial linear velocity of the rigid-body to create.\n     *\n     * @param x - The linear velocity to set along the `x` axis.\n     * @param y - The linear velocity to set along the `y` axis.\n     * @param z - The linear velocity to set along the `z` axis.\n     */\n    public setLinvel(x: number, y: number, z: number): RigidBodyDesc {\n        if (\n            typeof x != \"number\" ||\n            typeof y != \"number\" ||\n            typeof z != \"number\"\n        )\n            throw TypeError(\"The linvel components must be numbers.\");\n\n        this.linvel = {x: x, y: y, z: z};\n        return this;\n    }\n\n    /**\n     * Sets the initial angular velocity of the rigid-body to create.\n     *\n     * @param vel - The angular velocity to set.\n     */\n    public setAngvel(vel: Vector): RigidBodyDesc {\n        VectorOps.copy(this.angvel, vel);\n        return this;\n    }\n\n    /**\n     * Sets the mass properties of the rigid-body being built.\n     *\n     * Note that the final mass properties of the rigid-bodies depends\n     * on the initial mass-properties of the rigid-body (set by this method)\n     * to which is added the contributions of all the colliders with non-zero density\n     * attached to this rigid-body.\n     *\n     * Therefore, if you want your provided mass properties to be the final\n     * mass properties of your rigid-body, don't attach colliders to it, or\n     * only attach colliders with densities equal to zero.\n     *\n     * @param mass \u2212 The initial mass of the rigid-body to create.\n     * @param centerOfMass \u2212 The initial center-of-mass of the rigid-body to create.\n     * @param principalAngularInertia \u2212 The initial principal angular inertia of the rigid-body to create.\n     *                                  These are the eigenvalues of the angular inertia matrix.\n     * @param angularInertiaLocalFrame \u2212 The initial local angular inertia frame of the rigid-body to create.\n     *                                   These are the eigenvectors of the angular inertia matrix.\n     */\n    public setAdditionalMassProperties(\n        mass: number,\n        centerOfMass: Vector,\n        principalAngularInertia: Vector,\n        angularInertiaLocalFrame: Rotation,\n    ): RigidBodyDesc {\n        this.mass = mass;\n        VectorOps.copy(this.centerOfMass, centerOfMass);\n        VectorOps.copy(this.principalAngularInertia, principalAngularInertia);\n        RotationOps.copy(\n            this.angularInertiaLocalFrame,\n            angularInertiaLocalFrame,\n        );\n        this.massOnly = false;\n        return this;\n    }\n\n    /**\n     * Allow translation of this rigid-body only along specific axes.\n     * @param translationsEnabledX - Are translations along the X axis enabled?\n     * @param translationsEnabledY - Are translations along the y axis enabled?\n     * @param translationsEnabledZ - Are translations along the Z axis enabled?\n     */\n    public enabledTranslations(\n        translationsEnabledX: boolean,\n        translationsEnabledY: boolean,\n        translationsEnabledZ: boolean,\n    ): RigidBodyDesc {\n        this.translationsEnabledX = translationsEnabledX;\n        this.translationsEnabledY = translationsEnabledY;\n        this.translationsEnabledZ = translationsEnabledZ;\n        return this;\n    }\n    /**\n     * Allow translation of this rigid-body only along specific axes.\n     * @param translationsEnabledX - Are translations along the X axis enabled?\n     * @param translationsEnabledY - Are translations along the y axis enabled?\n     * @param translationsEnabledZ - Are translations along the Z axis enabled?\n     * @deprecated use `this.enabledTranslations` with the same arguments instead.\n     */\n    public restrictTranslations(\n        translationsEnabledX: boolean,\n        translationsEnabledY: boolean,\n        translationsEnabledZ: boolean,\n    ): RigidBodyDesc {\n        return this.enabledTranslations(\n            translationsEnabledX,\n            translationsEnabledY,\n            translationsEnabledZ,\n        );\n    }\n\n    /**\n     * Locks all translations that would have resulted from forces on\n     * the created rigid-body.\n     */\n    public lockTranslations(): RigidBodyDesc {\n        return this.enabledTranslations(false, false, false);\n    }\n\n    /**\n     * Allow rotation of this rigid-body only along specific axes.\n     * @param rotationsEnabledX - Are rotations along the X axis enabled?\n     * @param rotationsEnabledY - Are rotations along the y axis enabled?\n     * @param rotationsEnabledZ - Are rotations along the Z axis enabled?\n     */\n    public enabledRotations(\n        rotationsEnabledX: boolean,\n        rotationsEnabledY: boolean,\n        rotationsEnabledZ: boolean,\n    ): RigidBodyDesc {\n        this.rotationsEnabledX = rotationsEnabledX;\n        this.rotationsEnabledY = rotationsEnabledY;\n        this.rotationsEnabledZ = rotationsEnabledZ;\n        return this;\n    }\n\n    /**\n     * Allow rotation of this rigid-body only along specific axes.\n     * @param rotationsEnabledX - Are rotations along the X axis enabled?\n     * @param rotationsEnabledY - Are rotations along the y axis enabled?\n     * @param rotationsEnabledZ - Are rotations along the Z axis enabled?\n     * @deprecated use `this.enabledRotations` with the same arguments instead.\n     */\n    public restrictRotations(\n        rotationsEnabledX: boolean,\n        rotationsEnabledY: boolean,\n        rotationsEnabledZ: boolean,\n    ): RigidBodyDesc {\n        return this.enabledRotations(\n            rotationsEnabledX,\n            rotationsEnabledY,\n            rotationsEnabledZ,\n        );\n    }\n\n    /**\n     * Locks all rotations that would have resulted from forces on\n     * the created rigid-body.\n     */\n    public lockRotations(): RigidBodyDesc {\n        return this.restrictRotations(false, false, false);\n    }\n\n    // #endif\n\n    /**\n     * Sets the linear damping of the rigid-body to create.\n     *\n     * This will progressively slowdown the translational movement of the rigid-body.\n     *\n     * @param damping - The angular damping coefficient. Should be >= 0. The higher this\n     *                  value is, the stronger the translational slowdown will be.\n     */\n    public setLinearDamping(damping: number): RigidBodyDesc {\n        this.linearDamping = damping;\n        return this;\n    }\n\n    /**\n     * Sets the angular damping of the rigid-body to create.\n     *\n     * This will progressively slowdown the rotational movement of the rigid-body.\n     *\n     * @param damping - The angular damping coefficient. Should be >= 0. The higher this\n     *                  value is, the stronger the rotational slowdown will be.\n     */\n    public setAngularDamping(damping: number): RigidBodyDesc {\n        this.angularDamping = damping;\n        return this;\n    }\n\n    /**\n     * Sets whether or not the rigid-body to create can sleep.\n     *\n     * @param can - true if the rigid-body can sleep, false if it can't.\n     */\n    public setCanSleep(can: boolean): RigidBodyDesc {\n        this.canSleep = can;\n        return this;\n    }\n\n    /**\n     * Sets whether or not the rigid-body is to be created asleep.\n     *\n     * @param can - true if the rigid-body should be in sleep, default false.\n     */\n    setSleeping(sleeping: boolean): RigidBodyDesc {\n        this.sleeping = sleeping;\n        return this;\n    }\n\n    /**\n     * Sets whether Continuous Collision Detection (CCD) is enabled for this rigid-body.\n     *\n     * @param enabled - true if the rigid-body has CCD enabled.\n     */\n    public setCcdEnabled(enabled: boolean): RigidBodyDesc {\n        this.ccdEnabled = enabled;\n        return this;\n    }\n\n    /**\n     * Sets the user-defined object of this rigid-body.\n     *\n     * @param userData - The user-defined object to set.\n     */\n    public setUserData(data?: unknown): RigidBodyDesc {\n        this.userData = data;\n        return this;\n    }\n}\n", "export class Coarena<T> {\n    fconv: Float64Array;\n    uconv: Uint32Array;\n    data: Array<T>;\n    size: number;\n\n    public constructor() {\n        this.fconv = new Float64Array(1);\n        this.uconv = new Uint32Array(this.fconv.buffer);\n        this.data = new Array<T>();\n        this.size = 0;\n    }\n\n    public set(handle: number, data: T) {\n        let i = this.index(handle);\n        while (this.data.length <= i) {\n            this.data.push(null);\n        }\n\n        if (this.data[i] == null) this.size += 1;\n        this.data[i] = data;\n    }\n\n    public len(): number {\n        return this.size;\n    }\n\n    public delete(handle: number) {\n        let i = this.index(handle);\n        if (i < this.data.length) {\n            if (this.data[i] != null) this.size -= 1;\n            this.data[i] = null;\n        }\n    }\n\n    public clear() {\n        this.data = new Array<T>();\n    }\n\n    public get(handle: number): T | null {\n        let i = this.index(handle);\n        if (i < this.data.length) {\n            return this.data[i];\n        } else {\n            return null;\n        }\n    }\n\n    public forEach(f: (elt: T) => void) {\n        for (const elt of this.data) {\n            if (elt != null) f(elt);\n        }\n    }\n\n    public getAll(): Array<T> {\n        return this.data.filter((elt) => elt != null);\n    }\n\n    private index(handle: number): number {\n        /// Extracts the index part of a handle (the lower 32 bits).\n        /// This is done by first injecting the handle into an Float64Array\n        /// which is itself injected into an Uint32Array (at construction time).\n        /// The 0-th value of the Uint32Array will become the `number` integer\n        /// representation of the lower 32 bits.\n        /// Also `this.uconv[1]` then contains the generation number as a `number`,\n        /// which we don\u2019t really need.\n        this.fconv[0] = handle;\n        return this.uconv[0];\n    }\n}\n", "import {RawRigidBodySet} from \"../raw\";\nimport {Coarena} from \"../coarena\";\nimport {VectorOps, RotationOps} from \"../math\";\nimport {RigidBody, RigidBodyDesc, RigidBodyHandle} from \"./rigid_body\";\nimport {ColliderSet} from \"../geometry\";\nimport {ImpulseJointSet} from \"./impulse_joint_set\";\nimport {MultibodyJointSet} from \"./multibody_joint_set\";\nimport {IslandManager} from \"./island_manager\";\n\n/**\n * A set of rigid bodies that can be handled by a physics pipeline.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `rigidBodySet.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nexport class RigidBodySet {\n    raw: RawRigidBodySet;\n    private map: Coarena<RigidBody>;\n\n    /**\n     * Release the WASM memory occupied by this rigid-body set.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n\n        if (!!this.map) {\n            this.map.clear();\n        }\n        this.map = undefined;\n    }\n\n    constructor(raw?: RawRigidBodySet) {\n        this.raw = raw || new RawRigidBodySet();\n        this.map = new Coarena<RigidBody>();\n        // deserialize\n        if (raw) {\n            raw.forEachRigidBodyHandle((handle: RigidBodyHandle) => {\n                this.map.set(handle, new RigidBody(raw, null, handle));\n            });\n        }\n    }\n\n    /**\n     * Internal method, do not call this explicitly.\n     */\n    public finalizeDeserialization(colliderSet: ColliderSet) {\n        this.map.forEach((rb) => rb.finalizeDeserialization(colliderSet));\n    }\n\n    /**\n     * Creates a new rigid-body and return its integer handle.\n     *\n     * @param desc - The description of the rigid-body to create.\n     */\n    public createRigidBody(\n        colliderSet: ColliderSet,\n        desc: RigidBodyDesc,\n    ): RigidBody {\n        let rawTra = VectorOps.intoRaw(desc.translation);\n        let rawRot = RotationOps.intoRaw(desc.rotation);\n        let rawLv = VectorOps.intoRaw(desc.linvel);\n        let rawCom = VectorOps.intoRaw(desc.centerOfMass);\n\n        // #if DIM3\n        let rawAv = VectorOps.intoRaw(desc.angvel);\n        let rawPrincipalInertia = VectorOps.intoRaw(\n            desc.principalAngularInertia,\n        );\n        let rawInertiaFrame = RotationOps.intoRaw(\n            desc.angularInertiaLocalFrame,\n        );\n        // #endif\n\n        let handle = this.raw.createRigidBody(\n            desc.enabled,\n            rawTra,\n            rawRot,\n            desc.gravityScale,\n            desc.mass,\n            desc.massOnly,\n            rawCom,\n            rawLv,\n            // #if DIM3\n            rawAv,\n            rawPrincipalInertia,\n            rawInertiaFrame,\n            desc.translationsEnabledX,\n            desc.translationsEnabledY,\n            desc.translationsEnabledZ,\n            desc.rotationsEnabledX,\n            desc.rotationsEnabledY,\n            desc.rotationsEnabledZ,\n            // #endif\n            desc.linearDamping,\n            desc.angularDamping,\n            desc.status,\n            desc.canSleep,\n            desc.sleeping,\n            desc.ccdEnabled,\n            desc.dominanceGroup,\n        );\n\n        rawTra.free();\n        rawRot.free();\n        rawLv.free();\n        rawCom.free();\n\n        // #if DIM3\n        rawAv.free();\n        rawPrincipalInertia.free();\n        rawInertiaFrame.free();\n        // #endif\n\n        const body = new RigidBody(this.raw, colliderSet, handle);\n        body.userData = desc.userData;\n\n        this.map.set(handle, body);\n\n        return body;\n    }\n\n    /**\n     * Removes a rigid-body from this set.\n     *\n     * This will also remove all the colliders and joints attached to the rigid-body.\n     *\n     * @param handle - The integer handle of the rigid-body to remove.\n     * @param colliders - The set of colliders that may contain colliders attached to the removed rigid-body.\n     * @param impulseJoints - The set of impulse joints that may contain joints attached to the removed rigid-body.\n     * @param multibodyJoints - The set of multibody joints that may contain joints attached to the removed rigid-body.\n     */\n    public remove(\n        handle: RigidBodyHandle,\n        islands: IslandManager,\n        colliders: ColliderSet,\n        impulseJoints: ImpulseJointSet,\n        multibodyJoints: MultibodyJointSet,\n    ) {\n        // Unmap the entities that will be removed automatically because of the rigid-body removals.\n        for (let i = 0; i < this.raw.rbNumColliders(handle); i += 1) {\n            colliders.unmap(this.raw.rbCollider(handle, i));\n        }\n\n        impulseJoints.forEachJointHandleAttachedToRigidBody(handle, (handle) =>\n            impulseJoints.unmap(handle),\n        );\n        multibodyJoints.forEachJointHandleAttachedToRigidBody(\n            handle,\n            (handle) => multibodyJoints.unmap(handle),\n        );\n\n        // Remove the rigid-body.\n        this.raw.remove(\n            handle,\n            islands.raw,\n            colliders.raw,\n            impulseJoints.raw,\n            multibodyJoints.raw,\n        );\n        this.map.delete(handle);\n    }\n\n    /**\n     * The number of rigid-bodies on this set.\n     */\n    public len(): number {\n        return this.map.len();\n    }\n\n    /**\n     * Does this set contain a rigid-body with the given handle?\n     *\n     * @param handle - The rigid-body handle to check.\n     */\n    public contains(handle: RigidBodyHandle): boolean {\n        return this.get(handle) != null;\n    }\n\n    /**\n     * Gets the rigid-body with the given handle.\n     *\n     * @param handle - The handle of the rigid-body to retrieve.\n     */\n    public get(handle: RigidBodyHandle): RigidBody | null {\n        return this.map.get(handle);\n    }\n\n    /**\n     * Applies the given closure to each rigid-body contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n    public forEach(f: (body: RigidBody) => void) {\n        this.map.forEach(f);\n    }\n\n    /**\n     * Applies the given closure to each active rigid-bodies contained by this set.\n     *\n     * A rigid-body is active if it is not sleeping, i.e., if it moved recently.\n     *\n     * @param f - The closure to apply.\n     */\n    public forEachActiveRigidBody(\n        islands: IslandManager,\n        f: (body: RigidBody) => void,\n    ) {\n        islands.forEachActiveRigidBodyHandle((handle) => {\n            f(this.get(handle));\n        });\n    }\n\n    /**\n     * Gets all rigid-bodies in the list.\n     *\n     * @returns rigid-bodies list.\n     */\n    public getAll(): RigidBody[] {\n        return this.map.getAll();\n    }\n}\n", "import {RawIntegrationParameters} from \"../raw\";\n\nexport class IntegrationParameters {\n    raw: RawIntegrationParameters;\n\n    constructor(raw?: RawIntegrationParameters) {\n        this.raw = raw || new RawIntegrationParameters();\n    }\n\n    /**\n     * Free the WASM memory used by these integration parameters.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    /**\n     * The timestep length (default: `1.0 / 60.0`)\n     */\n    get dt(): number {\n        return this.raw.dt;\n    }\n\n    /**\n     * The Error Reduction Parameter in `[0, 1]` is the proportion of\n     * the positional error to be corrected at each time step (default: `0.2`).\n     */\n    get erp(): number {\n        return this.raw.erp;\n    }\n\n    /**\n     * Amount of penetration the engine wont attempt to correct (default: `0.001m`).\n     */\n    get allowedLinearError(): number {\n        return this.raw.allowedLinearError;\n    }\n\n    /**\n     * The maximal distance separating two objects that will generate predictive contacts (default: `0.002`).\n     */\n    get predictionDistance(): number {\n        return this.raw.predictionDistance;\n    }\n\n    /**\n     * Maximum number of iterations performed by the velocity constraints solver (default: `4`).\n     */\n    get maxVelocityIterations(): number {\n        return this.raw.maxVelocityIterations;\n    }\n\n    /**\n     * Maximum number of friction iterations performed by the position-based constraints solver (default: `1`).\n     */\n    get maxVelocityFrictionIterations(): number {\n        return this.raw.maxVelocityFrictionIterations;\n    }\n\n    /**\n     * Maximum number of stabilization iterations performed by the position-based constraints solver (default: `1`).\n     */\n    get maxStabilizationIterations(): number {\n        return this.raw.maxStabilizationIterations;\n    }\n\n    /**\n     * Minimum number of dynamic bodies in each active island (default: `128`).\n     */\n    get minIslandSize(): number {\n        return this.raw.minIslandSize;\n    }\n\n    /**\n     * Maximum number of substeps performed by the  solver (default: `1`).\n     */\n    get maxCcdSubsteps(): number {\n        return this.raw.maxCcdSubsteps;\n    }\n\n    set dt(value: number) {\n        this.raw.dt = value;\n    }\n\n    set erp(value: number) {\n        this.raw.erp = value;\n    }\n\n    set allowedLinearError(value: number) {\n        this.raw.allowedLinearError = value;\n    }\n\n    set predictionDistance(value: number) {\n        this.raw.predictionDistance = value;\n    }\n\n    set maxVelocityIterations(value: number) {\n        this.raw.maxVelocityIterations = value;\n    }\n\n    set maxVelocityFrictionIterations(value: number) {\n        this.raw.maxVelocityFrictionIterations = value;\n    }\n\n    set maxStabilizationIterations(value: number) {\n        this.raw.maxStabilizationIterations = value;\n    }\n\n    set minIslandSize(value: number) {\n        this.raw.minIslandSize = value;\n    }\n\n    set maxCcdSubsteps(value: number) {\n        this.raw.maxCcdSubsteps = value;\n    }\n}\n", "import {Rotation, Vector, VectorOps, RotationOps} from \"../math\";\nimport {\n    RawGenericJoint,\n    RawImpulseJointSet,\n    RawRigidBodySet,\n    RawJointAxis,\n} from \"../raw\";\nimport {RigidBody, RigidBodyHandle} from \"./rigid_body\";\nimport {RigidBodySet} from \"./rigid_body_set\";\n// #if DIM3\nimport {Quaternion} from \"../math\";\n// #endif\n\n/**\n * The integer identifier of a collider added to a `ColliderSet`.\n */\nexport type ImpulseJointHandle = number;\n\n/**\n * An enum grouping all possible types of joints:\n *\n * - `Revolute`: A revolute joint that removes all degrees of freedom between the affected\n *               bodies except for the rotation along one axis.\n * - `Fixed`: A fixed joint that removes all relative degrees of freedom between the affected bodies.\n * - `Prismatic`: A prismatic joint that removes all degrees of freedom between the affected\n *                bodies except for the translation along one axis.\n * - `Spherical`: (3D only) A spherical joint that removes all relative linear degrees of freedom between the affected bodies.\n * - `Generic`: (3D only) A joint with customizable degrees of freedom, allowing any of the 6 axes to be locked.\n */\nexport enum JointType {\n    Revolute,\n    Fixed,\n    Prismatic,\n    // #if DIM3\n    Spherical,\n    Generic,\n    // #endif\n}\n\nexport enum MotorModel {\n    AccelerationBased,\n    ForceBased,\n}\n\n/**\n * An enum representing the possible joint axes of a generic joint.\n * They can be ORed together, like:\n * JointAxesMask.X || JointAxesMask.Y\n * to get a joint that is only free in the X and Y translational (positional) axes.\n *\n * Possible free axes are:\n *\n * - `X`: X translation axis\n * - `Y`: Y translation axis\n * - `Z`: Z translation axis\n * - `AngX`: X angular rotation axis\n * - `AngY`: Y angular rotations axis\n * - `AngZ`: Z angular rotation axis\n */\nexport enum JointAxesMask {\n    X = 1 << 0,\n    Y = 1 << 1,\n    Z = 1 << 2,\n    AngX = 1 << 3,\n    AngY = 1 << 4,\n    AngZ = 1 << 5,\n}\n\nexport class ImpulseJoint {\n    protected rawSet: RawImpulseJointSet; // The ImpulseJoint won't need to free this.\n    protected bodySet: RigidBodySet; // The ImpulseJoint won\u2019t need to free this.\n    handle: ImpulseJointHandle;\n\n    constructor(\n        rawSet: RawImpulseJointSet,\n        bodySet: RigidBodySet,\n        handle: ImpulseJointHandle,\n    ) {\n        this.rawSet = rawSet;\n        this.bodySet = bodySet;\n        this.handle = handle;\n    }\n\n    public static newTyped(\n        rawSet: RawImpulseJointSet,\n        bodySet: RigidBodySet,\n        handle: ImpulseJointHandle,\n    ): ImpulseJoint {\n        switch (rawSet.jointType(handle)) {\n            case JointType.Revolute:\n                return new RevoluteImpulseJoint(rawSet, bodySet, handle);\n            case JointType.Prismatic:\n                return new PrismaticImpulseJoint(rawSet, bodySet, handle);\n            case JointType.Fixed:\n                return new FixedImpulseJoint(rawSet, bodySet, handle);\n            // #if DIM3\n            case JointType.Spherical:\n                return new SphericalImpulseJoint(rawSet, bodySet, handle);\n            case JointType.Generic:\n                return new GenericImpulseJoint(rawSet, bodySet, handle);\n            // #endif\n            default:\n                return new ImpulseJoint(rawSet, bodySet, handle);\n        }\n    }\n\n    /** @internal */\n    public finalizeDeserialization(bodySet: RigidBodySet) {\n        this.bodySet = bodySet;\n    }\n\n    /**\n     * Checks if this joint is still valid (i.e. that it has\n     * not been deleted from the joint set yet).\n     */\n    public isValid(): boolean {\n        return this.rawSet.contains(this.handle);\n    }\n\n    /**\n     * The first rigid-body this joint it attached to.\n     */\n    public body1(): RigidBody {\n        return this.bodySet.get(this.rawSet.jointBodyHandle1(this.handle));\n    }\n\n    /**\n     * The second rigid-body this joint is attached to.\n     */\n    public body2(): RigidBody {\n        return this.bodySet.get(this.rawSet.jointBodyHandle2(this.handle));\n    }\n\n    /**\n     * The type of this joint given as a string.\n     */\n    public type(): JointType {\n        return this.rawSet.jointType(this.handle);\n    }\n\n    // #if DIM3\n    /**\n     * The rotation quaternion that aligns this joint's first local axis to the `x` axis.\n     */\n    public frameX1(): Rotation {\n        return RotationOps.fromRaw(this.rawSet.jointFrameX1(this.handle));\n    }\n\n    // #endif\n\n    // #if DIM3\n    /**\n     * The rotation matrix that aligns this joint's second local axis to the `x` axis.\n     */\n    public frameX2(): Rotation {\n        return RotationOps.fromRaw(this.rawSet.jointFrameX2(this.handle));\n    }\n\n    // #endif\n\n    /**\n     * The position of the first anchor of this joint.\n     *\n     * The first anchor gives the position of the application point on the\n     * local frame of the first rigid-body it is attached to.\n     */\n    public anchor1(): Vector {\n        return VectorOps.fromRaw(this.rawSet.jointAnchor1(this.handle));\n    }\n\n    /**\n     * The position of the second anchor of this joint.\n     *\n     * The second anchor gives the position of the application point on the\n     * local frame of the second rigid-body it is attached to.\n     */\n    public anchor2(): Vector {\n        return VectorOps.fromRaw(this.rawSet.jointAnchor2(this.handle));\n    }\n\n    /**\n     * Sets the position of the first anchor of this joint.\n     *\n     * The first anchor gives the position of the application point on the\n     * local frame of the first rigid-body it is attached to.\n     */\n    public setAnchor1(newPos: Vector) {\n        const rawPoint = VectorOps.intoRaw(newPos);\n        this.rawSet.jointSetAnchor1(this.handle, rawPoint);\n        rawPoint.free();\n    }\n\n    /**\n     * Sets the position of the second anchor of this joint.\n     *\n     * The second anchor gives the position of the application point on the\n     * local frame of the second rigid-body it is attached to.\n     */\n    public setAnchor2(newPos: Vector) {\n        const rawPoint = VectorOps.intoRaw(newPos);\n        this.rawSet.jointSetAnchor2(this.handle, rawPoint);\n        rawPoint.free();\n    }\n\n    /**\n     * Controls whether contacts are computed between colliders attached\n     * to the rigid-bodies linked by this joint.\n     */\n    public setContactsEnabled(enabled: boolean) {\n        this.rawSet.jointSetContactsEnabled(this.handle, enabled);\n    }\n\n    /**\n     * Indicates if contacts are enabled between colliders attached\n     * to the rigid-bodies linked by this joint.\n     */\n    public contactsEnabled(): boolean {\n        return this.rawSet.jointContactsEnabled(this.handle);\n    }\n}\n\nexport class UnitImpulseJoint extends ImpulseJoint {\n    /**\n     * The axis left free by this joint.\n     */\n    protected rawAxis?(): RawJointAxis;\n\n    /**\n     * Are the limits enabled for this joint?\n     */\n    public limitsEnabled(): boolean {\n        return this.rawSet.jointLimitsEnabled(this.handle, this.rawAxis());\n    }\n\n    /**\n     * The min limit of this joint.\n     */\n    public limitsMin(): number {\n        return this.rawSet.jointLimitsMin(this.handle, this.rawAxis());\n    }\n\n    /**\n     * The max limit of this joint.\n     */\n    public limitsMax(): number {\n        return this.rawSet.jointLimitsMax(this.handle, this.rawAxis());\n    }\n\n    /**\n     * Sets the limits of this joint.\n     *\n     * @param min - The minimum bound of this joint\u2019s free coordinate.\n     * @param max - The maximum bound of this joint\u2019s free coordinate.\n     */\n    public setLimits(min: number, max: number) {\n        this.rawSet.jointSetLimits(this.handle, this.rawAxis(), min, max);\n    }\n\n    public configureMotorModel(model: MotorModel) {\n        this.rawSet.jointConfigureMotorModel(\n            this.handle,\n            this.rawAxis(),\n            model,\n        );\n    }\n\n    public configureMotorVelocity(targetVel: number, factor: number) {\n        this.rawSet.jointConfigureMotorVelocity(\n            this.handle,\n            this.rawAxis(),\n            targetVel,\n            factor,\n        );\n    }\n\n    public configureMotorPosition(\n        targetPos: number,\n        stiffness: number,\n        damping: number,\n    ) {\n        this.rawSet.jointConfigureMotorPosition(\n            this.handle,\n            this.rawAxis(),\n            targetPos,\n            stiffness,\n            damping,\n        );\n    }\n\n    public configureMotor(\n        targetPos: number,\n        targetVel: number,\n        stiffness: number,\n        damping: number,\n    ) {\n        this.rawSet.jointConfigureMotor(\n            this.handle,\n            this.rawAxis(),\n            targetPos,\n            targetVel,\n            stiffness,\n            damping,\n        );\n    }\n}\n\nexport class FixedImpulseJoint extends ImpulseJoint {}\n\nexport class PrismaticImpulseJoint extends UnitImpulseJoint {\n    public rawAxis(): RawJointAxis {\n        return RawJointAxis.X;\n    }\n}\n\nexport class RevoluteImpulseJoint extends UnitImpulseJoint {\n    public rawAxis(): RawJointAxis {\n        return RawJointAxis.AngX;\n    }\n}\n\n// #if DIM3\nexport class GenericImpulseJoint extends ImpulseJoint {}\n\nexport class SphericalImpulseJoint extends ImpulseJoint {\n    /* Unsupported by this alpha release.\n    public configureMotorModel(model: MotorModel) {\n        this.rawSet.jointConfigureMotorModel(this.handle, model);\n    }\n\n    public configureMotorVelocity(targetVel: Vector, factor: number) {\n        this.rawSet.jointConfigureBallMotorVelocity(this.handle, targetVel.x, targetVel.y, targetVel.z, factor);\n    }\n\n    public configureMotorPosition(targetPos: Quaternion, stiffness: number, damping: number) {\n        this.rawSet.jointConfigureBallMotorPosition(this.handle, targetPos.w, targetPos.x, targetPos.y, targetPos.z, stiffness, damping);\n    }\n\n    public configureMotor(targetPos: Quaternion, targetVel: Vector, stiffness: number, damping: number) {\n        this.rawSet.jointConfigureBallMotor(this.handle,\n            targetPos.w, targetPos.x, targetPos.y, targetPos.z,\n            targetVel.x, targetVel.y, targetVel.z,\n            stiffness, damping);\n    }\n     */\n}\n// #endif\n\nexport class JointData {\n    anchor1: Vector;\n    anchor2: Vector;\n    axis: Vector;\n    frame1: Rotation;\n    frame2: Rotation;\n    jointType: JointType;\n    limitsEnabled: boolean;\n    limits: Array<number>;\n    axesMask: JointAxesMask;\n\n    private constructor() {}\n\n    /**\n     * Creates a new joint descriptor that builds a Fixed joint.\n     *\n     * A fixed joint removes all the degrees of freedom between the affected bodies, ensuring their\n     * anchor and local frames coincide in world-space.\n     *\n     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param frame1 - The reference orientation of the joint wrt. the first rigid-body.\n     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param frame2 - The reference orientation of the joint wrt. the second rigid-body.\n     */\n    public static fixed(\n        anchor1: Vector,\n        frame1: Rotation,\n        anchor2: Vector,\n        frame2: Rotation,\n    ): JointData {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.frame1 = frame1;\n        res.frame2 = frame2;\n        res.jointType = JointType.Fixed;\n        return res;\n    }\n\n\n    // #if DIM3\n    /**\n     * Create a new joint descriptor that builds generic joints.\n     *\n     * A generic joint allows customizing its degrees of freedom\n     * by supplying a mask of the joint axes that should remain locked.\n     *\n     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param axis - The X axis of the joint, expressed in the local-space of the rigid-bodies it is attached to.\n     * @param axesMask - Mask representing the locked axes of the joint. You can use logical OR to select these from\n     *                   the JointAxesMask enum. For example, passing (JointAxesMask.AngX || JointAxesMask.AngY) will\n     *                   create a joint locked in the X and Y rotational axes.\n     */\n    public static generic(\n        anchor1: Vector,\n        anchor2: Vector,\n        axis: Vector,\n        axesMask: JointAxesMask,\n    ): JointData {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.axis = axis;\n        res.axesMask = axesMask;\n        res.jointType = JointType.Generic;\n        return res;\n    }\n\n    /**\n     * Create a new joint descriptor that builds spherical joints.\n     *\n     * A spherical joint allows three relative rotational degrees of freedom\n     * by preventing any relative translation between the anchors of the\n     * two attached rigid-bodies.\n     *\n     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     */\n    public static spherical(anchor1: Vector, anchor2: Vector): JointData {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.jointType = JointType.Spherical;\n        return res;\n    }\n\n    /**\n     * Creates a new joint descriptor that builds a Prismatic joint.\n     *\n     * A prismatic joint removes all the degrees of freedom between the\n     * affected bodies, except for the translation along one axis.\n     *\n     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param axis - Axis of the joint, expressed in the local-space of the rigid-bodies it is attached to.\n     */\n    public static prismatic(\n        anchor1: Vector,\n        anchor2: Vector,\n        axis: Vector,\n    ): JointData {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.axis = axis;\n        res.jointType = JointType.Prismatic;\n        return res;\n    }\n\n    /**\n     * Create a new joint descriptor that builds Revolute joints.\n     *\n     * A revolute joint removes all degrees of freedom between the affected\n     * bodies except for the rotation along one axis.\n     *\n     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param axis - Axis of the joint, expressed in the local-space of the rigid-bodies it is attached to.\n     */\n    public static revolute(\n        anchor1: Vector,\n        anchor2: Vector,\n        axis: Vector,\n    ): JointData {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.axis = axis;\n        res.jointType = JointType.Revolute;\n        return res;\n    }\n    // #endif\n\n    public intoRaw(): RawGenericJoint {\n        let rawA1 = VectorOps.intoRaw(this.anchor1);\n        let rawA2 = VectorOps.intoRaw(this.anchor2);\n        let rawAx;\n        let result;\n        let limitsEnabled = false;\n        let limitsMin = 0.0;\n        let limitsMax = 0.0;\n\n        switch (this.jointType) {\n            case JointType.Fixed:\n                let rawFra1 = RotationOps.intoRaw(this.frame1);\n                let rawFra2 = RotationOps.intoRaw(this.frame2);\n                result = RawGenericJoint.fixed(rawA1, rawFra1, rawA2, rawFra2);\n                rawFra1.free();\n                rawFra2.free();\n                break;\n            case JointType.Prismatic:\n                rawAx = VectorOps.intoRaw(this.axis);\n\n                if (!!this.limitsEnabled) {\n                    limitsEnabled = true;\n                    limitsMin = this.limits[0];\n                    limitsMax = this.limits[1];\n                }\n\n\n                // #if DIM3\n                result = RawGenericJoint.prismatic(\n                    rawA1,\n                    rawA2,\n                    rawAx,\n                    limitsEnabled,\n                    limitsMin,\n                    limitsMax,\n                );\n                // #endif\n\n                rawAx.free();\n                break;\n            // #if DIM3\n            case JointType.Generic:\n                rawAx = VectorOps.intoRaw(this.axis);\n                // implicit type cast: axesMask is a JointAxesMask bitflag enum,\n                // we're treating it as a u8 on the Rust side\n                let rawAxesMask = this.axesMask;\n                result = RawGenericJoint.generic(\n                    rawA1,\n                    rawA2,\n                    rawAx,\n                    rawAxesMask,\n                );\n                break;\n            case JointType.Spherical:\n                result = RawGenericJoint.spherical(rawA1, rawA2);\n                break;\n            case JointType.Revolute:\n                rawAx = VectorOps.intoRaw(this.axis);\n                result = RawGenericJoint.revolute(rawA1, rawA2, rawAx);\n                rawAx.free();\n                break;\n            // #endif\n        }\n\n        rawA1.free();\n        rawA2.free();\n\n        return result;\n    }\n}\n", "import {RawImpulseJointSet} from \"../raw\";\nimport {Coarena} from \"../coarena\";\nimport {RigidBodySet} from \"./rigid_body_set\";\nimport {\n    RevoluteImpulseJoint,\n    FixedImpulseJoint,\n    ImpulseJoint,\n    ImpulseJointHandle,\n    JointData,\n    JointType,\n    PrismaticImpulseJoint,\n    // #if DIM3\n    SphericalImpulseJoint,\n    // #endif\n} from \"./impulse_joint\";\nimport {IslandManager} from \"./island_manager\";\nimport {RigidBodyHandle} from \"./rigid_body\";\nimport {Collider, ColliderHandle} from \"../geometry\";\n\n/**\n * A set of joints.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `jointSet.free()`\n * once you are done using it (and all the joints it created).\n */\nexport class ImpulseJointSet {\n    raw: RawImpulseJointSet;\n    private map: Coarena<ImpulseJoint>;\n\n    /**\n     * Release the WASM memory occupied by this joint set.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n\n        if (!!this.map) {\n            this.map.clear();\n        }\n        this.map = undefined;\n    }\n\n    constructor(raw?: RawImpulseJointSet) {\n        this.raw = raw || new RawImpulseJointSet();\n        this.map = new Coarena<ImpulseJoint>();\n        // Initialize the map with the existing elements, if any.\n        if (raw) {\n            raw.forEachJointHandle((handle: ImpulseJointHandle) => {\n                this.map.set(handle, ImpulseJoint.newTyped(raw, null, handle));\n            });\n        }\n    }\n\n    /** @internal */\n    public finalizeDeserialization(bodies: RigidBodySet) {\n        this.map.forEach((joint) => joint.finalizeDeserialization(bodies));\n    }\n\n    /**\n     * Creates a new joint and return its integer handle.\n     *\n     * @param bodies - The set of rigid-bodies containing the bodies the joint is attached to.\n     * @param desc - The joint's parameters.\n     * @param parent1 - The handle of the first rigid-body this joint is attached to.\n     * @param parent2 - The handle of the second rigid-body this joint is attached to.\n     * @param wakeUp - Should the attached rigid-bodies be awakened?\n     */\n    public createJoint(\n        bodies: RigidBodySet,\n        desc: JointData,\n        parent1: RigidBodyHandle,\n        parent2: RigidBodyHandle,\n        wakeUp: boolean,\n    ): ImpulseJoint {\n        const rawParams = desc.intoRaw();\n        const handle = this.raw.createJoint(\n            rawParams,\n            parent1,\n            parent2,\n            wakeUp,\n        );\n        rawParams.free();\n        let joint = ImpulseJoint.newTyped(this.raw, bodies, handle);\n        this.map.set(handle, joint);\n        return joint;\n    }\n\n    /**\n     * Remove a joint from this set.\n     *\n     * @param handle - The integer handle of the joint.\n     * @param wakeUp - If `true`, the rigid-bodies attached by the removed joint will be woken-up automatically.\n     */\n    public remove(handle: ImpulseJointHandle, wakeUp: boolean) {\n        this.raw.remove(handle, wakeUp);\n        this.unmap(handle);\n    }\n\n    /**\n     * Calls the given closure with the integer handle of each impulse joint attached to this rigid-body.\n     *\n     * @param f - The closure called with the integer handle of each impulse joint attached to the rigid-body.\n     */\n    public forEachJointHandleAttachedToRigidBody(\n        handle: RigidBodyHandle,\n        f: (handle: ImpulseJointHandle) => void,\n    ) {\n        this.raw.forEachJointAttachedToRigidBody(handle, f);\n    }\n\n    /**\n     * Internal function, do not call directly.\n     * @param handle\n     */\n    public unmap(handle: ImpulseJointHandle) {\n        this.map.delete(handle);\n    }\n\n    /**\n     * The number of joints on this set.\n     */\n    public len(): number {\n        return this.map.len();\n    }\n\n    /**\n     * Does this set contain a joint with the given handle?\n     *\n     * @param handle - The joint handle to check.\n     */\n    public contains(handle: ImpulseJointHandle): boolean {\n        return this.get(handle) != null;\n    }\n\n    /**\n     * Gets the joint with the given handle.\n     *\n     * Returns `null` if no joint with the specified handle exists.\n     *\n     * @param handle - The integer handle of the joint to retrieve.\n     */\n    public get(handle: ImpulseJointHandle): ImpulseJoint | null {\n        return this.map.get(handle);\n    }\n\n    /**\n     * Applies the given closure to each joint contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n    public forEach(f: (joint: ImpulseJoint) => void) {\n        this.map.forEach(f);\n    }\n\n    /**\n     * Gets all joints in the list.\n     *\n     * @returns joint list.\n     */\n    public getAll(): ImpulseJoint[] {\n        return this.map.getAll();\n    }\n}\n", "import {RawImpulseJointSet, RawJointAxis, RawMultibodyJointSet} from \"../raw\";\nimport {\n    FixedImpulseJoint,\n    ImpulseJointHandle,\n    JointType,\n    MotorModel,\n    PrismaticImpulseJoint,\n    RevoluteImpulseJoint,\n} from \"./impulse_joint\";\n\n// #if DIM3\nimport {Quaternion} from \"../math\";\nimport {SphericalImpulseJoint} from \"./impulse_joint\";\n// #endif\n\n/**\n * The integer identifier of a collider added to a `ColliderSet`.\n */\nexport type MultibodyJointHandle = number;\n\nexport class MultibodyJoint {\n    protected rawSet: RawMultibodyJointSet; // The MultibodyJoint won't need to free this.\n    handle: MultibodyJointHandle;\n\n    constructor(rawSet: RawMultibodyJointSet, handle: MultibodyJointHandle) {\n        this.rawSet = rawSet;\n        this.handle = handle;\n    }\n\n    public static newTyped(\n        rawSet: RawMultibodyJointSet,\n        handle: MultibodyJointHandle,\n    ): MultibodyJoint {\n        switch (rawSet.jointType(handle)) {\n            case JointType.Revolute:\n                return new RevoluteMultibodyJoint(rawSet, handle);\n            case JointType.Prismatic:\n                return new PrismaticMultibodyJoint(rawSet, handle);\n            case JointType.Fixed:\n                return new FixedMultibodyJoint(rawSet, handle);\n            // #if DIM3\n            case JointType.Spherical:\n                return new SphericalMultibodyJoint(rawSet, handle);\n            // #endif\n            default:\n                return new MultibodyJoint(rawSet, handle);\n        }\n    }\n\n    /**\n     * Checks if this joint is still valid (i.e. that it has\n     * not been deleted from the joint set yet).\n     */\n    public isValid(): boolean {\n        return this.rawSet.contains(this.handle);\n    }\n\n    // /**\n    //  * The unique integer identifier of the first rigid-body this joint it attached to.\n    //  */\n    // public bodyHandle1(): RigidBodyHandle {\n    //     return this.rawSet.jointBodyHandle1(this.handle);\n    // }\n    //\n    // /**\n    //  * The unique integer identifier of the second rigid-body this joint is attached to.\n    //  */\n    // public bodyHandle2(): RigidBodyHandle {\n    //     return this.rawSet.jointBodyHandle2(this.handle);\n    // }\n    //\n    // /**\n    //  * The type of this joint given as a string.\n    //  */\n    // public type(): JointType {\n    //     return this.rawSet.jointType(this.handle);\n    // }\n    //\n    // // #if DIM3\n    // /**\n    //  * The rotation quaternion that aligns this joint's first local axis to the `x` axis.\n    //  */\n    // public frameX1(): Rotation {\n    //     return RotationOps.fromRaw(this.rawSet.jointFrameX1(this.handle));\n    // }\n    //\n    // // #endif\n    //\n    // // #if DIM3\n    // /**\n    //  * The rotation matrix that aligns this joint's second local axis to the `x` axis.\n    //  */\n    // public frameX2(): Rotation {\n    //     return RotationOps.fromRaw(this.rawSet.jointFrameX2(this.handle));\n    // }\n    //\n    // // #endif\n    //\n    // /**\n    //  * The position of the first anchor of this joint.\n    //  *\n    //  * The first anchor gives the position of the points application point on the\n    //  * local frame of the first rigid-body it is attached to.\n    //  */\n    // public anchor1(): Vector {\n    //     return VectorOps.fromRaw(this.rawSet.jointAnchor1(this.handle));\n    // }\n    //\n    // /**\n    //  * The position of the second anchor of this joint.\n    //  *\n    //  * The second anchor gives the position of the points application point on the\n    //  * local frame of the second rigid-body it is attached to.\n    //  */\n    // public anchor2(): Vector {\n    //     return VectorOps.fromRaw(this.rawSet.jointAnchor2(this.handle));\n    // }\n\n    /**\n     * Controls whether contacts are computed between colliders attached\n     * to the rigid-bodies linked by this joint.\n     */\n    public setContactsEnabled(enabled: boolean) {\n        this.rawSet.jointSetContactsEnabled(this.handle, enabled);\n    }\n\n    /**\n     * Indicates if contacts are enabled between colliders attached\n     * to the rigid-bodies linked by this joint.\n     */\n    public contactsEnabled(): boolean {\n        return this.rawSet.jointContactsEnabled(this.handle);\n    }\n}\n\nexport class UnitMultibodyJoint extends MultibodyJoint {\n    /**\n     * The axis left free by this joint.\n     */\n    protected rawAxis?(): RawJointAxis;\n\n    // /**\n    //  * Are the limits enabled for this joint?\n    //  */\n    // public limitsEnabled(): boolean {\n    //     return this.rawSet.jointLimitsEnabled(this.handle, this.rawAxis());\n    // }\n    //\n    // /**\n    //  * The min limit of this joint.\n    //  */\n    // public limitsMin(): number {\n    //     return this.rawSet.jointLimitsMin(this.handle, this.rawAxis());\n    // }\n    //\n    // /**\n    //  * The max limit of this joint.\n    //  */\n    // public limitsMax(): number {\n    //     return this.rawSet.jointLimitsMax(this.handle, this.rawAxis());\n    // }\n    //\n    // public configureMotorModel(model: MotorModel) {\n    //     this.rawSet.jointConfigureMotorModel(this.handle, this.rawAxis(), model);\n    // }\n    //\n    // public configureMotorVelocity(targetVel: number, factor: number) {\n    //     this.rawSet.jointConfigureMotorVelocity(this.handle, this.rawAxis(), targetVel, factor);\n    // }\n    //\n    // public configureMotorPosition(targetPos: number, stiffness: number, damping: number) {\n    //     this.rawSet.jointConfigureMotorPosition(this.handle, this.rawAxis(), targetPos, stiffness, damping);\n    // }\n    //\n    // public configureMotor(targetPos: number, targetVel: number, stiffness: number, damping: number) {\n    //     this.rawSet.jointConfigureMotor(this.handle, this.rawAxis(), targetPos, targetVel, stiffness, damping);\n    // }\n}\n\nexport class FixedMultibodyJoint extends MultibodyJoint {}\n\nexport class PrismaticMultibodyJoint extends UnitMultibodyJoint {\n    public rawAxis(): RawJointAxis {\n        return RawJointAxis.X;\n    }\n}\n\nexport class RevoluteMultibodyJoint extends UnitMultibodyJoint {\n    public rawAxis(): RawJointAxis {\n        return RawJointAxis.AngX;\n    }\n}\n\n// #if DIM3\nexport class SphericalMultibodyJoint extends MultibodyJoint {\n    /* Unsupported by this alpha release.\n    public configureMotorModel(model: MotorModel) {\n        this.rawSet.jointConfigureMotorModel(this.handle, model);\n    }\n\n    public configureMotorVelocity(targetVel: Vector, factor: number) {\n        this.rawSet.jointConfigureBallMotorVelocity(this.handle, targetVel.x, targetVel.y, targetVel.z, factor);\n    }\n\n    public configureMotorPosition(targetPos: Quaternion, stiffness: number, damping: number) {\n        this.rawSet.jointConfigureBallMotorPosition(this.handle, targetPos.w, targetPos.x, targetPos.y, targetPos.z, stiffness, damping);\n    }\n\n    public configureMotor(targetPos: Quaternion, targetVel: Vector, stiffness: number, damping: number) {\n        this.rawSet.jointConfigureBallMotor(this.handle,\n            targetPos.w, targetPos.x, targetPos.y, targetPos.z,\n            targetVel.x, targetVel.y, targetVel.z,\n            stiffness, damping);\n    }\n     */\n}\n// #endif\n", "import {RawMultibodyJointSet} from \"../raw\";\nimport {Coarena} from \"../coarena\";\nimport {RigidBodySet} from \"./rigid_body_set\";\nimport {\n    MultibodyJoint,\n    MultibodyJointHandle,\n    RevoluteMultibodyJoint,\n    FixedMultibodyJoint,\n    PrismaticMultibodyJoint,\n    // #if DIM3\n    SphericalMultibodyJoint,\n    // #endif\n} from \"./multibody_joint\";\nimport {ImpulseJointHandle, JointData, JointType} from \"./impulse_joint\";\nimport {IslandManager} from \"./island_manager\";\nimport {ColliderHandle} from \"../geometry\";\nimport {RigidBodyHandle} from \"./rigid_body\";\n\n/**\n * A set of joints.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `jointSet.free()`\n * once you are done using it (and all the joints it created).\n */\nexport class MultibodyJointSet {\n    raw: RawMultibodyJointSet;\n    private map: Coarena<MultibodyJoint>;\n\n    /**\n     * Release the WASM memory occupied by this joint set.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n\n        if (!!this.map) {\n            this.map.clear();\n        }\n        this.map = undefined;\n    }\n\n    constructor(raw?: RawMultibodyJointSet) {\n        this.raw = raw || new RawMultibodyJointSet();\n        this.map = new Coarena<MultibodyJoint>();\n        // Initialize the map with the existing elements, if any.\n        if (raw) {\n            raw.forEachJointHandle((handle: MultibodyJointHandle) => {\n                this.map.set(handle, MultibodyJoint.newTyped(this.raw, handle));\n            });\n        }\n    }\n\n    /**\n     * Creates a new joint and return its integer handle.\n     *\n     * @param desc - The joint's parameters.\n     * @param parent1 - The handle of the first rigid-body this joint is attached to.\n     * @param parent2 - The handle of the second rigid-body this joint is attached to.\n     * @param wakeUp - Should the attached rigid-bodies be awakened?\n     */\n    public createJoint(\n        desc: JointData,\n        parent1: RigidBodyHandle,\n        parent2: RigidBodyHandle,\n        wakeUp: boolean,\n    ): MultibodyJoint {\n        const rawParams = desc.intoRaw();\n        const handle = this.raw.createJoint(\n            rawParams,\n            parent1,\n            parent2,\n            wakeUp,\n        );\n        rawParams.free();\n        let joint = MultibodyJoint.newTyped(this.raw, handle);\n        this.map.set(handle, joint);\n        return joint;\n    }\n\n    /**\n     * Remove a joint from this set.\n     *\n     * @param handle - The integer handle of the joint.\n     * @param wake_up - If `true`, the rigid-bodies attached by the removed joint will be woken-up automatically.\n     */\n    public remove(handle: MultibodyJointHandle, wake_up: boolean) {\n        this.raw.remove(handle, wake_up);\n        this.map.delete(handle);\n    }\n\n    /**\n     * Internal function, do not call directly.\n     * @param handle\n     */\n    public unmap(handle: MultibodyJointHandle) {\n        this.map.delete(handle);\n    }\n\n    /**\n     * The number of joints on this set.\n     */\n    public len(): number {\n        return this.map.len();\n    }\n\n    /**\n     * Does this set contain a joint with the given handle?\n     *\n     * @param handle - The joint handle to check.\n     */\n    public contains(handle: MultibodyJointHandle): boolean {\n        return this.get(handle) != null;\n    }\n\n    /**\n     * Gets the joint with the given handle.\n     *\n     * Returns `null` if no joint with the specified handle exists.\n     *\n     * @param handle - The integer handle of the joint to retrieve.\n     */\n    public get(handle: MultibodyJointHandle): MultibodyJoint | null {\n        return this.map.get(handle);\n    }\n\n    /**\n     * Applies the given closure to each joint contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n    public forEach(f: (joint: MultibodyJoint) => void) {\n        this.map.forEach(f);\n    }\n\n    /**\n     * Calls the given closure with the integer handle of each multibody joint attached to this rigid-body.\n     *\n     * @param f - The closure called with the integer handle of each multibody joint attached to the rigid-body.\n     */\n    public forEachJointHandleAttachedToRigidBody(\n        handle: RigidBodyHandle,\n        f: (handle: MultibodyJointHandle) => void,\n    ) {\n        this.raw.forEachJointAttachedToRigidBody(handle, f);\n    }\n\n    /**\n     * Gets all joints in the list.\n     *\n     * @returns joint list.\n     */\n    public getAll(): MultibodyJoint[] {\n        return this.map.getAll();\n    }\n}\n", "/**\n * A rule applied to combine coefficients.\n *\n * Use this when configuring the `ColliderDesc` to specify\n * how friction and restitution coefficient should be combined\n * in a contact.\n */\nexport enum CoefficientCombineRule {\n    Average = 0,\n    Min = 1,\n    Multiply = 2,\n    Max = 3,\n}\n", "import {RawCCDSolver} from \"../raw\";\n\n/**\n * The CCD solver responsible for resolving Continuous Collision Detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `ccdSolver.free()`\n * once you are done using it.\n */\nexport class CCDSolver {\n    raw: RawCCDSolver;\n\n    /**\n     * Release the WASM memory occupied by this narrow-phase.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    constructor(raw?: RawCCDSolver) {\n        this.raw = raw || new RawCCDSolver();\n    }\n}\n", "import {RawIslandManager} from \"../raw\";\nimport {RigidBodyHandle} from \"./rigid_body\";\n\n/**\n * The CCD solver responsible for resolving Continuous Collision Detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `ccdSolver.free()`\n * once you are done using it.\n */\nexport class IslandManager {\n    raw: RawIslandManager;\n\n    /**\n     * Release the WASM memory occupied by this narrow-phase.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    constructor(raw?: RawIslandManager) {\n        this.raw = raw || new RawIslandManager();\n    }\n\n    /**\n     * Applies the given closure to the handle of each active rigid-bodies contained by this set.\n     *\n     * A rigid-body is active if it is not sleeping, i.e., if it moved recently.\n     *\n     * @param f - The closure to apply.\n     */\n    public forEachActiveRigidBodyHandle(f: (handle: RigidBodyHandle) => void) {\n        this.raw.forEachActiveRigidBodyHandle(f);\n    }\n}\n", "import {RawBroadPhase} from \"../raw\";\n\n/**\n * The broad-phase used for coarse collision-detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `broadPhase.free()`\n * once you are done using it.\n */\nexport class BroadPhase {\n    raw: RawBroadPhase;\n\n    /**\n     * Release the WASM memory occupied by this broad-phase.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    constructor(raw?: RawBroadPhase) {\n        this.raw = raw || new RawBroadPhase();\n    }\n}\n", "import {RawNarrowPhase, RawContactManifold} from \"../raw\";\nimport {ColliderHandle} from \"./collider\";\nimport {Vector, VectorOps} from \"../math\";\n\n/**\n * The narrow-phase used for precise collision-detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `narrowPhase.free()`\n * once you are done using it.\n */\nexport class NarrowPhase {\n    raw: RawNarrowPhase;\n    tempManifold: TempContactManifold;\n\n    /**\n     * Release the WASM memory occupied by this narrow-phase.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    constructor(raw?: RawNarrowPhase) {\n        this.raw = raw || new RawNarrowPhase();\n        this.tempManifold = new TempContactManifold(null);\n    }\n\n    /**\n     * Enumerates all the colliders potentially in contact with the given collider.\n     *\n     * @param collider1 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each collider that is in contact with `collider1`.\n     */\n    public contactsWith(\n        collider1: ColliderHandle,\n        f: (collider2: ColliderHandle) => void,\n    ) {\n        this.raw.contacts_with(collider1, f);\n    }\n\n    /**\n     * Enumerates all the colliders intersecting the given colliders, assuming one of them\n     * is a sensor.\n     */\n    public intersectionsWith(\n        collider1: ColliderHandle,\n        f: (collider2: ColliderHandle) => void,\n    ) {\n        this.raw.intersections_with(collider1, f);\n    }\n\n    /**\n     * Iterates through all the contact manifolds between the given pair of colliders.\n     *\n     * @param collider1 - The first collider involved in the contact.\n     * @param collider2 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each contact manifold between the two colliders. If the second argument\n     *            passed to this closure is `true`, then the contact manifold data is flipped, i.e., methods like `localNormal1`\n     *            actually apply to the `collider2` and fields like `localNormal2` apply to the `collider1`.\n     */\n    public contactPair(\n        collider1: ColliderHandle,\n        collider2: ColliderHandle,\n        f: (manifold: TempContactManifold, flipped: boolean) => void,\n    ) {\n        const rawPair = this.raw.contact_pair(collider1, collider2);\n\n        if (!!rawPair) {\n            const flipped = rawPair.collider1() != collider1;\n\n            let i;\n            for (i = 0; i < rawPair.numContactManifolds(); ++i) {\n                this.tempManifold.raw = rawPair.contactManifold(i);\n                if (!!this.tempManifold.raw) {\n                    f(this.tempManifold, flipped);\n                }\n\n                // SAFETY: The RawContactManifold stores a raw pointer that will be invalidated\n                //         at the next timestep. So we must be sure to free the pair here\n                //         to avoid unsoundness in the Rust code.\n                this.tempManifold.free();\n            }\n            rawPair.free();\n        }\n    }\n\n    /**\n     * Returns `true` if `collider1` and `collider2` intersect and at least one of them is a sensor.\n     * @param collider1 \u2212 The first collider involved in the intersection.\n     * @param collider2 \u2212 The second collider involved in the intersection.\n     */\n    public intersectionPair(\n        collider1: ColliderHandle,\n        collider2: ColliderHandle,\n    ): boolean {\n        return this.raw.intersection_pair(collider1, collider2);\n    }\n}\n\nexport class TempContactManifold {\n    raw: RawContactManifold;\n\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    constructor(raw: RawContactManifold) {\n        this.raw = raw;\n    }\n\n    public normal(): Vector {\n        return VectorOps.fromRaw(this.raw.normal());\n    }\n\n    public localNormal1(): Vector {\n        return VectorOps.fromRaw(this.raw.local_n1());\n    }\n\n    public localNormal2(): Vector {\n        return VectorOps.fromRaw(this.raw.local_n2());\n    }\n\n    public subshape1(): number {\n        return this.raw.subshape1();\n    }\n\n    public subshape2(): number {\n        return this.raw.subshape2();\n    }\n\n    public numContacts(): number {\n        return this.raw.num_contacts();\n    }\n\n    public localContactPoint1(i: number): Vector | null {\n        return VectorOps.fromRaw(this.raw.contact_local_p1(i));\n    }\n\n    public localContactPoint2(i: number): Vector | null {\n        return VectorOps.fromRaw(this.raw.contact_local_p2(i));\n    }\n\n    public contactDist(i: number): number {\n        return this.raw.contact_dist(i);\n    }\n\n    public contactFid1(i: number): number {\n        return this.raw.contact_fid1(i);\n    }\n\n    public contactFid2(i: number): number {\n        return this.raw.contact_fid2(i);\n    }\n\n    public contactImpulse(i: number): number {\n        return this.raw.contact_impulse(i);\n    }\n\n\n    // #if DIM3\n    public contactTangentImpulseX(i: number): number {\n        return this.raw.contact_tangent_impulse_x(i);\n    }\n\n    public contactTangentImpulseY(i: number): number {\n        return this.raw.contact_tangent_impulse_y(i);\n    }\n    // #endif\n\n    public numSolverContacts(): number {\n        return this.raw.num_solver_contacts();\n    }\n\n    public solverContactPoint(i: number): Vector {\n        return VectorOps.fromRaw(this.raw.solver_contact_point(i));\n    }\n\n    public solverContactDist(i: number): number {\n        return this.raw.solver_contact_dist(i);\n    }\n\n    public solverContactFriction(i: number): number {\n        return this.raw.solver_contact_friction(i);\n    }\n\n    public solverContactRestitution(i: number): number {\n        return this.raw.solver_contact_restitution(i);\n    }\n\n    public solverContactTangentVelocity(i: number): Vector {\n        return VectorOps.fromRaw(this.raw.solver_contact_tangent_velocity(i));\n    }\n}\n", "import {Vector, VectorOps} from \"../math\";\nimport {RawShapeContact} from \"../raw\";\n\n/**\n * The contact info between two shapes.\n */\nexport class ShapeContact {\n    /**\n     * Distance between the two contact points.\n     * If this is negative, this contact represents a penetration.\n     */\n    distance: number;\n\n    /**\n     * Position of the contact on the first shape.\n     */\n    point1: Vector;\n\n    /**\n     * Position of the contact on the second shape.\n     */\n    point2: Vector;\n\n    /**\n     * Contact normal, pointing towards the exterior of the first shape.\n     */\n    normal1: Vector;\n\n    /**\n     * Contact normal, pointing towards the exterior of the second shape.\n     * If these contact data are expressed in world-space, this normal is equal to -normal1.\n     */\n    normal2: Vector;\n\n    constructor(\n        dist: number,\n        point1: Vector,\n        point2: Vector,\n        normal1: Vector,\n        normal2: Vector,\n    ) {\n        this.distance = dist;\n        this.point1 = point1;\n        this.point2 = point2;\n        this.normal1 = normal1;\n        this.normal2 = normal2;\n    }\n\n    public static fromRaw(raw: RawShapeContact): ShapeContact {\n        if (!raw) return null;\n\n        const result = new ShapeContact(\n            raw.distance(),\n            VectorOps.fromRaw(raw.point1()),\n            VectorOps.fromRaw(raw.point2()),\n            VectorOps.fromRaw(raw.normal1()),\n            VectorOps.fromRaw(raw.normal2()),\n        );\n        raw.free();\n        return result;\n    }\n}\n", "\n// #if DIM3\nexport enum FeatureType {\n    Vertex,\n    Edge,\n    Face,\n    Unknown,\n}\n// #endif\n", "import {Collider, ColliderHandle} from \"./collider\";\nimport {Vector, VectorOps} from \"../math\";\nimport {RawPointColliderProjection, RawPointProjection} from \"../raw\";\nimport {FeatureType} from \"./feature\";\nimport {ColliderSet} from \"./collider_set\";\n\n/**\n * The projection of a point on a collider.\n */\nexport class PointProjection {\n    /**\n     * The projection of the point on the collider.\n     */\n    point: Vector;\n    /**\n     * Is the point inside of the collider?\n     */\n    isInside: boolean;\n\n    constructor(point: Vector, isInside: boolean) {\n        this.point = point;\n        this.isInside = isInside;\n    }\n\n    public static fromRaw(raw: RawPointProjection): PointProjection {\n        if (!raw) return null;\n\n        const result = new PointProjection(\n            VectorOps.fromRaw(raw.point()),\n            raw.isInside(),\n        );\n        raw.free();\n        return result;\n    }\n}\n\n/**\n * The projection of a point on a collider (includes the collider handle).\n */\nexport class PointColliderProjection {\n    /**\n     * The collider hit by the ray.\n     */\n    collider: Collider;\n    /**\n     * The projection of the point on the collider.\n     */\n    point: Vector;\n    /**\n     * Is the point inside of the collider?\n     */\n    isInside: boolean;\n\n    /**\n     * The type of the geometric feature the point was projected on.\n     */\n    featureType = FeatureType.Unknown;\n\n    /**\n     * The id of the geometric feature the point was projected on.\n     */\n    featureId: number | undefined = undefined;\n\n    constructor(\n        collider: Collider,\n        point: Vector,\n        isInside: boolean,\n        featureType?: FeatureType,\n        featureId?: number,\n    ) {\n        this.collider = collider;\n        this.point = point;\n        this.isInside = isInside;\n        if (featureId !== undefined) this.featureId = featureId;\n        if (featureType !== undefined) this.featureType = featureType;\n    }\n\n    public static fromRaw(\n        colliderSet: ColliderSet,\n        raw: RawPointColliderProjection,\n    ): PointColliderProjection {\n        if (!raw) return null;\n\n        const result = new PointColliderProjection(\n            colliderSet.get(raw.colliderHandle()),\n            VectorOps.fromRaw(raw.point()),\n            raw.isInside(),\n            raw.featureType(),\n            raw.featureId(),\n        );\n        raw.free();\n        return result;\n    }\n}\n", "import {Vector, VectorOps} from \"../math\";\nimport {\n    RawRayColliderIntersection,\n    RawRayColliderToi,\n    RawRayIntersection,\n} from \"../raw\";\nimport {Collider} from \"./collider\";\nimport {FeatureType} from \"./feature\";\nimport {ColliderSet} from \"./collider_set\";\n\n/**\n * A ray. This is a directed half-line.\n */\nexport class Ray {\n    /**\n     * The starting point of the ray.\n     */\n    public origin: Vector;\n    /**\n     * The direction of propagation of the ray.\n     */\n    public dir: Vector;\n\n    /**\n     * Builds a ray from its origin and direction.\n     *\n     * @param origin - The ray's starting point.\n     * @param dir - The ray's direction of propagation.\n     */\n    constructor(origin: Vector, dir: Vector) {\n        this.origin = origin;\n        this.dir = dir;\n    }\n\n    public pointAt(t: number): Vector {\n        return {\n            x: this.origin.x + this.dir.x * t,\n            y: this.origin.y + this.dir.y * t,\n            // #if DIM3\n            z: this.origin.z + this.dir.z * t,\n            // #endif\n        };\n    }\n}\n\n/**\n * The intersection between a ray and a collider.\n */\nexport class RayIntersection {\n    /**\n     * The time-of-impact of the ray with the collider.\n     *\n     * The hit point is obtained from the ray's origin and direction: `origin + dir * toi`.\n     */\n    toi: number;\n    /**\n     * The normal of the collider at the hit point.\n     */\n    normal: Vector;\n\n    /**\n     * The type of the geometric feature the point was projected on.\n     */\n    featureType = FeatureType.Unknown;\n\n    /**\n     * The id of the geometric feature the point was projected on.\n     */\n    featureId: number | undefined = undefined;\n\n    constructor(\n        toi: number,\n        normal: Vector,\n        featureType?: FeatureType,\n        featureId?: number,\n    ) {\n        this.toi = toi;\n        this.normal = normal;\n        if (featureId !== undefined) this.featureId = featureId;\n        if (featureType !== undefined) this.featureType = featureType;\n    }\n\n    public static fromRaw(raw: RawRayIntersection): RayIntersection {\n        if (!raw) return null;\n\n        const result = new RayIntersection(\n            raw.toi(),\n            VectorOps.fromRaw(raw.normal()),\n            raw.featureType(),\n            raw.featureId(),\n        );\n        raw.free();\n        return result;\n    }\n}\n\n/**\n * The intersection between a ray and a collider (includes the collider handle).\n */\nexport class RayColliderIntersection {\n    /**\n     * The collider hit by the ray.\n     */\n    collider: Collider;\n    /**\n     * The time-of-impact of the ray with the collider.\n     *\n     * The hit point is obtained from the ray's origin and direction: `origin + dir * toi`.\n     */\n    toi: number;\n    /**\n     * The normal of the collider at the hit point.\n     */\n    normal: Vector;\n\n    /**\n     * The type of the geometric feature the point was projected on.\n     */\n    featureType = FeatureType.Unknown;\n\n    /**\n     * The id of the geometric feature the point was projected on.\n     */\n    featureId: number | undefined = undefined;\n\n    constructor(\n        collider: Collider,\n        toi: number,\n        normal: Vector,\n        featureType?: FeatureType,\n        featureId?: number,\n    ) {\n        this.collider = collider;\n        this.toi = toi;\n        this.normal = normal;\n        if (featureId !== undefined) this.featureId = featureId;\n        if (featureType !== undefined) this.featureType = featureType;\n    }\n\n    public static fromRaw(\n        colliderSet: ColliderSet,\n        raw: RawRayColliderIntersection,\n    ): RayColliderIntersection {\n        if (!raw) return null;\n\n        const result = new RayColliderIntersection(\n            colliderSet.get(raw.colliderHandle()),\n            raw.toi(),\n            VectorOps.fromRaw(raw.normal()),\n            raw.featureType(),\n            raw.featureId(),\n        );\n        raw.free();\n        return result;\n    }\n}\n\n/**\n * The time of impact between a ray and a collider.\n */\nexport class RayColliderToi {\n    /**\n     * The handle of the collider hit by the ray.\n     */\n    collider: Collider;\n    /**\n     * The time-of-impact of the ray with the collider.\n     *\n     * The hit point is obtained from the ray's origin and direction: `origin + dir * toi`.\n     */\n    toi: number;\n\n    constructor(collider: Collider, toi: number) {\n        this.collider = collider;\n        this.toi = toi;\n    }\n\n    public static fromRaw(\n        colliderSet: ColliderSet,\n        raw: RawRayColliderToi,\n    ): RayColliderToi {\n        if (!raw) return null;\n\n        const result = new RayColliderToi(\n            colliderSet.get(raw.colliderHandle()),\n            raw.toi(),\n        );\n        raw.free();\n        return result;\n    }\n}\n", "import {Collider} from \"./collider\";\nimport {Vector, VectorOps} from \"../math\";\nimport {RawShapeTOI, RawShapeColliderTOI} from \"../raw\";\nimport {ColliderSet} from \"./collider_set\";\n\n/**\n * The intersection between a ray and a collider.\n */\nexport class ShapeTOI {\n    /**\n     * The time of impact of the two shapes.\n     */\n    toi: number;\n    /**\n     * The local-space contact point on the first shape, at\n     * the time of impact.\n     */\n    witness1: Vector;\n    /**\n     * The local-space contact point on the second shape, at\n     * the time of impact.\n     */\n    witness2: Vector;\n    /**\n     * The local-space normal on the first shape, at\n     * the time of impact.\n     */\n    normal1: Vector;\n    /**\n     * The local-space normal on the second shape, at\n     * the time of impact.\n     */\n    normal2: Vector;\n\n    constructor(\n        toi: number,\n        witness1: Vector,\n        witness2: Vector,\n        normal1: Vector,\n        normal2: Vector,\n    ) {\n        this.toi = toi;\n        this.witness1 = witness1;\n        this.witness2 = witness2;\n        this.normal1 = normal1;\n        this.normal2 = normal2;\n    }\n\n    public static fromRaw(\n        colliderSet: ColliderSet,\n        raw: RawShapeTOI,\n    ): ShapeTOI {\n        if (!raw) return null;\n\n        const result = new ShapeTOI(\n            raw.toi(),\n            VectorOps.fromRaw(raw.witness1()),\n            VectorOps.fromRaw(raw.witness2()),\n            VectorOps.fromRaw(raw.normal1()),\n            VectorOps.fromRaw(raw.normal2()),\n        );\n        raw.free();\n        return result;\n    }\n}\n\n/**\n * The intersection between a ray and a collider.\n */\nexport class ShapeColliderTOI extends ShapeTOI {\n    /**\n     * The handle of the collider hit by the ray.\n     */\n    collider: Collider;\n\n    constructor(\n        collider: Collider,\n        toi: number,\n        witness1: Vector,\n        witness2: Vector,\n        normal1: Vector,\n        normal2: Vector,\n    ) {\n        super(toi, witness1, witness2, normal1, normal2);\n        this.collider = collider;\n    }\n\n    public static fromRaw(\n        colliderSet: ColliderSet,\n        raw: RawShapeColliderTOI,\n    ): ShapeColliderTOI {\n        if (!raw) return null;\n\n        const result = new ShapeColliderTOI(\n            colliderSet.get(raw.colliderHandle()),\n            raw.toi(),\n            VectorOps.fromRaw(raw.witness1()),\n            VectorOps.fromRaw(raw.witness2()),\n            VectorOps.fromRaw(raw.normal1()),\n            VectorOps.fromRaw(raw.normal2()),\n        );\n        raw.free();\n        return result;\n    }\n}\n", "import {Vector, VectorOps, Rotation, RotationOps} from \"../math\";\nimport {RawColliderSet, RawShape} from \"../raw\";\nimport {ShapeContact} from \"./contact\";\nimport {PointProjection} from \"./point\";\nimport {Ray, RayIntersection} from \"./ray\";\nimport {ShapeTOI} from \"./toi\";\nimport {ColliderHandle} from \"./collider\";\n\nexport abstract class Shape {\n    public abstract intoRaw(): RawShape;\n\n    /**\n     * The concrete type of this shape.\n     */\n    public abstract get type(): ShapeType;\n\n    /**\n     * instant mode without cache\n     */\n    public static fromRaw(\n        rawSet: RawColliderSet,\n        handle: ColliderHandle,\n    ): Shape {\n        const rawType = rawSet.coShapeType(handle);\n\n        let extents: Vector;\n        let borderRadius: number;\n        let vs: Float32Array;\n        let indices: Uint32Array;\n        let halfHeight: number;\n        let radius: number;\n        let normal: Vector;\n\n        switch (rawType) {\n            case ShapeType.Ball:\n                return new Ball(rawSet.coRadius(handle));\n            case ShapeType.Cuboid:\n                extents = rawSet.coHalfExtents(handle);\n\n                // #if DIM3\n                return new Cuboid(extents.x, extents.y, extents.z);\n            // #endif\n\n            case ShapeType.RoundCuboid:\n                extents = rawSet.coHalfExtents(handle);\n                borderRadius = rawSet.coRoundRadius(handle);\n\n\n                // #if DIM3\n                return new RoundCuboid(\n                    extents.x,\n                    extents.y,\n                    extents.z,\n                    borderRadius,\n                );\n            // #endif\n\n            case ShapeType.Capsule:\n                halfHeight = rawSet.coHalfHeight(handle);\n                radius = rawSet.coRadius(handle);\n                return new Capsule(halfHeight, radius);\n            case ShapeType.Segment:\n                vs = rawSet.coVertices(handle);\n\n\n                // #if DIM3\n                return new Segment(\n                    VectorOps.new(vs[0], vs[1], vs[2]),\n                    VectorOps.new(vs[3], vs[4], vs[5]),\n                );\n            // #endif\n\n            case ShapeType.Polyline:\n                vs = rawSet.coVertices(handle);\n                indices = rawSet.coIndices(handle);\n                return new Polyline(vs, indices);\n            case ShapeType.Triangle:\n                vs = rawSet.coVertices(handle);\n\n\n                // #if DIM3\n                return new Triangle(\n                    VectorOps.new(vs[0], vs[1], vs[2]),\n                    VectorOps.new(vs[3], vs[4], vs[5]),\n                    VectorOps.new(vs[6], vs[7], vs[8]),\n                );\n            // #endif\n\n            case ShapeType.RoundTriangle:\n                vs = rawSet.coVertices(handle);\n                borderRadius = rawSet.coRoundRadius(handle);\n\n\n                // #if DIM3\n                return new RoundTriangle(\n                    VectorOps.new(vs[0], vs[1], vs[2]),\n                    VectorOps.new(vs[3], vs[4], vs[5]),\n                    VectorOps.new(vs[6], vs[7], vs[8]),\n                    borderRadius,\n                );\n            // #endif\n\n            case ShapeType.HalfSpace:\n                normal = VectorOps.fromRaw(rawSet.coHalfspaceNormal(handle));\n                return new HalfSpace(normal);\n\n            case ShapeType.TriMesh:\n                vs = rawSet.coVertices(handle);\n                indices = rawSet.coIndices(handle);\n                return new TriMesh(vs, indices);\n\n            case ShapeType.HeightField:\n                const scale = rawSet.coHeightfieldScale(handle);\n                const heights = rawSet.coHeightfieldHeights(handle);\n\n\n                // #if DIM3\n                const nrows = rawSet.coHeightfieldNRows(handle);\n                const ncols = rawSet.coHeightfieldNCols(handle);\n                return new Heightfield(nrows, ncols, heights, scale);\n            // #endif\n\n\n            // #if DIM3\n            case ShapeType.ConvexPolyhedron:\n                vs = rawSet.coVertices(handle);\n                indices = rawSet.coIndices(handle);\n                return new ConvexPolyhedron(vs, indices);\n            case ShapeType.RoundConvexPolyhedron:\n                vs = rawSet.coVertices(handle);\n                indices = rawSet.coIndices(handle);\n                borderRadius = rawSet.coRoundRadius(handle);\n                return new RoundConvexPolyhedron(vs, indices, borderRadius);\n            case ShapeType.Cylinder:\n                halfHeight = rawSet.coHalfHeight(handle);\n                radius = rawSet.coRadius(handle);\n                return new Cylinder(halfHeight, radius);\n            case ShapeType.RoundCylinder:\n                halfHeight = rawSet.coHalfHeight(handle);\n                radius = rawSet.coRadius(handle);\n                borderRadius = rawSet.coRoundRadius(handle);\n                return new RoundCylinder(halfHeight, radius, borderRadius);\n            case ShapeType.Cone:\n                halfHeight = rawSet.coHalfHeight(handle);\n                radius = rawSet.coRadius(handle);\n                return new Cone(halfHeight, radius);\n            case ShapeType.RoundCone:\n                halfHeight = rawSet.coHalfHeight(handle);\n                radius = rawSet.coRadius(handle);\n                borderRadius = rawSet.coRoundRadius(handle);\n                return new RoundCone(halfHeight, radius, borderRadius);\n            // #endif\n\n            default:\n                throw new Error(\"unknown shape type: \" + rawType);\n        }\n    }\n\n    /**\n     * Computes the time of impact between two moving shapes.\n     * @param shapePos1 - The initial position of this sahpe.\n     * @param shapeRot1 - The rotation of this shape.\n     * @param shapeVel1 - The velocity of this shape.\n     * @param shape2 - The second moving shape.\n     * @param shapePos2 - The initial position of the second shape.\n     * @param shapeRot2 - The rotation of the second shape.\n     * @param shapeVel2 - The velocity of the second shape.\n     * @param maxToi - The maximum time when the impact can happen.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast won\u2019t immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that it\u2019s on a path to exist that penetration state.\n     * @returns If the two moving shapes collider at some point along their trajectories, this returns the\n     *  time at which the two shape collider as well as the contact information during the impact. Returns\n     *  `null`if the two shapes never collide along their paths.\n     */\n    public castShape(\n        shapePos1: Vector,\n        shapeRot1: Rotation,\n        shapeVel1: Vector,\n        shape2: Shape,\n        shapePos2: Vector,\n        shapeRot2: Rotation,\n        shapeVel2: Vector,\n        maxToi: number,\n        stopAtPenetration: boolean,\n    ): ShapeTOI | null {\n        let rawPos1 = VectorOps.intoRaw(shapePos1);\n        let rawRot1 = RotationOps.intoRaw(shapeRot1);\n        let rawVel1 = VectorOps.intoRaw(shapeVel1);\n        let rawPos2 = VectorOps.intoRaw(shapePos2);\n        let rawRot2 = RotationOps.intoRaw(shapeRot2);\n        let rawVel2 = VectorOps.intoRaw(shapeVel2);\n\n        let rawShape1 = this.intoRaw();\n        let rawShape2 = shape2.intoRaw();\n\n        let result = ShapeTOI.fromRaw(\n            null,\n            rawShape1.castShape(\n                rawPos1,\n                rawRot1,\n                rawVel1,\n                rawShape2,\n                rawPos2,\n                rawRot2,\n                rawVel2,\n                maxToi,\n                stopAtPenetration,\n            ),\n        );\n\n        rawPos1.free();\n        rawRot1.free();\n        rawVel1.free();\n        rawPos2.free();\n        rawRot2.free();\n        rawVel2.free();\n\n        rawShape1.free();\n        rawShape2.free();\n\n        return result;\n    }\n\n    /**\n     * Tests if this shape intersects another shape.\n     *\n     * @param shapePos1 - The position of this shape.\n     * @param shapeRot1 - The rotation of this shape.\n     * @param shape2  - The second shape to test.\n     * @param shapePos2 - The position of the second shape.\n     * @param shapeRot2 - The rotation of the second shape.\n     * @returns `true` if the two shapes intersect, `false` if they don\u2019t.\n     */\n    public intersectsShape(\n        shapePos1: Vector,\n        shapeRot1: Rotation,\n        shape2: Shape,\n        shapePos2: Vector,\n        shapeRot2: Rotation,\n    ): boolean {\n        let rawPos1 = VectorOps.intoRaw(shapePos1);\n        let rawRot1 = RotationOps.intoRaw(shapeRot1);\n        let rawPos2 = VectorOps.intoRaw(shapePos2);\n        let rawRot2 = RotationOps.intoRaw(shapeRot2);\n\n        let rawShape1 = this.intoRaw();\n        let rawShape2 = shape2.intoRaw();\n\n        let result = rawShape1.intersectsShape(\n            rawPos1,\n            rawRot1,\n            rawShape2,\n            rawPos2,\n            rawRot2,\n        );\n\n        rawPos1.free();\n        rawRot1.free();\n        rawPos2.free();\n        rawRot2.free();\n\n        rawShape1.free();\n        rawShape2.free();\n\n        return result;\n    }\n\n    /**\n     * Computes one pair of contact points between two shapes.\n     *\n     * @param shapePos1 - The initial position of this sahpe.\n     * @param shapeRot1 - The rotation of this shape.\n     * @param shape2 - The second shape.\n     * @param shapePos2 - The initial position of the second shape.\n     * @param shapeRot2 - The rotation of the second shape.\n     * @param prediction - The prediction value, if the shapes are separated by a distance greater than this value, test will fail.\n     * @returns `null` if the shapes are separated by a distance greater than prediction, otherwise contact details. The result is given in world-space.\n     */\n    contactShape(\n        shapePos1: Vector,\n        shapeRot1: Rotation,\n        shape2: Shape,\n        shapePos2: Vector,\n        shapeRot2: Rotation,\n        prediction: number,\n    ): ShapeContact | null {\n        let rawPos1 = VectorOps.intoRaw(shapePos1);\n        let rawRot1 = RotationOps.intoRaw(shapeRot1);\n        let rawPos2 = VectorOps.intoRaw(shapePos2);\n        let rawRot2 = RotationOps.intoRaw(shapeRot2);\n\n        let rawShape1 = this.intoRaw();\n        let rawShape2 = shape2.intoRaw();\n\n        let result = ShapeContact.fromRaw(\n            rawShape1.contactShape(\n                rawPos1,\n                rawRot1,\n                rawShape2,\n                rawPos2,\n                rawRot2,\n                prediction,\n            ),\n        );\n\n        rawPos1.free();\n        rawRot1.free();\n        rawPos2.free();\n        rawRot2.free();\n\n        rawShape1.free();\n        rawShape2.free();\n\n        return result;\n    }\n\n    containsPoint(\n        shapePos: Vector,\n        shapeRot: Rotation,\n        point: Vector,\n    ): boolean {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawPoint = VectorOps.intoRaw(point);\n        let rawShape = this.intoRaw();\n\n        let result = rawShape.containsPoint(rawPos, rawRot, rawPoint);\n\n        rawPos.free();\n        rawRot.free();\n        rawPoint.free();\n        rawShape.free();\n\n        return result;\n    }\n\n    projectPoint(\n        shapePos: Vector,\n        shapeRot: Rotation,\n        point: Vector,\n        solid: boolean,\n    ): PointProjection {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawPoint = VectorOps.intoRaw(point);\n        let rawShape = this.intoRaw();\n\n        let result = PointProjection.fromRaw(\n            rawShape.projectPoint(rawPos, rawRot, rawPoint, solid),\n        );\n\n        rawPos.free();\n        rawRot.free();\n        rawPoint.free();\n        rawShape.free();\n\n        return result;\n    }\n\n    intersectsRay(\n        ray: Ray,\n        shapePos: Vector,\n        shapeRot: Rotation,\n        maxToi: number,\n    ): boolean {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawRayOrig = VectorOps.intoRaw(ray.origin);\n        let rawRayDir = VectorOps.intoRaw(ray.dir);\n        let rawShape = this.intoRaw();\n\n        let result = rawShape.intersectsRay(\n            rawPos,\n            rawRot,\n            rawRayOrig,\n            rawRayDir,\n            maxToi,\n        );\n\n        rawPos.free();\n        rawRot.free();\n        rawRayOrig.free();\n        rawRayDir.free();\n        rawShape.free();\n\n        return result;\n    }\n\n    castRay(\n        ray: Ray,\n        shapePos: Vector,\n        shapeRot: Rotation,\n        maxToi: number,\n        solid: boolean,\n    ): number {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawRayOrig = VectorOps.intoRaw(ray.origin);\n        let rawRayDir = VectorOps.intoRaw(ray.dir);\n        let rawShape = this.intoRaw();\n\n        let result = rawShape.castRay(\n            rawPos,\n            rawRot,\n            rawRayOrig,\n            rawRayDir,\n            maxToi,\n            solid,\n        );\n\n        rawPos.free();\n        rawRot.free();\n        rawRayOrig.free();\n        rawRayDir.free();\n        rawShape.free();\n\n        return result;\n    }\n\n    castRayAndGetNormal(\n        ray: Ray,\n        shapePos: Vector,\n        shapeRot: Rotation,\n        maxToi: number,\n        solid: boolean,\n    ): RayIntersection {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawRayOrig = VectorOps.intoRaw(ray.origin);\n        let rawRayDir = VectorOps.intoRaw(ray.dir);\n        let rawShape = this.intoRaw();\n\n        let result = RayIntersection.fromRaw(\n            rawShape.castRayAndGetNormal(\n                rawPos,\n                rawRot,\n                rawRayOrig,\n                rawRayDir,\n                maxToi,\n                solid,\n            ),\n        );\n\n        rawPos.free();\n        rawRot.free();\n        rawRayOrig.free();\n        rawRayDir.free();\n        rawShape.free();\n\n        return result;\n    }\n}\n\n\n// #if DIM3\n/**\n * An enumeration representing the type of a shape.\n */\nexport enum ShapeType {\n    Ball = 0,\n    Cuboid = 1,\n    Capsule = 2,\n    Segment = 3,\n    Polyline = 4,\n    Triangle = 5,\n    TriMesh = 6,\n    HeightField = 7,\n    // Compound = 8,\n    ConvexPolyhedron = 9,\n    Cylinder = 10,\n    Cone = 11,\n    RoundCuboid = 12,\n    RoundTriangle = 13,\n    RoundCylinder = 14,\n    RoundCone = 15,\n    RoundConvexPolyhedron = 16,\n    HalfSpace = 17,\n}\n\n// #endif\n\n/**\n * A shape that is a sphere in 3D and a circle in 2D.\n */\nexport class Ball extends Shape {\n    readonly type = ShapeType.Ball;\n\n    /**\n     * The balls radius.\n     */\n    radius: number;\n\n    /**\n     * Creates a new ball with the given radius.\n     * @param radius - The balls radius.\n     */\n    constructor(radius: number) {\n        super();\n        this.radius = radius;\n    }\n\n    public intoRaw(): RawShape {\n        return RawShape.ball(this.radius);\n    }\n}\n\nexport class HalfSpace extends Shape {\n    readonly type = ShapeType.HalfSpace;\n\n    /**\n     * The outward normal of the half-space.\n     */\n    normal: Vector;\n\n    /**\n     * Creates a new halfspace delimited by an infinite plane.\n     *\n     * @param normal - The outward normal of the plane.\n     */\n    constructor(normal: Vector) {\n        super();\n        this.normal = normal;\n    }\n\n    public intoRaw(): RawShape {\n        let n = VectorOps.intoRaw(this.normal);\n        let result = RawShape.halfspace(n);\n        n.free();\n        return result;\n    }\n}\n\n/**\n * A shape that is a box in 3D and a rectangle in 2D.\n */\nexport class Cuboid extends Shape {\n    readonly type = ShapeType.Cuboid;\n\n    /**\n     * The half extent of the cuboid along each coordinate axis.\n     */\n    halfExtents: Vector;\n\n\n    // #if DIM3\n    /**\n     * Creates a new 3D cuboid.\n     * @param hx - The half width of the cuboid.\n     * @param hy - The half height of the cuboid.\n     * @param hz - The half depth of the cuboid.\n     */\n    constructor(hx: number, hy: number, hz: number) {\n        super();\n        this.halfExtents = VectorOps.new(hx, hy, hz);\n    }\n\n    // #endif\n\n    public intoRaw(): RawShape {\n\n        // #if DIM3\n        return RawShape.cuboid(\n            this.halfExtents.x,\n            this.halfExtents.y,\n            this.halfExtents.z,\n        );\n        // #endif\n    }\n}\n\n/**\n * A shape that is a box in 3D and a rectangle in 2D, with round corners.\n */\nexport class RoundCuboid extends Shape {\n    readonly type = ShapeType.RoundCuboid;\n\n    /**\n     * The half extent of the cuboid along each coordinate axis.\n     */\n    halfExtents: Vector;\n\n    /**\n     * The radius of the cuboid's round border.\n     */\n    borderRadius: number;\n\n\n    // #if DIM3\n    /**\n     * Creates a new 3D cuboid.\n     * @param hx - The half width of the cuboid.\n     * @param hy - The half height of the cuboid.\n     * @param hz - The half depth of the cuboid.\n     * @param borderRadius - The radius of the borders of this cuboid. This will\n     *   effectively increase the half-extents of the cuboid by this radius.\n     */\n    constructor(hx: number, hy: number, hz: number, borderRadius: number) {\n        super();\n        this.halfExtents = VectorOps.new(hx, hy, hz);\n        this.borderRadius = borderRadius;\n    }\n\n    // #endif\n\n    public intoRaw(): RawShape {\n\n        // #if DIM3\n        return RawShape.roundCuboid(\n            this.halfExtents.x,\n            this.halfExtents.y,\n            this.halfExtents.z,\n            this.borderRadius,\n        );\n        // #endif\n    }\n}\n\n/**\n * A shape that is a capsule.\n */\nexport class Capsule extends Shape {\n    readonly type = ShapeType.Capsule;\n\n    /**\n     * The radius of the capsule's basis.\n     */\n    radius: number;\n\n    /**\n     * The capsule's half height, along the `y` axis.\n     */\n    halfHeight: number;\n\n    /**\n     * Creates a new capsule with the given radius and half-height.\n     * @param halfHeight - The balls half-height along the `y` axis.\n     * @param radius - The balls radius.\n     */\n    constructor(halfHeight: number, radius: number) {\n        super();\n        this.halfHeight = halfHeight;\n        this.radius = radius;\n    }\n\n    public intoRaw(): RawShape {\n        return RawShape.capsule(this.halfHeight, this.radius);\n    }\n}\n\n/**\n * A shape that is a segment.\n */\nexport class Segment extends Shape {\n    readonly type = ShapeType.Segment;\n\n    /**\n     * The first point of the segment.\n     */\n    a: Vector;\n\n    /**\n     * The second point of the segment.\n     */\n    b: Vector;\n\n    /**\n     * Creates a new segment shape.\n     * @param a - The first point of the segment.\n     * @param b - The second point of the segment.\n     */\n    constructor(a: Vector, b: Vector) {\n        super();\n        this.a = a;\n        this.b = b;\n    }\n\n    public intoRaw(): RawShape {\n        let ra = VectorOps.intoRaw(this.a);\n        let rb = VectorOps.intoRaw(this.b);\n        let result = RawShape.segment(ra, rb);\n        ra.free();\n        rb.free();\n        return result;\n    }\n}\n\n/**\n * A shape that is a segment.\n */\nexport class Triangle extends Shape {\n    readonly type = ShapeType.Triangle;\n\n    /**\n     * The first point of the triangle.\n     */\n    a: Vector;\n\n    /**\n     * The second point of the triangle.\n     */\n    b: Vector;\n\n    /**\n     * The second point of the triangle.\n     */\n    c: Vector;\n\n    /**\n     * Creates a new triangle shape.\n     *\n     * @param a - The first point of the triangle.\n     * @param b - The second point of the triangle.\n     * @param c - The third point of the triangle.\n     */\n    constructor(a: Vector, b: Vector, c: Vector) {\n        super();\n        this.a = a;\n        this.b = b;\n        this.c = c;\n    }\n\n    public intoRaw(): RawShape {\n        let ra = VectorOps.intoRaw(this.a);\n        let rb = VectorOps.intoRaw(this.b);\n        let rc = VectorOps.intoRaw(this.c);\n        let result = RawShape.triangle(ra, rb, rc);\n        ra.free();\n        rb.free();\n        rc.free();\n        return result;\n    }\n}\n\n/**\n * A shape that is a triangle with round borders and a non-zero thickness.\n */\nexport class RoundTriangle extends Shape {\n    readonly type = ShapeType.RoundTriangle;\n\n    /**\n     * The first point of the triangle.\n     */\n    a: Vector;\n\n    /**\n     * The second point of the triangle.\n     */\n    b: Vector;\n\n    /**\n     * The second point of the triangle.\n     */\n    c: Vector;\n\n    /**\n     * The radius of the triangles's rounded edges and vertices.\n     * In 3D, this is also equal to half the thickness of the round triangle.\n     */\n    borderRadius: number;\n\n    /**\n     * Creates a new triangle shape with round corners.\n     *\n     * @param a - The first point of the triangle.\n     * @param b - The second point of the triangle.\n     * @param c - The third point of the triangle.\n     * @param borderRadius - The radius of the borders of this triangle. In 3D,\n     *   this is also equal to half the thickness of the triangle.\n     */\n    constructor(a: Vector, b: Vector, c: Vector, borderRadius: number) {\n        super();\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.borderRadius = borderRadius;\n    }\n\n    public intoRaw(): RawShape {\n        let ra = VectorOps.intoRaw(this.a);\n        let rb = VectorOps.intoRaw(this.b);\n        let rc = VectorOps.intoRaw(this.c);\n        let result = RawShape.roundTriangle(ra, rb, rc, this.borderRadius);\n        ra.free();\n        rb.free();\n        rc.free();\n        return result;\n    }\n}\n\n/**\n * A shape that is a triangle mesh.\n */\nexport class Polyline extends Shape {\n    readonly type = ShapeType.Polyline;\n\n    /**\n     * The vertices of the polyline.\n     */\n    vertices: Float32Array;\n\n    /**\n     * The indices of the segments.\n     */\n    indices: Uint32Array;\n\n    /**\n     * Creates a new polyline shape.\n     *\n     * @param vertices - The coordinates of the polyline's vertices.\n     * @param indices - The indices of the polyline's segments. If this is `null` or not provided, then\n     *    the vertices are assumed to form a line strip.\n     */\n    constructor(vertices: Float32Array, indices?: Uint32Array) {\n        super();\n        this.vertices = vertices;\n        this.indices = indices ?? new Uint32Array(0);\n    }\n\n    public intoRaw(): RawShape {\n        return RawShape.polyline(this.vertices, this.indices);\n    }\n}\n\n/**\n * A shape that is a triangle mesh.\n */\nexport class TriMesh extends Shape {\n    readonly type = ShapeType.TriMesh;\n\n    /**\n     * The vertices of the triangle mesh.\n     */\n    vertices: Float32Array;\n\n    /**\n     * The indices of the triangles.\n     */\n    indices: Uint32Array;\n\n    /**\n     * Creates a new triangle mesh shape.\n     *\n     * @param vertices - The coordinates of the triangle mesh's vertices.\n     * @param indices - The indices of the triangle mesh's triangles.\n     */\n    constructor(vertices: Float32Array, indices: Uint32Array) {\n        super();\n        this.vertices = vertices;\n        this.indices = indices;\n    }\n\n    public intoRaw(): RawShape {\n        return RawShape.trimesh(this.vertices, this.indices);\n    }\n}\n\n\n// #if DIM3\n/**\n * A shape that is a convex polygon.\n */\nexport class ConvexPolyhedron extends Shape {\n    readonly type = ShapeType.ConvexPolyhedron;\n\n    /**\n     * The vertices of the convex polygon.\n     */\n    vertices: Float32Array;\n\n    /**\n     * The indices of the convex polygon.\n     */\n    indices?: Uint32Array | null;\n\n    /**\n     * Creates a new convex polygon shape.\n     *\n     * @param vertices - The coordinates of the convex polygon's vertices.\n     * @param indices - The index buffer of this convex mesh. If this is `null`\n     *   or `undefined`, the convex-hull of the input vertices will be computed\n     *   automatically. Otherwise, it will be assumed that the mesh you provide\n     *   is already convex.\n     */\n    constructor(vertices: Float32Array, indices?: Uint32Array | null) {\n        super();\n        this.vertices = vertices;\n        this.indices = indices;\n    }\n\n    public intoRaw(): RawShape {\n        if (!!this.indices) {\n            return RawShape.convexMesh(this.vertices, this.indices);\n        } else {\n            return RawShape.convexHull(this.vertices);\n        }\n    }\n}\n\n/**\n * A shape that is a convex polygon.\n */\nexport class RoundConvexPolyhedron extends Shape {\n    readonly type = ShapeType.RoundConvexPolyhedron;\n\n    /**\n     * The vertices of the convex polygon.\n     */\n    vertices: Float32Array;\n\n    /**\n     * The indices of the convex polygon.\n     */\n    indices?: Uint32Array;\n\n    /**\n     * The radius of the convex polyhedron's rounded edges and vertices.\n     */\n    borderRadius: number;\n\n    /**\n     * Creates a new convex polygon shape.\n     *\n     * @param vertices - The coordinates of the convex polygon's vertices.\n     * @param indices - The index buffer of this convex mesh. If this is `null`\n     *   or `undefined`, the convex-hull of the input vertices will be computed\n     *   automatically. Otherwise, it will be assumed that the mesh you provide\n     *   is already convex.\n     * @param borderRadius - The radius of the borders of this convex polyhedron.\n     */\n    constructor(\n        vertices: Float32Array,\n        indices: Uint32Array | null | undefined,\n        borderRadius: number,\n    ) {\n        super();\n        this.vertices = vertices;\n        this.indices = indices;\n        this.borderRadius = borderRadius;\n    }\n\n    public intoRaw(): RawShape {\n        if (!!this.indices) {\n            return RawShape.roundConvexMesh(\n                this.vertices,\n                this.indices,\n                this.borderRadius,\n            );\n        } else {\n            return RawShape.roundConvexHull(this.vertices, this.borderRadius);\n        }\n    }\n}\n\n/**\n * A shape that is a heightfield.\n */\nexport class Heightfield extends Shape {\n    readonly type = ShapeType.HeightField;\n\n    /**\n     * The number of rows in the heights matrix.\n     */\n    nrows: number;\n\n    /**\n     * The number of columns in the heights matrix.\n     */\n    ncols: number;\n\n    /**\n     * The heights of the heightfield along its local `y` axis,\n     * provided as a matrix stored in column-major order.\n     */\n    heights: Float32Array;\n\n    /**\n     * The dimensions of the heightfield's local `x,z` plane.\n     */\n    scale: Vector;\n\n    /**\n     * Creates a new heightfield shape.\n     *\n     * @param nrows \u2212 The number of rows in the heights matrix.\n     * @param ncols - The number of columns in the heights matrix.\n     * @param heights - The heights of the heightfield along its local `y` axis,\n     *                  provided as a matrix stored in column-major order.\n     * @param scale - The dimensions of the heightfield's local `x,z` plane.\n     */\n    constructor(\n        nrows: number,\n        ncols: number,\n        heights: Float32Array,\n        scale: Vector,\n    ) {\n        super();\n        this.nrows = nrows;\n        this.ncols = ncols;\n        this.heights = heights;\n        this.scale = scale;\n    }\n\n    public intoRaw(): RawShape {\n        let rawScale = VectorOps.intoRaw(this.scale);\n        let rawShape = RawShape.heightfield(\n            this.nrows,\n            this.ncols,\n            this.heights,\n            rawScale,\n        );\n        rawScale.free();\n        return rawShape;\n    }\n}\n\n/**\n * A shape that is a 3D cylinder.\n */\nexport class Cylinder extends Shape {\n    readonly type = ShapeType.Cylinder;\n\n    /**\n     * The radius of the cylinder's basis.\n     */\n    radius: number;\n\n    /**\n     * The cylinder's half height, along the `y` axis.\n     */\n    halfHeight: number;\n\n    /**\n     * Creates a new cylinder with the given radius and half-height.\n     * @param halfHeight - The balls half-height along the `y` axis.\n     * @param radius - The balls radius.\n     */\n    constructor(halfHeight: number, radius: number) {\n        super();\n        this.halfHeight = halfHeight;\n        this.radius = radius;\n    }\n\n    public intoRaw(): RawShape {\n        return RawShape.cylinder(this.halfHeight, this.radius);\n    }\n}\n\n/**\n * A shape that is a 3D cylinder with round corners.\n */\nexport class RoundCylinder extends Shape {\n    readonly type = ShapeType.RoundCylinder;\n\n    /**\n     * The radius of the cylinder's basis.\n     */\n    radius: number;\n\n    /**\n     * The cylinder's half height, along the `y` axis.\n     */\n    halfHeight: number;\n\n    /**\n     * The radius of the cylinder's rounded edges and vertices.\n     */\n    borderRadius: number;\n\n    /**\n     * Creates a new cylinder with the given radius and half-height.\n     * @param halfHeight - The balls half-height along the `y` axis.\n     * @param radius - The balls radius.\n     * @param borderRadius - The radius of the borders of this cylinder.\n     */\n    constructor(halfHeight: number, radius: number, borderRadius: number) {\n        super();\n        this.borderRadius = borderRadius;\n        this.halfHeight = halfHeight;\n        this.radius = radius;\n    }\n\n    public intoRaw(): RawShape {\n        return RawShape.roundCylinder(\n            this.halfHeight,\n            this.radius,\n            this.borderRadius,\n        );\n    }\n}\n\n/**\n * A shape that is a 3D cone.\n */\nexport class Cone extends Shape {\n    readonly type = ShapeType.Cone;\n\n    /**\n     * The radius of the cone's basis.\n     */\n    radius: number;\n\n    /**\n     * The cone's half height, along the `y` axis.\n     */\n    halfHeight: number;\n\n    /**\n     * Creates a new cone with the given radius and half-height.\n     * @param halfHeight - The balls half-height along the `y` axis.\n     * @param radius - The balls radius.\n     */\n    constructor(halfHeight: number, radius: number) {\n        super();\n        this.halfHeight = halfHeight;\n        this.radius = radius;\n    }\n\n    public intoRaw(): RawShape {\n        return RawShape.cone(this.halfHeight, this.radius);\n    }\n}\n\n/**\n * A shape that is a 3D cone with round corners.\n */\nexport class RoundCone extends Shape {\n    readonly type = ShapeType.RoundCone;\n\n    /**\n     * The radius of the cone's basis.\n     */\n    radius: number;\n\n    /**\n     * The cone's half height, along the `y` axis.\n     */\n    halfHeight: number;\n\n    /**\n     * The radius of the cylinder's rounded edges and vertices.\n     */\n    borderRadius: number;\n\n    /**\n     * Creates a new cone with the given radius and half-height.\n     * @param halfHeight - The balls half-height along the `y` axis.\n     * @param radius - The balls radius.\n     * @param borderRadius - The radius of the borders of this cone.\n     */\n    constructor(halfHeight: number, radius: number, borderRadius: number) {\n        super();\n        this.halfHeight = halfHeight;\n        this.radius = radius;\n        this.borderRadius = borderRadius;\n    }\n\n    public intoRaw(): RawShape {\n        return RawShape.roundCone(\n            this.halfHeight,\n            this.radius,\n            this.borderRadius,\n        );\n    }\n}\n\n// #endif\n", "import {RawPhysicsPipeline} from \"../raw\";\nimport {Vector, VectorOps} from \"../math\";\nimport {\n    IntegrationParameters,\n    ImpulseJointSet,\n    MultibodyJointSet,\n    RigidBodyHandle,\n    RigidBodySet,\n    CCDSolver,\n    IslandManager,\n} from \"../dynamics\";\nimport {\n    BroadPhase,\n    ColliderHandle,\n    ColliderSet,\n    NarrowPhase,\n} from \"../geometry\";\nimport {EventQueue} from \"./event_queue\";\nimport {PhysicsHooks} from \"./physics_hooks\";\n\nexport class PhysicsPipeline {\n    raw: RawPhysicsPipeline;\n\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    constructor(raw?: RawPhysicsPipeline) {\n        this.raw = raw || new RawPhysicsPipeline();\n    }\n\n    public step(\n        gravity: Vector,\n        integrationParameters: IntegrationParameters,\n        islands: IslandManager,\n        broadPhase: BroadPhase,\n        narrowPhase: NarrowPhase,\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        impulseJoints: ImpulseJointSet,\n        multibodyJoints: MultibodyJointSet,\n        ccdSolver: CCDSolver,\n        eventQueue?: EventQueue,\n        hooks?: PhysicsHooks,\n    ) {\n        let rawG = VectorOps.intoRaw(gravity);\n\n        if (!!eventQueue) {\n            this.raw.stepWithEvents(\n                rawG,\n                integrationParameters.raw,\n                islands.raw,\n                broadPhase.raw,\n                narrowPhase.raw,\n                bodies.raw,\n                colliders.raw,\n                impulseJoints.raw,\n                multibodyJoints.raw,\n                ccdSolver.raw,\n                eventQueue.raw,\n                hooks,\n                !!hooks ? hooks.filterContactPair : null,\n                !!hooks ? hooks.filterIntersectionPair : null,\n            );\n        } else {\n            this.raw.step(\n                rawG,\n                integrationParameters.raw,\n                islands.raw,\n                broadPhase.raw,\n                narrowPhase.raw,\n                bodies.raw,\n                colliders.raw,\n                impulseJoints.raw,\n                multibodyJoints.raw,\n                ccdSolver.raw,\n            );\n        }\n\n        rawG.free();\n    }\n}\n", "import {RawQueryPipeline, RawRayColliderIntersection} from \"../raw\";\nimport {\n    ColliderHandle,\n    ColliderSet,\n    InteractionGroups,\n    PointColliderProjection,\n    Ray,\n    RayColliderIntersection,\n    RayColliderToi,\n    Shape,\n    ShapeColliderTOI,\n} from \"../geometry\";\nimport {IslandManager, RigidBodyHandle, RigidBodySet} from \"../dynamics\";\nimport {Rotation, RotationOps, Vector, VectorOps} from \"../math\";\n\n// NOTE: must match the bits in the QueryFilterFlags on the Rust side.\n/**\n * Flags for excluding whole sets of colliders from a scene query.\n */\nexport enum QueryFilterFlags {\n    /**\n     * Exclude from the query any collider attached to a fixed rigid-body and colliders with no rigid-body attached.\n     */\n    EXCLUDE_FIXED = 0b0000_0001,\n    /**\n     * Exclude from the query any collider attached to a dynamic rigid-body.\n     */\n    EXCLUDE_KINEMATIC = 0b0000_0010,\n    /**\n     * Exclude from the query any collider attached to a kinematic rigid-body.\n     */\n    EXCLUDE_DYNAMIC = 0b0000_0100,\n    /**\n     * Exclude from the query any collider that is a sensor.\n     */\n    EXCLUDE_SENSORS = 0b0000_1000,\n    /**\n     * Exclude from the query any collider that is not a sensor.\n     */\n    EXCLUDE_SOLIDS = 0b0001_0000,\n    /**\n     * Excludes all colliders not attached to a dynamic rigid-body.\n     */\n    ONLY_DYNAMIC = QueryFilterFlags.EXCLUDE_FIXED |\n        QueryFilterFlags.EXCLUDE_KINEMATIC,\n    /**\n     * Excludes all colliders not attached to a kinematic rigid-body.\n     */\n    ONLY_KINEMATIC = QueryFilterFlags.EXCLUDE_DYNAMIC |\n        QueryFilterFlags.EXCLUDE_FIXED,\n    /**\n     * Exclude all colliders attached to a non-fixed rigid-body\n     * (this will not exclude colliders not attached to any rigid-body).\n     */\n    ONLY_FIXED = QueryFilterFlags.EXCLUDE_DYNAMIC |\n        QueryFilterFlags.EXCLUDE_KINEMATIC,\n}\n\n/**\n * A pipeline for performing queries on all the colliders of a scene.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `queryPipeline.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nexport class QueryPipeline {\n    raw: RawQueryPipeline;\n\n    /**\n     * Release the WASM memory occupied by this query pipeline.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    constructor(raw?: RawQueryPipeline) {\n        this.raw = raw || new RawQueryPipeline();\n    }\n\n    /**\n     * Updates the acceleration structure of the query pipeline.\n     * @param bodies - The set of rigid-bodies taking part in this pipeline.\n     * @param colliders - The set of colliders taking part in this pipeline.\n     */\n    public update(bodies: RigidBodySet, colliders: ColliderSet) {\n        this.raw.update(bodies.raw, colliders.raw);\n    }\n\n    /**\n     * Find the closest intersection between a ray and a set of collider.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     * @param filter - The callback to filter out which collider will be hit.\n     */\n    public castRay(\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        ray: Ray,\n        maxToi: number,\n        solid: boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: ColliderHandle,\n        filterExcludeRigidBody?: RigidBodyHandle,\n        filterPredicate?: (collider: ColliderHandle) => boolean,\n    ): RayColliderToi | null {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let result = RayColliderToi.fromRaw(\n            colliders,\n            this.raw.castRay(\n                bodies.raw,\n                colliders.raw,\n                rawOrig,\n                rawDir,\n                maxToi,\n                solid,\n                filterFlags,\n                filterGroups,\n                filterExcludeCollider,\n                filterExcludeRigidBody,\n                filterPredicate,\n            ),\n        );\n\n        rawOrig.free();\n        rawDir.free();\n\n        return result;\n    }\n\n    /**\n     * Find the closest intersection between a ray and a set of collider.\n     *\n     * This also computes the normal at the hit point.\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     */\n    public castRayAndGetNormal(\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        ray: Ray,\n        maxToi: number,\n        solid: boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: ColliderHandle,\n        filterExcludeRigidBody?: RigidBodyHandle,\n        filterPredicate?: (collider: ColliderHandle) => boolean,\n    ): RayColliderIntersection | null {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let result = RayColliderIntersection.fromRaw(\n            colliders,\n            this.raw.castRayAndGetNormal(\n                bodies.raw,\n                colliders.raw,\n                rawOrig,\n                rawDir,\n                maxToi,\n                solid,\n                filterFlags,\n                filterGroups,\n                filterExcludeCollider,\n                filterExcludeRigidBody,\n                filterPredicate,\n            ),\n        );\n\n        rawOrig.free();\n        rawDir.free();\n\n        return result;\n    }\n\n    /**\n     * Cast a ray and collects all the intersections between a ray and the scene.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     * @param callback - The callback called once per hit (in no particular order) between a ray and a collider.\n     *   If this callback returns `false`, then the cast will stop and no further hits will be detected/reported.\n     */\n    public intersectionsWithRay(\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        ray: Ray,\n        maxToi: number,\n        solid: boolean,\n        callback: (intersect: RayColliderIntersection) => boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: ColliderHandle,\n        filterExcludeRigidBody?: RigidBodyHandle,\n        filterPredicate?: (collider: ColliderHandle) => boolean,\n    ) {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let rawCallback = (rawInter: RawRayColliderIntersection) => {\n            return callback(\n                RayColliderIntersection.fromRaw(colliders, rawInter),\n            );\n        };\n\n        this.raw.intersectionsWithRay(\n            bodies.raw,\n            colliders.raw,\n            rawOrig,\n            rawDir,\n            maxToi,\n            solid,\n            rawCallback,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider,\n            filterExcludeRigidBody,\n            filterPredicate,\n        );\n\n        rawOrig.free();\n        rawDir.free();\n    }\n\n    /**\n     * Gets the handle of up to one collider intersecting the given shape.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param shapePos - The position of the shape used for the intersection test.\n     * @param shapeRot - The orientation of the shape used for the intersection test.\n     * @param shape - The shape used for the intersection test.\n     * @param groups - The bit groups and filter associated to the ray, in order to only\n     *   hit the colliders with collision groups compatible with the ray's group.\n     */\n    public intersectionWithShape(\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        shapePos: Vector,\n        shapeRot: Rotation,\n        shape: Shape,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: ColliderHandle,\n        filterExcludeRigidBody?: RigidBodyHandle,\n        filterPredicate?: (collider: ColliderHandle) => boolean,\n    ): ColliderHandle | null {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawShape = shape.intoRaw();\n        let result = this.raw.intersectionWithShape(\n            bodies.raw,\n            colliders.raw,\n            rawPos,\n            rawRot,\n            rawShape,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider,\n            filterExcludeRigidBody,\n            filterPredicate,\n        );\n\n        rawPos.free();\n        rawRot.free();\n        rawShape.free();\n\n        return result;\n    }\n\n    /**\n     * Find the projection of a point on the closest collider.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param point - The point to project.\n     * @param solid - If this is set to `true` then the collider shapes are considered to\n     *   be plain (if the point is located inside of a plain shape, its projection is the point\n     *   itself). If it is set to `false` the collider shapes are considered to be hollow\n     *   (if the point is located inside of an hollow shape, it is projected on the shape's\n     *   boundary).\n     * @param groups - The bit groups and filter associated to the point to project, in order to only\n     *   project on colliders with collision groups compatible with the ray's group.\n     */\n    public projectPoint(\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        point: Vector,\n        solid: boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: ColliderHandle,\n        filterExcludeRigidBody?: RigidBodyHandle,\n        filterPredicate?: (collider: ColliderHandle) => boolean,\n    ): PointColliderProjection | null {\n        let rawPoint = VectorOps.intoRaw(point);\n        let result = PointColliderProjection.fromRaw(\n            colliders,\n            this.raw.projectPoint(\n                bodies.raw,\n                colliders.raw,\n                rawPoint,\n                solid,\n                filterFlags,\n                filterGroups,\n                filterExcludeCollider,\n                filterExcludeRigidBody,\n                filterPredicate,\n            ),\n        );\n\n        rawPoint.free();\n\n        return result;\n    }\n\n    /**\n     * Find the projection of a point on the closest collider.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param point - The point to project.\n     * @param groups - The bit groups and filter associated to the point to project, in order to only\n     *   project on colliders with collision groups compatible with the ray's group.\n     */\n    public projectPointAndGetFeature(\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        point: Vector,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: ColliderHandle,\n        filterExcludeRigidBody?: RigidBodyHandle,\n        filterPredicate?: (collider: ColliderHandle) => boolean,\n    ): PointColliderProjection | null {\n        let rawPoint = VectorOps.intoRaw(point);\n        let result = PointColliderProjection.fromRaw(\n            colliders,\n            this.raw.projectPointAndGetFeature(\n                bodies.raw,\n                colliders.raw,\n                rawPoint,\n                filterFlags,\n                filterGroups,\n                filterExcludeCollider,\n                filterExcludeRigidBody,\n                filterPredicate,\n            ),\n        );\n\n        rawPoint.free();\n\n        return result;\n    }\n\n    /**\n     * Find all the colliders containing the given point.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param point - The point used for the containment test.\n     * @param groups - The bit groups and filter associated to the point to test, in order to only\n     *   test on colliders with collision groups compatible with the ray's group.\n     * @param callback - A function called with the handles of each collider with a shape\n     *   containing the `point`.\n     */\n    public intersectionsWithPoint(\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        point: Vector,\n        callback: (handle: ColliderHandle) => boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: ColliderHandle,\n        filterExcludeRigidBody?: RigidBodyHandle,\n        filterPredicate?: (collider: ColliderHandle) => boolean,\n    ) {\n        let rawPoint = VectorOps.intoRaw(point);\n\n        this.raw.intersectionsWithPoint(\n            bodies.raw,\n            colliders.raw,\n            rawPoint,\n            callback,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider,\n            filterExcludeRigidBody,\n            filterPredicate,\n        );\n\n        rawPoint.free();\n    }\n\n    /**\n     * Casts a shape at a constant linear velocity and retrieve the first collider it hits.\n     * This is similar to ray-casting except that we are casting a whole shape instead of\n     * just a point (the ray origin).\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param shapePos - The initial position of the shape to cast.\n     * @param shapeRot - The initial rotation of the shape to cast.\n     * @param shapeVel - The constant velocity of the shape to cast (i.e. the cast direction).\n     * @param shape - The shape to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the distance traveled by the shape to `shapeVel.norm() * maxToi`.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast won\u2019t immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that it\u2019s on a path to exist that penetration state.\n     * @param groups - The bit groups and filter associated to the shape to cast, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     */\n    public castShape(\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        shapePos: Vector,\n        shapeRot: Rotation,\n        shapeVel: Vector,\n        shape: Shape,\n        maxToi: number,\n        stopAtPenetration: boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: ColliderHandle,\n        filterExcludeRigidBody?: RigidBodyHandle,\n        filterPredicate?: (collider: ColliderHandle) => boolean,\n    ): ShapeColliderTOI | null {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawVel = VectorOps.intoRaw(shapeVel);\n        let rawShape = shape.intoRaw();\n\n        let result = ShapeColliderTOI.fromRaw(\n            colliders,\n            this.raw.castShape(\n                bodies.raw,\n                colliders.raw,\n                rawPos,\n                rawRot,\n                rawVel,\n                rawShape,\n                maxToi,\n                stopAtPenetration,\n                filterFlags,\n                filterGroups,\n                filterExcludeCollider,\n                filterExcludeRigidBody,\n                filterPredicate,\n            ),\n        );\n\n        rawPos.free();\n        rawRot.free();\n        rawVel.free();\n        rawShape.free();\n\n        return result;\n    }\n\n    /**\n     * Retrieve all the colliders intersecting the given shape.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param shapePos - The position of the shape to test.\n     * @param shapeRot - The orientation of the shape to test.\n     * @param shape - The shape to test.\n     * @param groups - The bit groups and filter associated to the shape to test, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     * @param callback - A function called with the handles of each collider intersecting the `shape`.\n     */\n    public intersectionsWithShape(\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        shapePos: Vector,\n        shapeRot: Rotation,\n        shape: Shape,\n        callback: (handle: ColliderHandle) => boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: ColliderHandle,\n        filterExcludeRigidBody?: RigidBodyHandle,\n        filterPredicate?: (collider: ColliderHandle) => boolean,\n    ) {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawShape = shape.intoRaw();\n\n        this.raw.intersectionsWithShape(\n            bodies.raw,\n            colliders.raw,\n            rawPos,\n            rawRot,\n            rawShape,\n            callback,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider,\n            filterExcludeRigidBody,\n            filterPredicate,\n        );\n\n        rawPos.free();\n        rawRot.free();\n        rawShape.free();\n    }\n\n    /**\n     * Finds the handles of all the colliders with an AABB intersecting the given AABB.\n     *\n     * @param aabbCenter - The center of the AABB to test.\n     * @param aabbHalfExtents - The half-extents of the AABB to test.\n     * @param callback - The callback that will be called with the handles of all the colliders\n     *                   currently intersecting the given AABB.\n     */\n    public collidersWithAabbIntersectingAabb(\n        aabbCenter: Vector,\n        aabbHalfExtents: Vector,\n        callback: (handle: ColliderHandle) => boolean,\n    ) {\n        let rawCenter = VectorOps.intoRaw(aabbCenter);\n        let rawHalfExtents = VectorOps.intoRaw(aabbHalfExtents);\n        this.raw.collidersWithAabbIntersectingAabb(\n            rawCenter,\n            rawHalfExtents,\n            callback,\n        );\n        rawCenter.free();\n        rawHalfExtents.free();\n    }\n}\n", "import {RawSerializationPipeline} from \"../raw\";\nimport {Vector, VectorOps} from \"../math\";\nimport {\n    IntegrationParameters,\n    IslandManager,\n    ImpulseJointSet,\n    MultibodyJointSet,\n    RigidBodySet,\n} from \"../dynamics\";\nimport {BroadPhase, ColliderSet, NarrowPhase} from \"../geometry\";\nimport {World} from \"./world\";\n\n/**\n * A pipeline for serializing the physics scene.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `queryPipeline.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nexport class SerializationPipeline {\n    raw: RawSerializationPipeline;\n\n    /**\n     * Release the WASM memory occupied by this serialization pipeline.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    constructor(raw?: RawSerializationPipeline) {\n        this.raw = raw || new RawSerializationPipeline();\n    }\n\n    /**\n     * Serialize a complete physics state into a single byte array.\n     * @param gravity - The current gravity affecting the simulation.\n     * @param integrationParameters - The integration parameters of the simulation.\n     * @param broadPhase - The broad-phase of the simulation.\n     * @param narrowPhase - The narrow-phase of the simulation.\n     * @param bodies - The rigid-bodies taking part into the simulation.\n     * @param colliders - The colliders taking part into the simulation.\n     * @param impulseJoints - The impulse joints taking part into the simulation.\n     * @param multibodyJoints - The multibody joints taking part into the simulation.\n     */\n    public serializeAll(\n        gravity: Vector,\n        integrationParameters: IntegrationParameters,\n        islands: IslandManager,\n        broadPhase: BroadPhase,\n        narrowPhase: NarrowPhase,\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        impulseJoints: ImpulseJointSet,\n        multibodyJoints: MultibodyJointSet,\n    ): Uint8Array {\n        let rawGra = VectorOps.intoRaw(gravity);\n\n        const res = this.raw.serializeAll(\n            rawGra,\n            integrationParameters.raw,\n            islands.raw,\n            broadPhase.raw,\n            narrowPhase.raw,\n            bodies.raw,\n            colliders.raw,\n            impulseJoints.raw,\n            multibodyJoints.raw,\n        );\n        rawGra.free();\n\n        return res;\n    }\n\n    /**\n     * Deserialize the complete physics state from a single byte array.\n     *\n     * @param data - The byte array to deserialize.\n     */\n    public deserializeAll(data: Uint8Array): World {\n        return World.fromRaw(this.raw.deserializeAll(data));\n    }\n}\n", "import {RawDebugRenderPipeline} from \"../raw\";\nimport {Vector, VectorOps} from \"../math\";\nimport {\n    IntegrationParameters,\n    IslandManager,\n    ImpulseJointSet,\n    MultibodyJointSet,\n    RigidBodySet,\n} from \"../dynamics\";\nimport {BroadPhase, ColliderSet, NarrowPhase} from \"../geometry\";\n\n/**\n * The vertex and color buffers for debug-redering the physics scene.\n */\nexport class DebugRenderBuffers {\n    /**\n     * The lines to render. This is a flat array containing all the lines\n     * to render. Each line is described as two consecutive point. Each\n     * point is described as two (in 2D) or three (in 3D) consecutive\n     * floats. For example, in 2D, the array: `[1, 2, 3, 4, 5, 6, 7, 8]`\n     * describes the two segments `[[1, 2], [3, 4]]` and `[[5, 6], [7, 8]]`.\n     */\n    public vertices: Float32Array;\n    /**\n     * The color buffer. There is one color per vertex, and each color\n     * has four consecutive components (in RGBA format).\n     */\n    public colors: Float32Array;\n\n    constructor(vertices: Float32Array, colors: Float32Array) {\n        this.vertices = vertices;\n        this.colors = colors;\n    }\n}\n\n/**\n * A pipeline for rendering the physics scene.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `debugRenderPipeline.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nexport class DebugRenderPipeline {\n    raw: RawDebugRenderPipeline;\n    public vertices: Float32Array;\n    public colors: Float32Array;\n\n    /**\n     * Release the WASM memory occupied by this serialization pipeline.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n        this.vertices = undefined;\n        this.colors = undefined;\n    }\n\n    constructor(raw?: RawDebugRenderPipeline) {\n        this.raw = raw || new RawDebugRenderPipeline();\n    }\n\n    public render(\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        impulse_joints: ImpulseJointSet,\n        multibody_joints: MultibodyJointSet,\n        narrow_phase: NarrowPhase,\n    ) {\n        this.raw.render(\n            bodies.raw,\n            colliders.raw,\n            impulse_joints.raw,\n            multibody_joints.raw,\n            narrow_phase.raw,\n        );\n        this.vertices = this.raw.vertices();\n        this.colors = this.raw.colors();\n    }\n}\n", "import {RawKinematicCharacterController, RawCharacterCollision} from \"../raw\";\nimport {Rotation, Vector, VectorOps} from \"../math\";\nimport {Collider, ColliderSet, InteractionGroups, Shape} from \"../geometry\";\nimport {QueryFilterFlags, QueryPipeline, World} from \"../pipeline\";\nimport {IntegrationParameters, RigidBody, RigidBodySet} from \"../dynamics\";\n\n/**\n * A collision between the character and an obstacle hit on its path.\n */\nexport class CharacterCollision {\n    /** The collider involved in the collision. Null if the collider no longer exists in the physics world. */\n    public collider: Collider | null;\n    /** The translation delta applied to the character before this collision took place. */\n    public translationDeltaApplied: Vector;\n    /** The translation delta the character would move after this collision if there is no other obstacles. */\n    public translationDeltaRemaining: Vector;\n    /** The time-of-impact between the character and the obstacles. */\n    public toi: number;\n    /** The world-space contact point on the collider when the collision happens. */\n    public witness1: Vector;\n    /** The local-space contact point on the character when the collision happens. */\n    public witness2: Vector;\n    /** The world-space outward contact normal on the collider when the collision happens. */\n    public normal1: Vector;\n    /** The local-space outward contact normal on the character when the collision happens. */\n    public normal2: Vector;\n}\n\n/**\n * A character controller for controlling kinematic bodies and parentless colliders by hitting\n * and sliding against obstacles.\n */\nexport class KinematicCharacterController {\n    private raw: RawKinematicCharacterController;\n    private rawCharacterCollision: RawCharacterCollision;\n\n    private params: IntegrationParameters;\n    private bodies: RigidBodySet;\n    private colliders: ColliderSet;\n    private queries: QueryPipeline;\n    private _applyImpulsesToDynamicBodies: boolean;\n    private _characterMass: number | null;\n\n    constructor(\n        offset: number,\n        params: IntegrationParameters,\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        queries: QueryPipeline,\n    ) {\n        this.params = params;\n        this.bodies = bodies;\n        this.colliders = colliders;\n        this.queries = queries;\n        this.raw = new RawKinematicCharacterController(offset);\n        this.rawCharacterCollision = new RawCharacterCollision();\n        this._applyImpulsesToDynamicBodies = false;\n        this._characterMass = null;\n    }\n\n    /** @internal */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n            this.rawCharacterCollision.free();\n        }\n\n        this.raw = undefined;\n        this.rawCharacterCollision = undefined;\n    }\n\n    /**\n     * The direction that goes \"up\". Used to determine where the floor is, and the floor\u2019s angle.\n     */\n    public up(): Vector {\n        return this.raw.up();\n    }\n\n    /**\n     * Sets the direction that goes \"up\". Used to determine where the floor is, and the floor\u2019s angle.\n     */\n    public setUp(vector: Vector) {\n        let rawVect = VectorOps.intoRaw(vector);\n        return this.raw.setUp(rawVect);\n        rawVect.free();\n    }\n\n    public applyImpulsesToDynamicBodies(): boolean {\n        return this._applyImpulsesToDynamicBodies;\n    }\n\n    public setApplyImpulsesToDynamicBodies(enabled: boolean) {\n        this._applyImpulsesToDynamicBodies = enabled;\n    }\n\n    /**\n     * Returns the custom value of the character mass, if it was set by `this.setCharacterMass`.\n     */\n    public characterMass(): number | null {\n        return this._characterMass;\n    }\n\n    /**\n     * Set the mass of the character to be used for impulse resolution if `self.applyImpulsesToDynamicBodies`\n     * is set to `true`.\n     *\n     * If no character mass is set explicitly (or if it is set to `null`) it is automatically assumed to be equal\n     * to the mass of the rigid-body the character collider is attached to; or equal to 0 if the character collider\n     * isn\u2019t attached to any rigid-body.\n     *\n     * @param mass - The mass to set.\n     */\n    public setCharacterMass(mass: number | null) {\n        this._characterMass = mass;\n    }\n\n    /**\n     * A small gap to preserve between the character and its surroundings.\n     *\n     * This value should not be too large to avoid visual artifacts, but shouldn\u2019t be too small\n     * (must not be zero) to improve numerical stability of the character controller.\n     */\n    public offset(): number {\n        return this.raw.offset();\n    }\n\n    /**\n     * Sets a small gap to preserve between the character and its surroundings.\n     *\n     * This value should not be too large to avoid visual artifacts, but shouldn\u2019t be too small\n     * (must not be zero) to improve numerical stability of the character controller.\n     */\n    public setOffset(value: number) {\n        this.raw.setOffset(value);\n    }\n\n    /**\n     * Is sliding against obstacles enabled?\n     */\n    public slideEnabled(): boolean {\n        return this.raw.slideEnabled();\n    }\n\n    /**\n     * Enable or disable sliding against obstacles.\n     */\n    public setSlideEnabled(enabled: boolean) {\n        this.raw.setSlideEnabled(enabled);\n    }\n\n    /**\n     * The maximum step height a character can automatically step over.\n     */\n    public autostepMaxHeight(): number | null {\n        return this.raw.autostepMaxHeight();\n    }\n\n    /**\n     * The minimum width of free space that must be available after stepping on a stair.\n     */\n    public autostepMinWidth(): number | null {\n        return this.raw.autostepMinWidth();\n    }\n\n    /**\n     * Can the character automatically step over dynamic bodies too?\n     */\n    public autostepIncludesDynamicBodies(): boolean | null {\n        return this.raw.autostepIncludesDynamicBodies();\n    }\n\n    /**\n     * Is automatically stepping over small objects enabled?\n     */\n    public autostepEnabled(): boolean {\n        return this.raw.autostepEnabled();\n    }\n\n    /**\n     * Enabled automatically stepping over small objects.\n     *\n     * @param maxHeight - The maximum step height a character can automatically step over.\n     * @param minWidth - The minimum width of free space that must be available after stepping on a stair.\n     * @param includeDynamicBodies - Can the character automatically step over dynamic bodies too?\n     */\n    public enableAutostep(\n        maxHeight: number,\n        minWidth: number,\n        includeDynamicBodies: boolean,\n    ) {\n        this.raw.enableAutostep(maxHeight, minWidth, includeDynamicBodies);\n    }\n\n    /**\n     * Disable automatically stepping over small objects.\n     */\n    public disableAutostep() {\n        return this.raw.disableAutostep();\n    }\n\n    /**\n     * The maximum angle (radians) between the floor\u2019s normal and the `up` vector that the\n     * character is able to climb.\n     */\n    public maxSlopeClimbAngle(): number {\n        return this.raw.maxSlopeClimbAngle();\n    }\n\n    /**\n     * Sets the maximum angle (radians) between the floor\u2019s normal and the `up` vector that the\n     * character is able to climb.\n     */\n    public setMaxSlopeClimbAngle(angle: number) {\n        this.raw.setMaxSlopeClimbAngle(angle);\n    }\n\n    /**\n     * The minimum angle (radians) between the floor\u2019s normal and the `up` vector before the\n     * character starts to slide down automatically.\n     */\n    public minSlopeSlideAngle(): number {\n        return this.raw.minSlopeSlideAngle();\n    }\n\n    /**\n     * Sets the minimum angle (radians) between the floor\u2019s normal and the `up` vector before the\n     * character starts to slide down automatically.\n     */\n    public setMinSlopeSlideAngle(angle: number) {\n        this.raw.setMinSlopeSlideAngle(angle);\n    }\n\n    /**\n     * If snap-to-ground is enabled, should the character be automatically snapped to the ground if\n     * the distance between the ground and its feet are smaller than the specified threshold?\n     */\n    public snapToGroundDistance(): number | null {\n        return this.raw.snapToGroundDistance();\n    }\n\n    /**\n     * Enables automatically snapping the character to the ground if the distance between\n     * the ground and its feet are smaller than the specified threshold.\n     */\n    public enableSnapToGround(distance: number) {\n        this.raw.enableSnapToGround(distance);\n    }\n\n    /**\n     * Disables automatically snapping the character to the ground.\n     */\n    public disableSnapToGround() {\n        this.raw.disableSnapToGround();\n    }\n\n    /**\n     * Is automatically snapping the character to the ground enabled?\n     */\n    public snapToGroundEnabled(): boolean {\n        return this.raw.snapToGroundEnabled();\n    }\n\n    /**\n     * Computes the movement the given collider is able to execute after hitting and sliding on obstacles.\n     *\n     * @param collider - The collider to move.\n     * @param desiredTranslationDelta - The desired collider movement.\n     * @param filterFlags - Flags for excluding whole subsets of colliders from the obstacles taken into account.\n     * @param filterGroups - Groups for excluding colliders with incompatible collision groups from the obstacles\n     *                       taken into account.\n     * @param filterPredicate - Any collider for which this closure returns `false` will be excluded from the\n     *                          obstacles taken into account.\n     */\n    public computeColliderMovement(\n        collider: Collider,\n        desiredTranslationDelta: Vector,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterPredicate?: (collider: Collider) => boolean,\n    ) {\n        let rawTranslationDelta = VectorOps.intoRaw(desiredTranslationDelta);\n        this.raw.computeColliderMovement(\n            this.params.dt,\n            this.bodies.raw,\n            this.colliders.raw,\n            this.queries.raw,\n            collider.handle,\n            rawTranslationDelta,\n            this._applyImpulsesToDynamicBodies,\n            this._characterMass,\n            filterFlags,\n            filterGroups,\n            this.colliders.castClosure(filterPredicate),\n        );\n        rawTranslationDelta.free();\n    }\n\n    /**\n     * The movement computed by the last call to `this.computeColliderMovement`.\n     */\n    public computedMovement(): Vector {\n        return VectorOps.fromRaw(this.raw.computedMovement());\n    }\n\n    /**\n     * The result of ground detection computed by the last call to `this.computeColliderMovement`.\n     */\n    public computedGrounded(): boolean {\n        return this.raw.computedGrounded();\n    }\n\n    /**\n     * The number of collisions against obstacles detected along the path of the last call\n     * to `this.computeColliderMovement`.\n     */\n    public numComputedCollisions(): number {\n        return this.raw.numComputedCollisions();\n    }\n\n    /**\n     * Returns the collision against one of the obstacles detected along the path of the last\n     * call to `this.computeColliderMovement`.\n     *\n     * @param i - The i-th collision will be returned.\n     * @param out - If this argument is set, it will be filled with the collision information.\n     */\n    public computedCollision(\n        i: number,\n        out?: CharacterCollision,\n    ): CharacterCollision | null {\n        if (!this.raw.computedCollision(i, this.rawCharacterCollision)) {\n            return null;\n        } else {\n            let c = this.rawCharacterCollision;\n            out = out ?? new CharacterCollision();\n            out.translationDeltaApplied = VectorOps.fromRaw(\n                c.translationDeltaApplied(),\n            );\n            out.translationDeltaRemaining = VectorOps.fromRaw(\n                c.translationDeltaRemaining(),\n            );\n            out.toi = c.toi();\n            out.witness1 = VectorOps.fromRaw(c.worldWitness1());\n            out.witness2 = VectorOps.fromRaw(c.worldWitness2());\n            out.normal1 = VectorOps.fromRaw(c.worldNormal1());\n            out.normal2 = VectorOps.fromRaw(c.worldNormal2());\n            out.collider = this.colliders.get(c.handle());\n            return out;\n        }\n    }\n}\n", "import {RawDynamicRayCastVehicleController} from \"../raw\";\nimport {Vector, VectorOps} from \"../math\";\nimport {Collider, ColliderSet, InteractionGroups} from \"../geometry\";\nimport {QueryFilterFlags, QueryPipeline} from \"../pipeline\";\nimport {RigidBody, RigidBodyHandle, RigidBodySet} from \"../dynamics\";\n\n/**\n * A character controller to simulate vehicles using ray-casting for the wheels.\n */\nexport class DynamicRayCastVehicleController {\n    private raw: RawDynamicRayCastVehicleController;\n    private bodies: RigidBodySet;\n    private colliders: ColliderSet;\n    private queries: QueryPipeline;\n    private _chassis: RigidBody;\n\n    constructor(\n        chassis: RigidBody,\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        queries: QueryPipeline,\n    ) {\n        this.raw = new RawDynamicRayCastVehicleController(chassis.handle);\n        this.bodies = bodies;\n        this.colliders = colliders;\n        this.queries = queries;\n        this._chassis = chassis;\n    }\n\n    /** @internal */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n\n        this.raw = undefined;\n    }\n\n    /**\n     * Updates the vehicle\u2019s velocity based on its suspension, engine force, and brake.\n     *\n     * This directly updates the velocity of its chassis rigid-body.\n     *\n     * @param dt - Time increment used to integrate forces.\n     * @param filterFlags - Flag to exclude categories of objects from the wheels\u2019 ray-cast.\n     * @param filterGroups - Only colliders compatible with these groups will be hit by the wheels\u2019 ray-casts.\n     * @param filterPredicate - Callback to filter out which collider will be hit by the wheels\u2019 ray-casts.\n     */\n    public updateVehicle(\n        dt: number,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterPredicate?: (collider: Collider) => boolean,\n    ) {\n        this.raw.update_vehicle(\n            dt,\n            this.bodies.raw,\n            this.colliders.raw,\n            this.queries.raw,\n            filterFlags,\n            filterGroups,\n            this.colliders.castClosure(filterPredicate),\n        );\n    }\n\n    /**\n     * The current forward speed of the vehicle.\n     */\n    public currentVehicleSpeed(): number {\n        return this.raw.current_vehicle_speed();\n    }\n\n    /**\n     * The rigid-body used as the chassis.\n     */\n    public chassis(): RigidBody {\n        return this._chassis;\n    }\n\n    /**\n     * The chassis\u2019 local _up_ direction (`0 = x, 1 = y, 2 = z`).\n     */\n    get indexUpAxis(): number {\n        return this.raw.index_up_axis();\n    }\n\n    /**\n     * Sets the chassis\u2019 local _up_ direction (`0 = x, 1 = y, 2 = z`).\n     */\n    set indexUpAxis(axis: number) {\n        this.raw.set_index_up_axis(axis);\n    }\n\n    /**\n     * The chassis\u2019 local _forward_ direction (`0 = x, 1 = y, 2 = z`).\n     */\n    get indexForwardAxis(): number {\n        return this.raw.index_forward_axis();\n    }\n\n    /**\n     * Sets the chassis\u2019 local _forward_ direction (`0 = x, 1 = y, 2 = z`).\n     */\n    set setIndexForwardAxis(axis: number) {\n        this.raw.set_index_forward_axis(axis);\n    }\n\n    /**\n     * Adds a new wheel attached to this vehicle.\n     * @param chassisConnectionCs  - The position of the wheel relative to the chassis.\n     * @param directionCs - The direction of the wheel\u2019s suspension, relative to the chassis. The ray-casting will\n     *                      happen following this direction to detect the ground.\n     * @param axleCs - The wheel\u2019s axle axis, relative to the chassis.\n     * @param suspensionRestLength - The rest length of the wheel\u2019s suspension spring.\n     * @param radius - The wheel\u2019s radius.\n     */\n    public addWheel(\n        chassisConnectionCs: Vector,\n        directionCs: Vector,\n        axleCs: Vector,\n        suspensionRestLength: number,\n        radius: number,\n    ) {\n        let rawChassisConnectionCs = VectorOps.intoRaw(chassisConnectionCs);\n        let rawDirectionCs = VectorOps.intoRaw(directionCs);\n        let rawAxleCs = VectorOps.intoRaw(axleCs);\n\n        this.raw.add_wheel(\n            rawChassisConnectionCs,\n            rawDirectionCs,\n            rawAxleCs,\n            suspensionRestLength,\n            radius,\n        );\n\n        rawChassisConnectionCs.free();\n        rawDirectionCs.free();\n        rawAxleCs.free();\n    }\n\n    /**\n     * The number of wheels attached to this vehicle.\n     */\n    public numWheels(): number {\n        return this.raw.num_wheels();\n    }\n\n    /*\n     *\n     * Access to wheel properties.\n     *\n     */\n    /*\n     * Getters + setters\n     */\n    /**\n     * The position of the i-th wheel, relative to the chassis.\n     */\n    public wheelChassisConnectionPointCs(i: number): Vector | null {\n        return VectorOps.fromRaw(this.raw.wheel_chassis_connection_point_cs(i));\n    }\n\n    /**\n     * Sets the position of the i-th wheel, relative to the chassis.\n     */\n    public setWheelChassisConnectionPointCs(i: number, value: Vector) {\n        let rawValue = VectorOps.intoRaw(value);\n        this.raw.set_wheel_chassis_connection_point_cs(i, rawValue);\n        rawValue.free();\n    }\n\n    /**\n     * The rest length of the i-th wheel\u2019s suspension spring.\n     */\n    public wheelSuspensionRestLength(i: number): number | null {\n        return this.raw.wheel_suspension_rest_length(i);\n    }\n\n    /**\n     * Sets the rest length of the i-th wheel\u2019s suspension spring.\n     */\n    public setWheelSuspensionRestLength(i: number, value: number) {\n        this.raw.set_wheel_suspension_rest_length(i, value);\n    }\n\n    /**\n     * The maximum distance the i-th wheel suspension can travel before and after its resting length.\n     */\n    public wheelMaxSuspensionTravel(i: number): number | null {\n        return this.raw.wheel_max_suspension_travel(i);\n    }\n\n    /**\n     * Sets the maximum distance the i-th wheel suspension can travel before and after its resting length.\n     */\n    public setWheelMaxSuspensionTravel(i: number, value: number) {\n        this.raw.set_wheel_max_suspension_travel(i, value);\n    }\n\n    /**\n     * The i-th wheel\u2019s radius.\n     */\n    public wheelRadius(i: number): number | null {\n        return this.raw.wheel_radius(i);\n    }\n\n    /**\n     * Sets the i-th wheel\u2019s radius.\n     */\n    public setWheelRadius(i: number, value: number) {\n        this.raw.set_wheel_radius(i, value);\n    }\n\n    /**\n     * The i-th wheel\u2019s suspension stiffness.\n     *\n     * Increase this value if the suspension appears to not push the vehicle strong enough.\n     */\n    public wheelSuspensionStiffness(i: number): number | null {\n        return this.raw.wheel_suspension_stiffness(i);\n    }\n\n    /**\n     * Sets the i-th wheel\u2019s suspension stiffness.\n     *\n     * Increase this value if the suspension appears to not push the vehicle strong enough.\n     */\n    public setWheelSuspensionStiffness(i: number, value: number) {\n        this.raw.set_wheel_suspension_stiffness(i, value);\n    }\n\n    /**\n     * The i-th wheel\u2019s suspension\u2019s damping when it is being compressed.\n     */\n    public wheelSuspensionCompression(i: number): number | null {\n        return this.raw.wheel_suspension_compression(i);\n    }\n\n    /**\n     * The i-th wheel\u2019s suspension\u2019s damping when it is being compressed.\n     */\n    public setWheelSuspensionCompression(i: number, value: number) {\n        this.raw.set_wheel_suspension_compression(i, value);\n    }\n\n    /**\n     * The i-th wheel\u2019s suspension\u2019s damping when it is being released.\n     *\n     * Increase this value if the suspension appears to overshoot.\n     */\n    public wheelSuspensionRelaxation(i: number): number | null {\n        return this.raw.wheel_suspension_relaxation(i);\n    }\n\n    /**\n     * Sets the i-th wheel\u2019s suspension\u2019s damping when it is being released.\n     *\n     * Increase this value if the suspension appears to overshoot.\n     */\n    public setWheelSuspensionRelaxation(i: number, value: number) {\n        this.raw.set_wheel_suspension_relaxation(i, value);\n    }\n\n    /**\n     * The maximum force applied by the i-th wheel\u2019s suspension.\n     */\n    public wheelMaxSuspensionForce(i: number): number | null {\n        return this.raw.wheel_max_suspension_force(i);\n    }\n\n    /**\n     * Sets the maximum force applied by the i-th wheel\u2019s suspension.\n     */\n    public setWheelMaxSuspensionForce(i: number, value: number) {\n        this.raw.set_wheel_max_suspension_force(i, value);\n    }\n\n    /**\n     * The maximum amount of braking impulse applied on the i-th wheel to slow down the vehicle.\n     */\n    public wheelBrake(i: number): number | null {\n        return this.raw.wheel_brake(i);\n    }\n\n    /**\n     * Set the maximum amount of braking impulse applied on the i-th wheel to slow down the vehicle.\n     */\n    public setWheelBrake(i: number, value: number) {\n        this.raw.set_wheel_brake(i, value);\n    }\n\n    /**\n     * The steering angle (radians) for the i-th wheel.\n     */\n    public wheelSteering(i: number): number | null {\n        return this.raw.wheel_steering(i);\n    }\n\n    /**\n     * Sets the steering angle (radians) for the i-th wheel.\n     */\n    public setWheelSteering(i: number, value: number) {\n        this.raw.set_wheel_steering(i, value);\n    }\n\n    /**\n     * The forward force applied by the i-th wheel on the chassis.\n     */\n    public wheelEngineForce(i: number): number | null {\n        return this.raw.wheel_engine_force(i);\n    }\n\n    /**\n     * Sets the forward force applied by the i-th wheel on the chassis.\n     */\n    public setWheelEngineForce(i: number, value: number) {\n        this.raw.set_wheel_engine_force(i, value);\n    }\n\n    /**\n     * The direction of the i-th wheel\u2019s suspension, relative to the chassis.\n     *\n     * The ray-casting will happen following this direction to detect the ground.\n     */\n    public wheelDirectionCs(i: number): Vector | null {\n        return VectorOps.fromRaw(this.raw.wheel_direction_cs(i));\n    }\n\n    /**\n     * Sets the direction of the i-th wheel\u2019s suspension, relative to the chassis.\n     *\n     * The ray-casting will happen following this direction to detect the ground.\n     */\n    public setWheelDirectionCs(i: number, value: Vector) {\n        let rawValue = VectorOps.intoRaw(value);\n        this.raw.set_wheel_direction_cs(i, rawValue);\n        rawValue.free();\n    }\n\n    /**\n     * The i-th wheel\u2019s axle axis, relative to the chassis.\n     *\n     * The axis index defined as 0 = X, 1 = Y, 2 = Z.\n     */\n    public wheelAxleCs(i: number): Vector | null {\n        return VectorOps.fromRaw(this.raw.wheel_axle_cs(i));\n    }\n\n    /**\n     * Sets the i-th wheel\u2019s axle axis, relative to the chassis.\n     *\n     * The axis index defined as 0 = X, 1 = Y, 2 = Z.\n     */\n    public setWheelAxleCs(i: number, value: Vector) {\n        let rawValue = VectorOps.intoRaw(value);\n        this.raw.set_wheel_axle_cs(i, rawValue);\n        rawValue.free();\n    }\n\n    /**\n     * Parameter controlling how much traction the tire has.\n     *\n     * The larger the value, the more instantaneous braking will happen (with the risk of\n     * causing the vehicle to flip if it\u2019s too strong).\n     */\n    public wheelFrictionSlip(i: number): number | null {\n        return this.raw.wheel_friction_slip(i);\n    }\n\n    /**\n     * Sets the parameter controlling how much traction the tire has.\n     *\n     * The larger the value, the more instantaneous braking will happen (with the risk of\n     * causing the vehicle to flip if it\u2019s too strong).\n     */\n    public setWheelFrictionSlip(i: number, value: number) {\n        this.raw.set_wheel_friction_slip(i, value);\n    }\n\n    /*\n     * Getters only.\n     */\n\n    /**\n     *  The i-th wheel\u2019s current rotation angle (radians) on its axle.\n     */\n    public wheelRotation(i: number): number | null {\n        return this.raw.wheel_rotation(i);\n    }\n\n    /**\n     *  The forward impulses applied by the i-th wheel on the chassis.\n     */\n    public wheelForwardImpulse(i: number): number | null {\n        return this.raw.wheel_forward_impulse(i);\n    }\n\n    /**\n     *  The side impulses applied by the i-th wheel on the chassis.\n     */\n    public wheelSideImpulse(i: number): number | null {\n        return this.raw.wheel_side_impulse(i);\n    }\n\n    /**\n     *  The force applied by the i-th wheel suspension.\n     */\n    public wheelSuspensionForce(i: number): number | null {\n        return this.raw.wheel_suspension_force(i);\n    }\n\n    /**\n     *  The (world-space) contact normal between the i-th wheel and the floor.\n     */\n    public wheelContactNormal(i: number): Vector | null {\n        return VectorOps.fromRaw(this.raw.wheel_contact_normal_ws(i));\n    }\n\n    /**\n     *  The (world-space) point hit by the wheel\u2019s ray-cast for the i-th wheel.\n     */\n    public wheelContactPoint(i: number): Vector | null {\n        return VectorOps.fromRaw(this.raw.wheel_contact_point_ws(i));\n    }\n\n    /**\n     *  The suspension length for the i-th wheel.\n     */\n    public wheelSuspensionLength(i: number): number | null {\n        return this.raw.wheel_suspension_length(i);\n    }\n\n    /**\n     *  The (world-space) starting point of the ray-cast for the i-th wheel.\n     */\n    public wheelHardPoint(i: number): Vector | null {\n        return VectorOps.fromRaw(this.raw.wheel_hard_point_ws(i));\n    }\n\n    /**\n     *  Is the i-th wheel in contact with the ground?\n     */\n    public wheelIsInContact(i: number): boolean {\n        return this.raw.wheel_is_in_contact(i);\n    }\n\n    /**\n     *  The collider hit by the ray-cast for the i-th wheel.\n     */\n    public wheelGroundObject(i: number): Collider | null {\n        return this.colliders.get(this.raw.wheel_ground_object(i));\n    }\n}\n", "import {\n    RawBroadPhase,\n    RawCCDSolver,\n    RawColliderSet,\n    RawDeserializedWorld,\n    RawIntegrationParameters,\n    RawIslandManager,\n    RawImpulseJointSet,\n    RawMultibodyJointSet,\n    RawNarrowPhase,\n    RawPhysicsPipeline,\n    RawQueryPipeline,\n    RawRigidBodySet,\n    RawSerializationPipeline,\n    RawDebugRenderPipeline,\n} from \"../raw\";\n\nimport {\n    BroadPhase,\n    Collider,\n    ColliderDesc,\n    ColliderHandle,\n    ColliderSet,\n    InteractionGroups,\n    NarrowPhase,\n    PointColliderProjection,\n    Ray,\n    RayColliderIntersection,\n    RayColliderToi,\n    Shape,\n    ShapeColliderTOI,\n    TempContactManifold,\n} from \"../geometry\";\nimport {\n    CCDSolver,\n    IntegrationParameters,\n    IslandManager,\n    ImpulseJoint,\n    ImpulseJointHandle,\n    MultibodyJoint,\n    MultibodyJointHandle,\n    JointData,\n    ImpulseJointSet,\n    MultibodyJointSet,\n    RigidBody,\n    RigidBodyDesc,\n    RigidBodyHandle,\n    RigidBodySet,\n} from \"../dynamics\";\nimport {Rotation, Vector, VectorOps} from \"../math\";\nimport {PhysicsPipeline} from \"./physics_pipeline\";\nimport {QueryFilterFlags, QueryPipeline} from \"./query_pipeline\";\nimport {SerializationPipeline} from \"./serialization_pipeline\";\nimport {EventQueue} from \"./event_queue\";\nimport {PhysicsHooks} from \"./physics_hooks\";\nimport {DebugRenderBuffers, DebugRenderPipeline} from \"./debug_render_pipeline\";\nimport {KinematicCharacterController} from \"../control\";\nimport {Coarena} from \"../coarena\";\n\n// #if DIM3\nimport {DynamicRayCastVehicleController} from \"../control\";\n// #endif\n\n/**\n * The physics world.\n *\n * This contains all the data-structures necessary for creating and simulating\n * bodies with contacts, joints, and external forces.\n */\nexport class World {\n    public gravity: Vector;\n    integrationParameters: IntegrationParameters;\n    islands: IslandManager;\n    broadPhase: BroadPhase;\n    narrowPhase: NarrowPhase;\n    bodies: RigidBodySet;\n    colliders: ColliderSet;\n    impulseJoints: ImpulseJointSet;\n    multibodyJoints: MultibodyJointSet;\n    ccdSolver: CCDSolver;\n    queryPipeline: QueryPipeline;\n    physicsPipeline: PhysicsPipeline;\n    serializationPipeline: SerializationPipeline;\n    debugRenderPipeline: DebugRenderPipeline;\n    characterControllers: Set<KinematicCharacterController>;\n\n    // #if DIM3\n    vehicleControllers: Set<DynamicRayCastVehicleController>;\n    // #endif\n\n    /**\n     * Release the WASM memory occupied by this physics world.\n     *\n     * All the fields of this physics world will be freed as well,\n     * so there is no need to call their `.free()` methods individually.\n     */\n    public free() {\n        this.integrationParameters.free();\n        this.islands.free();\n        this.broadPhase.free();\n        this.narrowPhase.free();\n        this.bodies.free();\n        this.colliders.free();\n        this.impulseJoints.free();\n        this.multibodyJoints.free();\n        this.ccdSolver.free();\n        this.queryPipeline.free();\n        this.physicsPipeline.free();\n        this.serializationPipeline.free();\n        this.debugRenderPipeline.free();\n        this.characterControllers.forEach((controller) => controller.free());\n\n        // #if DIM3\n        this.vehicleControllers.forEach((controller) => controller.free());\n        // #endif\n\n        this.integrationParameters = undefined;\n        this.islands = undefined;\n        this.broadPhase = undefined;\n        this.narrowPhase = undefined;\n        this.bodies = undefined;\n        this.colliders = undefined;\n        this.ccdSolver = undefined;\n        this.impulseJoints = undefined;\n        this.multibodyJoints = undefined;\n        this.queryPipeline = undefined;\n        this.physicsPipeline = undefined;\n        this.serializationPipeline = undefined;\n        this.debugRenderPipeline = undefined;\n        this.characterControllers = undefined;\n\n        // #if DIM3\n        this.vehicleControllers = undefined;\n        // #endif\n    }\n\n    constructor(\n        gravity: Vector,\n        rawIntegrationParameters?: RawIntegrationParameters,\n        rawIslands?: RawIslandManager,\n        rawBroadPhase?: RawBroadPhase,\n        rawNarrowPhase?: RawNarrowPhase,\n        rawBodies?: RawRigidBodySet,\n        rawColliders?: RawColliderSet,\n        rawImpulseJoints?: RawImpulseJointSet,\n        rawMultibodyJoints?: RawMultibodyJointSet,\n        rawCCDSolver?: RawCCDSolver,\n        rawQueryPipeline?: RawQueryPipeline,\n        rawPhysicsPipeline?: RawPhysicsPipeline,\n        rawSerializationPipeline?: RawSerializationPipeline,\n        rawDebugRenderPipeline?: RawDebugRenderPipeline,\n    ) {\n        this.gravity = gravity;\n        this.integrationParameters = new IntegrationParameters(\n            rawIntegrationParameters,\n        );\n        this.islands = new IslandManager(rawIslands);\n        this.broadPhase = new BroadPhase(rawBroadPhase);\n        this.narrowPhase = new NarrowPhase(rawNarrowPhase);\n        this.bodies = new RigidBodySet(rawBodies);\n        this.colliders = new ColliderSet(rawColliders);\n        this.impulseJoints = new ImpulseJointSet(rawImpulseJoints);\n        this.multibodyJoints = new MultibodyJointSet(rawMultibodyJoints);\n        this.ccdSolver = new CCDSolver(rawCCDSolver);\n        this.queryPipeline = new QueryPipeline(rawQueryPipeline);\n        this.physicsPipeline = new PhysicsPipeline(rawPhysicsPipeline);\n        this.serializationPipeline = new SerializationPipeline(\n            rawSerializationPipeline,\n        );\n        this.debugRenderPipeline = new DebugRenderPipeline(\n            rawDebugRenderPipeline,\n        );\n        this.characterControllers = new Set<KinematicCharacterController>();\n\n        // #if DIM3\n        this.vehicleControllers = new Set<DynamicRayCastVehicleController>();\n        // #endif\n\n        this.impulseJoints.finalizeDeserialization(this.bodies);\n        this.bodies.finalizeDeserialization(this.colliders);\n        this.colliders.finalizeDeserialization(this.bodies);\n    }\n\n    public static fromRaw(raw: RawDeserializedWorld): World {\n        if (!raw) return null;\n\n        return new World(\n            VectorOps.fromRaw(raw.takeGravity()),\n            raw.takeIntegrationParameters(),\n            raw.takeIslandManager(),\n            raw.takeBroadPhase(),\n            raw.takeNarrowPhase(),\n            raw.takeBodies(),\n            raw.takeColliders(),\n            raw.takeImpulseJoints(),\n            raw.takeMultibodyJoints(),\n        );\n    }\n\n    /**\n     * Takes a snapshot of this world.\n     *\n     * Use `World.restoreSnapshot` to create a new physics world with a state identical to\n     * the state when `.takeSnapshot()` is called.\n     */\n    public takeSnapshot(): Uint8Array {\n        return this.serializationPipeline.serializeAll(\n            this.gravity,\n            this.integrationParameters,\n            this.islands,\n            this.broadPhase,\n            this.narrowPhase,\n            this.bodies,\n            this.colliders,\n            this.impulseJoints,\n            this.multibodyJoints,\n        );\n    }\n\n    /**\n     * Creates a new physics world from a snapshot.\n     *\n     * This new physics world will be an identical copy of the snapshoted physics world.\n     */\n    public static restoreSnapshot(data: Uint8Array): World {\n        let deser = new SerializationPipeline();\n        return deser.deserializeAll(data);\n    }\n\n    /**\n     * Computes all the lines (and their colors) needed to render the scene.\n     */\n    public debugRender(): DebugRenderBuffers {\n        this.debugRenderPipeline.render(\n            this.bodies,\n            this.colliders,\n            this.impulseJoints,\n            this.multibodyJoints,\n            this.narrowPhase,\n        );\n        return new DebugRenderBuffers(\n            this.debugRenderPipeline.vertices,\n            this.debugRenderPipeline.colors,\n        );\n    }\n\n    /**\n     * Advance the simulation by one time step.\n     *\n     * All events generated by the physics engine are ignored.\n     *\n     * @param EventQueue - (optional) structure responsible for collecting\n     *   events generated by the physics engine.\n     */\n    public step(eventQueue?: EventQueue, hooks?: PhysicsHooks) {\n        this.physicsPipeline.step(\n            this.gravity,\n            this.integrationParameters,\n            this.islands,\n            this.broadPhase,\n            this.narrowPhase,\n            this.bodies,\n            this.colliders,\n            this.impulseJoints,\n            this.multibodyJoints,\n            this.ccdSolver,\n            eventQueue,\n            hooks,\n        );\n        this.queryPipeline.update(this.bodies, this.colliders);\n    }\n\n    /**\n     * Update colliders positions after rigid-bodies moved.\n     *\n     * When a rigid-body moves, the positions of the colliders attached to it need to be updated. This update is\n     * generally automatically done at the beginning and the end of each simulation step with World.step.\n     * If the positions need to be updated without running a simulation step this method can be called manually.\n     */\n    public propagateModifiedBodyPositionsToColliders() {\n        this.bodies.raw.propagateModifiedBodyPositionsToColliders(\n            this.colliders.raw,\n        );\n    }\n\n    /**\n     * Ensure subsequent scene queries take into account the collider positions set before this method is called.\n     *\n     * This does not step the physics simulation forward.\n     */\n    public updateSceneQueries() {\n        this.propagateModifiedBodyPositionsToColliders();\n        this.queryPipeline.update(this.bodies, this.colliders);\n    }\n\n    /**\n     * The current simulation timestep.\n     */\n    get timestep(): number {\n        return this.integrationParameters.dt;\n    }\n\n    /**\n     * Sets the new simulation timestep.\n     *\n     * The simulation timestep governs by how much the physics state of the world will\n     * be integrated. A simulation timestep should:\n     * - be as small as possible. Typical values evolve around 0.016 (assuming the chosen unit is milliseconds,\n     * corresponds to the time between two frames of a game running at 60FPS).\n     * - not vary too much during the course of the simulation. A timestep with large variations may\n     * cause instabilities in the simulation.\n     *\n     * @param dt - The timestep length, in seconds.\n     */\n    set timestep(dt: number) {\n        this.integrationParameters.dt = dt;\n    }\n\n    /**\n     * The maximum velocity iterations the velocity-based force constraint solver can make.\n     */\n    get maxVelocityIterations(): number {\n        return this.integrationParameters.maxVelocityIterations;\n    }\n\n    /**\n     * Sets the maximum number of velocity iterations (default: 4).\n     *\n     * The greater this value is, the most rigid and realistic the physics simulation will be.\n     * However a greater number of iterations is more computationally intensive.\n     *\n     * @param niter - The new maximum number of velocity iterations.\n     */\n    set maxVelocityIterations(niter: number) {\n        this.integrationParameters.maxVelocityIterations = niter;\n    }\n\n    /**\n     * The maximum velocity iterations the velocity-based friction constraint solver can make.\n     */\n    get maxVelocityFrictionIterations(): number {\n        return this.integrationParameters.maxVelocityFrictionIterations;\n    }\n\n    /**\n     * Sets the maximum number of velocity iterations for friction (default: 8).\n     *\n     * The greater this value is, the most realistic friction will be.\n     * However a greater number of iterations is more computationally intensive.\n     *\n     * @param niter - The new maximum number of velocity iterations.\n     */\n    set maxVelocityFrictionIterations(niter: number) {\n        this.integrationParameters.maxVelocityFrictionIterations = niter;\n    }\n\n    /**\n     * The maximum velocity iterations the velocity-based constraint solver can make to attempt to remove\n     * the energy introduced by constraint stabilization.\n     */\n    get maxStabilizationIterations(): number {\n        return this.integrationParameters.maxStabilizationIterations;\n    }\n\n    /**\n     * Sets the maximum number of velocity iterations for stabilization (default: 1).\n     *\n     * @param niter - The new maximum number of velocity iterations.\n     */\n    set maxStabilizationIterations(niter: number) {\n        this.integrationParameters.maxStabilizationIterations = niter;\n    }\n\n    /**\n     * Creates a new rigid-body from the given rigd-body descriptior.\n     *\n     * @param body - The description of the rigid-body to create.\n     */\n    public createRigidBody(body: RigidBodyDesc): RigidBody {\n        return this.bodies.createRigidBody(this.colliders, body);\n    }\n\n    /**\n     * Creates a new character controller.\n     *\n     * @param offset - The artificial gap added between the character\u2019s chape and its environment.\n     */\n    public createCharacterController(\n        offset: number,\n    ): KinematicCharacterController {\n        let controller = new KinematicCharacterController(\n            offset,\n            this.integrationParameters,\n            this.bodies,\n            this.colliders,\n            this.queryPipeline,\n        );\n        this.characterControllers.add(controller);\n        return controller;\n    }\n\n    /**\n     * Removes a character controller from this world.\n     *\n     * @param controller - The character controller to remove.\n     */\n    public removeCharacterController(controller: KinematicCharacterController) {\n        this.characterControllers.delete(controller);\n        controller.free();\n    }\n\n    // #if DIM3\n    /**\n     * Creates a new vehicle controller.\n     *\n     * @param chassis - The rigid-body used as the chassis of the vehicle controller. When the vehicle\n     *                  controller is updated, it will change directly the rigid-body\u2019s velocity. This\n     *                  rigid-body must be a dynamic or kinematic-velocity-based rigid-body.\n     */\n    public createVehicleController(\n        chassis: RigidBody,\n    ): DynamicRayCastVehicleController {\n        let controller = new DynamicRayCastVehicleController(\n            chassis,\n            this.bodies,\n            this.colliders,\n            this.queryPipeline,\n        );\n        this.vehicleControllers.add(controller);\n        return controller;\n    }\n\n    /**\n     * Removes a vehicle controller from this world.\n     *\n     * @param controller - The vehicle controller to remove.\n     */\n    public removeVehicleController(\n        controller: DynamicRayCastVehicleController,\n    ) {\n        this.vehicleControllers.delete(controller);\n        controller.free();\n    }\n    // #endif\n\n    /**\n     * Creates a new collider.\n     *\n     * @param desc - The description of the collider.\n     * @param parent - The rigid-body this collider is attached to.\n     */\n    public createCollider(desc: ColliderDesc, parent?: RigidBody): Collider {\n        let parentHandle = parent ? parent.handle : undefined;\n        return this.colliders.createCollider(this.bodies, desc, parentHandle);\n    }\n\n    /**\n     * Creates a new impulse joint from the given joint descriptor.\n     *\n     * @param params - The description of the joint to create.\n     * @param parent1 - The first rigid-body attached to this joint.\n     * @param parent2 - The second rigid-body attached to this joint.\n     * @param wakeUp - Should the attached rigid-bodies be awakened?\n     */\n    public createImpulseJoint(\n        params: JointData,\n        parent1: RigidBody,\n        parent2: RigidBody,\n        wakeUp: boolean,\n    ): ImpulseJoint {\n        return this.impulseJoints.createJoint(\n            this.bodies,\n            params,\n            parent1.handle,\n            parent2.handle,\n            wakeUp,\n        );\n    }\n\n    /**\n     * Creates a new multibody joint from the given joint descriptor.\n     *\n     * @param params - The description of the joint to create.\n     * @param parent1 - The first rigid-body attached to this joint.\n     * @param parent2 - The second rigid-body attached to this joint.\n     * @param wakeUp - Should the attached rigid-bodies be awakened?\n     */\n    public createMultibodyJoint(\n        params: JointData,\n        parent1: RigidBody,\n        parent2: RigidBody,\n        wakeUp: boolean,\n    ): MultibodyJoint {\n        return this.multibodyJoints.createJoint(\n            params,\n            parent1.handle,\n            parent2.handle,\n            wakeUp,\n        );\n    }\n\n    /**\n     * Retrieves a rigid-body from its handle.\n     *\n     * @param handle - The integer handle of the rigid-body to retrieve.\n     */\n    public getRigidBody(handle: RigidBodyHandle): RigidBody {\n        return this.bodies.get(handle);\n    }\n\n    /**\n     * Retrieves a collider from its handle.\n     *\n     * @param handle - The integer handle of the collider to retrieve.\n     */\n    public getCollider(handle: ColliderHandle): Collider {\n        return this.colliders.get(handle);\n    }\n\n    /**\n     * Retrieves an impulse joint from its handle.\n     *\n     * @param handle - The integer handle of the impulse joint to retrieve.\n     */\n    public getImpulseJoint(handle: ImpulseJointHandle): ImpulseJoint {\n        return this.impulseJoints.get(handle);\n    }\n\n    /**\n     * Retrieves an multibody joint from its handle.\n     *\n     * @param handle - The integer handle of the multibody joint to retrieve.\n     */\n    public getMultibodyJoint(handle: MultibodyJointHandle): MultibodyJoint {\n        return this.multibodyJoints.get(handle);\n    }\n\n    /**\n     * Removes the given rigid-body from this physics world.\n     *\n     * This will remove this rigid-body as well as all its attached colliders and joints.\n     * Every other bodies touching or attached by joints to this rigid-body will be woken-up.\n     *\n     * @param body - The rigid-body to remove.\n     */\n    public removeRigidBody(body: RigidBody) {\n        if (this.bodies) {\n            this.bodies.remove(\n                body.handle,\n                this.islands,\n                this.colliders,\n                this.impulseJoints,\n                this.multibodyJoints,\n            );\n        }\n    }\n\n    /**\n     * Removes the given collider from this physics world.\n     *\n     * @param collider - The collider to remove.\n     * @param wakeUp - If set to `true`, the rigid-body this collider is attached to will be awaken.\n     */\n    public removeCollider(collider: Collider, wakeUp: boolean) {\n        if (this.colliders) {\n            this.colliders.remove(\n                collider.handle,\n                this.islands,\n                this.bodies,\n                wakeUp,\n            );\n        }\n    }\n\n    /**\n     * Removes the given impulse joint from this physics world.\n     *\n     * @param joint - The impulse joint to remove.\n     * @param wakeUp - If set to `true`, the rigid-bodies attached by this joint will be awaken.\n     */\n    public removeImpulseJoint(joint: ImpulseJoint, wakeUp: boolean) {\n        if (this.impulseJoints) {\n            this.impulseJoints.remove(joint.handle, wakeUp);\n        }\n    }\n\n    /**\n     * Removes the given multibody joint from this physics world.\n     *\n     * @param joint - The multibody joint to remove.\n     * @param wakeUp - If set to `true`, the rigid-bodies attached by this joint will be awaken.\n     */\n    public removeMultibodyJoint(joint: MultibodyJoint, wakeUp: boolean) {\n        if (this.impulseJoints) {\n            this.multibodyJoints.remove(joint.handle, wakeUp);\n        }\n    }\n\n    /**\n     * Applies the given closure to each collider managed by this physics world.\n     *\n     * @param f(collider) - The function to apply to each collider managed by this physics world. Called as `f(collider)`.\n     */\n    public forEachCollider(f: (collider: Collider) => void) {\n        this.colliders.forEach(f);\n    }\n\n    /**\n     * Applies the given closure to each rigid-body managed by this physics world.\n     *\n     * @param f(body) - The function to apply to each rigid-body managed by this physics world. Called as `f(collider)`.\n     */\n    public forEachRigidBody(f: (body: RigidBody) => void) {\n        this.bodies.forEach(f);\n    }\n\n    /**\n     * Applies the given closure to each active rigid-body managed by this physics world.\n     *\n     * After a short time of inactivity, a rigid-body is automatically deactivated (\"asleep\") by\n     * the physics engine in order to save computational power. A sleeping rigid-body never moves\n     * unless it is moved manually by the user.\n     *\n     * @param f - The function to apply to each active rigid-body managed by this physics world. Called as `f(collider)`.\n     */\n    public forEachActiveRigidBody(f: (body: RigidBody) => void) {\n        this.bodies.forEachActiveRigidBody(this.islands, f);\n    }\n\n    /**\n     * Find the closest intersection between a ray and the physics world.\n     *\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     * @param filter - The callback to filter out which collider will be hit.\n     */\n    public castRay(\n        ray: Ray,\n        maxToi: number,\n        solid: boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: Collider,\n        filterExcludeRigidBody?: RigidBody,\n        filterPredicate?: (collider: Collider) => boolean,\n    ): RayColliderToi | null {\n        return this.queryPipeline.castRay(\n            this.bodies,\n            this.colliders,\n            ray,\n            maxToi,\n            solid,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider ? filterExcludeCollider.handle : null,\n            filterExcludeRigidBody ? filterExcludeRigidBody.handle : null,\n            this.colliders.castClosure(filterPredicate),\n        );\n    }\n\n    /**\n     * Find the closest intersection between a ray and the physics world.\n     *\n     * This also computes the normal at the hit point.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     */\n    public castRayAndGetNormal(\n        ray: Ray,\n        maxToi: number,\n        solid: boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: Collider,\n        filterExcludeRigidBody?: RigidBody,\n        filterPredicate?: (collider: Collider) => boolean,\n    ): RayColliderIntersection | null {\n        return this.queryPipeline.castRayAndGetNormal(\n            this.bodies,\n            this.colliders,\n            ray,\n            maxToi,\n            solid,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider ? filterExcludeCollider.handle : null,\n            filterExcludeRigidBody ? filterExcludeRigidBody.handle : null,\n            this.colliders.castClosure(filterPredicate),\n        );\n    }\n\n    /**\n     * Cast a ray and collects all the intersections between a ray and the scene.\n     *\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     * @param callback - The callback called once per hit (in no particular order) between a ray and a collider.\n     *   If this callback returns `false`, then the cast will stop and no further hits will be detected/reported.\n     */\n    public intersectionsWithRay(\n        ray: Ray,\n        maxToi: number,\n        solid: boolean,\n        callback: (intersect: RayColliderIntersection) => boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: Collider,\n        filterExcludeRigidBody?: RigidBody,\n        filterPredicate?: (collider: Collider) => boolean,\n    ) {\n        this.queryPipeline.intersectionsWithRay(\n            this.bodies,\n            this.colliders,\n            ray,\n            maxToi,\n            solid,\n            callback,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider ? filterExcludeCollider.handle : null,\n            filterExcludeRigidBody ? filterExcludeRigidBody.handle : null,\n            this.colliders.castClosure(filterPredicate),\n        );\n    }\n\n    /**\n     * Gets the handle of up to one collider intersecting the given shape.\n     *\n     * @param shapePos - The position of the shape used for the intersection test.\n     * @param shapeRot - The orientation of the shape used for the intersection test.\n     * @param shape - The shape used for the intersection test.\n     * @param groups - The bit groups and filter associated to the ray, in order to only\n     *   hit the colliders with collision groups compatible with the ray's group.\n     */\n    public intersectionWithShape(\n        shapePos: Vector,\n        shapeRot: Rotation,\n        shape: Shape,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: Collider,\n        filterExcludeRigidBody?: RigidBody,\n        filterPredicate?: (collider: Collider) => boolean,\n    ): Collider | null {\n        let handle = this.queryPipeline.intersectionWithShape(\n            this.bodies,\n            this.colliders,\n            shapePos,\n            shapeRot,\n            shape,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider ? filterExcludeCollider.handle : null,\n            filterExcludeRigidBody ? filterExcludeRigidBody.handle : null,\n            this.colliders.castClosure(filterPredicate),\n        );\n        return handle != null ? this.colliders.get(handle) : null;\n    }\n\n    /**\n     * Find the projection of a point on the closest collider.\n     *\n     * @param point - The point to project.\n     * @param solid - If this is set to `true` then the collider shapes are considered to\n     *   be plain (if the point is located inside of a plain shape, its projection is the point\n     *   itself). If it is set to `false` the collider shapes are considered to be hollow\n     *   (if the point is located inside of an hollow shape, it is projected on the shape's\n     *   boundary).\n     * @param groups - The bit groups and filter associated to the point to project, in order to only\n     *   project on colliders with collision groups compatible with the ray's group.\n     */\n    public projectPoint(\n        point: Vector,\n        solid: boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: Collider,\n        filterExcludeRigidBody?: RigidBody,\n        filterPredicate?: (collider: Collider) => boolean,\n    ): PointColliderProjection | null {\n        return this.queryPipeline.projectPoint(\n            this.bodies,\n            this.colliders,\n            point,\n            solid,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider ? filterExcludeCollider.handle : null,\n            filterExcludeRigidBody ? filterExcludeRigidBody.handle : null,\n            this.colliders.castClosure(filterPredicate),\n        );\n    }\n\n    /**\n     * Find the projection of a point on the closest collider.\n     *\n     * @param point - The point to project.\n     * @param groups - The bit groups and filter associated to the point to project, in order to only\n     *   project on colliders with collision groups compatible with the ray's group.\n     */\n    public projectPointAndGetFeature(\n        point: Vector,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: Collider,\n        filterExcludeRigidBody?: RigidBody,\n        filterPredicate?: (collider: Collider) => boolean,\n    ): PointColliderProjection | null {\n        return this.queryPipeline.projectPointAndGetFeature(\n            this.bodies,\n            this.colliders,\n            point,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider ? filterExcludeCollider.handle : null,\n            filterExcludeRigidBody ? filterExcludeRigidBody.handle : null,\n            this.colliders.castClosure(filterPredicate),\n        );\n    }\n\n    /**\n     * Find all the colliders containing the given point.\n     *\n     * @param point - The point used for the containment test.\n     * @param groups - The bit groups and filter associated to the point to test, in order to only\n     *   test on colliders with collision groups compatible with the ray's group.\n     * @param callback - A function called with the handles of each collider with a shape\n     *   containing the `point`.\n     */\n    public intersectionsWithPoint(\n        point: Vector,\n        callback: (handle: Collider) => boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: Collider,\n        filterExcludeRigidBody?: RigidBody,\n        filterPredicate?: (collider: Collider) => boolean,\n    ) {\n        this.queryPipeline.intersectionsWithPoint(\n            this.bodies,\n            this.colliders,\n            point,\n            this.colliders.castClosure(callback),\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider ? filterExcludeCollider.handle : null,\n            filterExcludeRigidBody ? filterExcludeRigidBody.handle : null,\n            this.colliders.castClosure(filterPredicate),\n        );\n    }\n\n    /**\n     * Casts a shape at a constant linear velocity and retrieve the first collider it hits.\n     * This is similar to ray-casting except that we are casting a whole shape instead of\n     * just a point (the ray origin).\n     *\n     * @param shapePos - The initial position of the shape to cast.\n     * @param shapeRot - The initial rotation of the shape to cast.\n     * @param shapeVel - The constant velocity of the shape to cast (i.e. the cast direction).\n     * @param shape - The shape to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the distance traveled by the shape to `shapeVel.norm() * maxToi`.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast won\u2019t immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that it\u2019s on a path to exist that penetration state.\n     * @param groups - The bit groups and filter associated to the shape to cast, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     */\n    public castShape(\n        shapePos: Vector,\n        shapeRot: Rotation,\n        shapeVel: Vector,\n        shape: Shape,\n        maxToi: number,\n        stopAtPenetration: boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: Collider,\n        filterExcludeRigidBody?: RigidBody,\n        filterPredicate?: (collider: Collider) => boolean,\n    ): ShapeColliderTOI | null {\n        return this.queryPipeline.castShape(\n            this.bodies,\n            this.colliders,\n            shapePos,\n            shapeRot,\n            shapeVel,\n            shape,\n            maxToi,\n            stopAtPenetration,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider ? filterExcludeCollider.handle : null,\n            filterExcludeRigidBody ? filterExcludeRigidBody.handle : null,\n            this.colliders.castClosure(filterPredicate),\n        );\n    }\n\n    /**\n     * Retrieve all the colliders intersecting the given shape.\n     *\n     * @param shapePos - The position of the shape to test.\n     * @param shapeRot - The orientation of the shape to test.\n     * @param shape - The shape to test.\n     * @param groups - The bit groups and filter associated to the shape to test, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     * @param callback - A function called with the handles of each collider intersecting the `shape`.\n     */\n    public intersectionsWithShape(\n        shapePos: Vector,\n        shapeRot: Rotation,\n        shape: Shape,\n        callback: (collider: Collider) => boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: Collider,\n        filterExcludeRigidBody?: RigidBody,\n        filterPredicate?: (collider: Collider) => boolean,\n    ) {\n        this.queryPipeline.intersectionsWithShape(\n            this.bodies,\n            this.colliders,\n            shapePos,\n            shapeRot,\n            shape,\n            this.colliders.castClosure(callback),\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider ? filterExcludeCollider.handle : null,\n            filterExcludeRigidBody ? filterExcludeRigidBody.handle : null,\n            this.colliders.castClosure(filterPredicate),\n        );\n    }\n\n    /**\n     * Finds the handles of all the colliders with an AABB intersecting the given AABB.\n     *\n     * @param aabbCenter - The center of the AABB to test.\n     * @param aabbHalfExtents - The half-extents of the AABB to test.\n     * @param callback - The callback that will be called with the handles of all the colliders\n     *                   currently intersecting the given AABB.\n     */\n    public collidersWithAabbIntersectingAabb(\n        aabbCenter: Vector,\n        aabbHalfExtents: Vector,\n        callback: (handle: Collider) => boolean,\n    ) {\n        this.queryPipeline.collidersWithAabbIntersectingAabb(\n            aabbCenter,\n            aabbHalfExtents,\n            this.colliders.castClosure(callback),\n        );\n    }\n\n    /**\n     * Enumerates all the colliders potentially in contact with the given collider.\n     *\n     * @param collider1 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each collider that is in contact with `collider1`.\n     */\n    public contactsWith(collider1: Collider, f: (collider2: Collider) => void) {\n        this.narrowPhase.contactsWith(\n            collider1.handle,\n            this.colliders.castClosure(f),\n        );\n    }\n\n    /**\n     * Enumerates all the colliders intersecting the given colliders, assuming one of them\n     * is a sensor.\n     */\n    public intersectionsWith(\n        collider1: Collider,\n        f: (collider2: Collider) => void,\n    ) {\n        this.narrowPhase.intersectionsWith(\n            collider1.handle,\n            this.colliders.castClosure(f),\n        );\n    }\n\n    /**\n     * Iterates through all the contact manifolds between the given pair of colliders.\n     *\n     * @param collider1 - The first collider involved in the contact.\n     * @param collider2 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each contact manifold between the two colliders. If the second argument\n     *            passed to this closure is `true`, then the contact manifold data is flipped, i.e., methods like `localNormal1`\n     *            actually apply to the `collider2` and fields like `localNormal2` apply to the `collider1`.\n     */\n    public contactPair(\n        collider1: Collider,\n        collider2: Collider,\n        f: (manifold: TempContactManifold, flipped: boolean) => void,\n    ) {\n        this.narrowPhase.contactPair(collider1.handle, collider2.handle, f);\n    }\n\n    /**\n     * Returns `true` if `collider1` and `collider2` intersect and at least one of them is a sensor.\n     * @param collider1 \u2212 The first collider involved in the intersection.\n     * @param collider2 \u2212 The second collider involved in the intersection.\n     */\n    public intersectionPair(collider1: Collider, collider2: Collider): boolean {\n        return this.narrowPhase.intersectionPair(\n            collider1.handle,\n            collider2.handle,\n        );\n    }\n}\n", "import {RawContactForceEvent, RawEventQueue} from \"../raw\";\nimport {RigidBodyHandle} from \"../dynamics\";\nimport {Collider, ColliderHandle} from \"../geometry\";\nimport {Vector, VectorOps} from \"../math\";\n\n/**\n * Flags indicating what events are enabled for colliders.\n */\nexport enum ActiveEvents {\n    NONE = 0,\n    /**\n     * Enable collision events.\n     */\n    COLLISION_EVENTS = 0b0001,\n    /**\n     * Enable contact force events.\n     */\n    CONTACT_FORCE_EVENTS = 0b0010,\n}\n\n/**\n * Event occurring when the sum of the magnitudes of the\n * contact forces between two colliders exceed a threshold.\n *\n * This object should **not** be stored anywhere. Its properties can only be\n * read from within the closure given to `EventHandler.drainContactForceEvents`.\n */\nexport class TempContactForceEvent {\n    raw: RawContactForceEvent;\n\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    /**\n     * The first collider involved in the contact.\n     */\n    public collider1(): ColliderHandle {\n        return this.raw.collider1();\n    }\n\n    /**\n     * The second collider involved in the contact.\n     */\n    public collider2(): ColliderHandle {\n        return this.raw.collider2();\n    }\n\n    /**\n     * The sum of all the forces between the two colliders.\n     */\n    public totalForce(): Vector {\n        return VectorOps.fromRaw(this.raw.total_force());\n    }\n\n    /**\n     * The sum of the magnitudes of each force between the two colliders.\n     *\n     * Note that this is **not** the same as the magnitude of `self.total_force`.\n     * Here we are summing the magnitude of all the forces, instead of taking\n     * the magnitude of their sum.\n     */\n    public totalForceMagnitude(): number {\n        return this.raw.total_force_magnitude();\n    }\n\n    /**\n     * The world-space (unit) direction of the force with strongest magnitude.\n     */\n    public maxForceDirection(): Vector {\n        return VectorOps.fromRaw(this.raw.max_force_direction());\n    }\n\n    /**\n     * The magnitude of the largest force at a contact point of this contact pair.\n     */\n    public maxForceMagnitude(): number {\n        return this.raw.max_force_magnitude();\n    }\n}\n\n/**\n * A structure responsible for collecting events generated\n * by the physics engine.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `eventQueue.free()`\n * once you are done using it.\n */\nexport class EventQueue {\n    raw: RawEventQueue;\n\n    /**\n     * Creates a new event collector.\n     *\n     * @param autoDrain -setting this to `true` is strongly recommended. If true, the collector will\n     * be automatically drained before each `world.step(collector)`. If false, the collector will\n     * keep all events in memory unless it is manually drained/cleared; this may lead to unbounded use of\n     * RAM if no drain is performed.\n     */\n    constructor(autoDrain: boolean, raw?: RawEventQueue) {\n        this.raw = raw || new RawEventQueue(autoDrain);\n    }\n\n    /**\n     * Release the WASM memory occupied by this event-queue.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    /**\n     * Applies the given javascript closure on each collision event of this collector, then clear\n     * the internal collision event buffer.\n     *\n     * @param f - JavaScript closure applied to each collision event. The\n     * closure must take three arguments: two integers representing the handles of the colliders\n     * involved in the collision, and a boolean indicating if the collision started (true) or stopped\n     * (false).\n     */\n    public drainCollisionEvents(\n        f: (\n            handle1: ColliderHandle,\n            handle2: ColliderHandle,\n            started: boolean,\n        ) => void,\n    ) {\n        this.raw.drainCollisionEvents(f);\n    }\n\n    /**\n     * Applies the given javascript closure on each contact force event of this collector, then clear\n     * the internal collision event buffer.\n     *\n     * @param f - JavaScript closure applied to each collision event. The\n     *            closure must take one `TempContactForceEvent` argument.\n     */\n    public drainContactForceEvents(f: (event: TempContactForceEvent) => void) {\n        let event = new TempContactForceEvent();\n        this.raw.drainContactForceEvents((raw: RawContactForceEvent) => {\n            event.raw = raw;\n            f(event);\n            event.free();\n        });\n    }\n\n    /**\n     * Removes all events contained by this collector\n     */\n    public clear() {\n        this.raw.clear();\n    }\n}\n", "import {RigidBodyHandle} from \"../dynamics\";\nimport {ColliderHandle} from \"../geometry\";\n\nexport enum ActiveHooks {\n    NONE = 0,\n    FILTER_CONTACT_PAIRS = 0b0001,\n    FILTER_INTERSECTION_PAIRS = 0b0010,\n    // MODIFY_SOLVER_CONTACTS = 0b0100, /* Not supported yet in JS. */\n}\n\nexport enum SolverFlags {\n    EMPTY = 0b000,\n    COMPUTE_IMPULSE = 0b001,\n}\n\nexport interface PhysicsHooks {\n    /**\n     * Function that determines if contacts computation should happen between two colliders, and how the\n     * constraints solver should behave for these contacts.\n     *\n     * This will only be executed and taken into account if at least one of the involved colliders contains the\n     * `ActiveHooks.FILTER_CONTACT_PAIR` flag in its active hooks.\n     *\n     * @param collider1 \u2212 Handle of the first collider involved in the potential contact.\n     * @param collider2 \u2212 Handle of the second collider involved in the potential contact.\n     * @param body1 \u2212 Handle of the first body involved in the potential contact.\n     * @param body2 \u2212 Handle of the second body involved in the potential contact.\n     */\n    filterContactPair(\n        collider1: ColliderHandle,\n        collider2: ColliderHandle,\n        body1: RigidBodyHandle,\n        body2: RigidBodyHandle,\n    ): SolverFlags | null;\n\n    /**\n     * Function that determines if intersection computation should happen between two colliders (where at least\n     * one is a sensor).\n     *\n     * This will only be executed and taken into account if `one of the involved colliders contains the\n     * `ActiveHooks.FILTER_INTERSECTION_PAIR` flag in its active hooks.\n     *\n     * @param collider1 \u2212 Handle of the first collider involved in the potential contact.\n     * @param collider2 \u2212 Handle of the second collider involved in the potential contact.\n     * @param body1 \u2212 Handle of the first body involved in the potential contact.\n     * @param body2 \u2212 Handle of the second body involved in the potential contact.\n     */\n    filterIntersectionPair(\n        collider1: ColliderHandle,\n        collider2: ColliderHandle,\n        body1: RigidBodyHandle,\n        body2: RigidBodyHandle,\n    ): boolean;\n}\n", "import {RawColliderSet} from \"../raw\";\nimport {Rotation, RotationOps, Vector, VectorOps} from \"../math\";\nimport {\n    CoefficientCombineRule,\n    RigidBody,\n    RigidBodyHandle,\n    RigidBodySet,\n} from \"../dynamics\";\nimport {ActiveHooks, ActiveEvents} from \"../pipeline\";\nimport {InteractionGroups} from \"./interaction_groups\";\nimport {\n    Shape,\n    Cuboid,\n    Ball,\n    ShapeType,\n    Capsule,\n    TriMesh,\n    Polyline,\n    Heightfield,\n    Segment,\n    Triangle,\n    RoundTriangle,\n    RoundCuboid,\n    HalfSpace,\n    // #if DIM3\n    Cylinder,\n    RoundCylinder,\n    Cone,\n    RoundCone,\n    ConvexPolyhedron,\n    RoundConvexPolyhedron,\n    // #endif\n} from \"./shape\";\nimport {Ray, RayIntersection} from \"./ray\";\nimport {PointProjection} from \"./point\";\nimport {ShapeColliderTOI, ShapeTOI} from \"./toi\";\nimport {ShapeContact} from \"./contact\";\nimport {ColliderSet} from \"./collider_set\";\n\n/**\n * Flags affecting whether collision-detection happens between two colliders\n * depending on the type of rigid-bodies they are attached to.\n */\nexport enum ActiveCollisionTypes {\n    /**\n     * Enable collision-detection between a collider attached to a dynamic body\n     * and another collider attached to a dynamic body.\n     */\n    DYNAMIC_DYNAMIC = 0b0000_0000_0000_0001,\n    /**\n     * Enable collision-detection between a collider attached to a dynamic body\n     * and another collider attached to a kinematic body.\n     */\n    DYNAMIC_KINEMATIC = 0b0000_0000_0000_1100,\n    /**\n     * Enable collision-detection between a collider attached to a dynamic body\n     * and another collider attached to a fixed body (or not attached to any body).\n     */\n    DYNAMIC_FIXED = 0b0000_0000_0000_0010,\n    /**\n     * Enable collision-detection between a collider attached to a kinematic body\n     * and another collider attached to a kinematic body.\n     */\n    KINEMATIC_KINEMATIC = 0b1100_1100_0000_0000,\n\n    /**\n     * Enable collision-detection between a collider attached to a kinematic body\n     * and another collider attached to a fixed body (or not attached to any body).\n     */\n    KINEMATIC_FIXED = 0b0010_0010_0000_0000,\n\n    /**\n     * Enable collision-detection between a collider attached to a fixed body (or\n     * not attached to any body) and another collider attached to a fixed body (or\n     * not attached to any body).\n     */\n    FIXED_FIXED = 0b0000_0000_0010_0000,\n    /**\n     * The default active collision types, enabling collisions between a dynamic body\n     * and another body of any type, but not enabling collisions between two non-dynamic bodies.\n     */\n    DEFAULT = DYNAMIC_KINEMATIC | DYNAMIC_DYNAMIC | DYNAMIC_FIXED,\n    /**\n     * Enable collisions between any kind of rigid-bodies (including between two non-dynamic bodies).\n     */\n    ALL = DYNAMIC_KINEMATIC |\n        DYNAMIC_DYNAMIC |\n        DYNAMIC_FIXED |\n        KINEMATIC_KINEMATIC |\n        KINEMATIC_FIXED |\n        KINEMATIC_KINEMATIC,\n}\n\n/**\n * The integer identifier of a collider added to a `ColliderSet`.\n */\nexport type ColliderHandle = number;\n\n/**\n * A geometric entity that can be attached to a body so it can be affected\n * by contacts and proximity queries.\n */\nexport class Collider {\n    private colliderSet: ColliderSet; // The Collider won't need to free this.\n    readonly handle: ColliderHandle;\n    private _shape: Shape;\n    private _parent: RigidBody | null;\n\n    constructor(\n        colliderSet: ColliderSet,\n        handle: ColliderHandle,\n        parent: RigidBody | null,\n        shape?: Shape,\n    ) {\n        this.colliderSet = colliderSet;\n        this.handle = handle;\n        this._parent = parent;\n        this._shape = shape;\n    }\n\n    /** @internal */\n    public finalizeDeserialization(bodies: RigidBodySet) {\n        if (this.handle != null) {\n            this._parent = bodies.get(\n                this.colliderSet.raw.coParent(this.handle),\n            );\n        }\n    }\n\n    private ensureShapeIsCached() {\n        if (!this._shape)\n            this._shape = Shape.fromRaw(this.colliderSet.raw, this.handle);\n    }\n\n    /**\n     * The shape of this collider.\n     */\n    public get shape(): Shape {\n        this.ensureShapeIsCached();\n        return this._shape;\n    }\n\n    /**\n     * Checks if this collider is still valid (i.e. that it has\n     * not been deleted from the collider set yet).\n     */\n    public isValid(): boolean {\n        return this.colliderSet.raw.contains(this.handle);\n    }\n\n    /**\n     * The world-space translation of this rigid-body.\n     */\n    public translation(): Vector {\n        return VectorOps.fromRaw(\n            this.colliderSet.raw.coTranslation(this.handle),\n        );\n    }\n\n    /**\n     * The world-space orientation of this rigid-body.\n     */\n    public rotation(): Rotation {\n        return RotationOps.fromRaw(\n            this.colliderSet.raw.coRotation(this.handle),\n        );\n    }\n\n    /**\n     * Is this collider a sensor?\n     */\n    public isSensor(): boolean {\n        return this.colliderSet.raw.coIsSensor(this.handle);\n    }\n\n    /**\n     * Sets whether or not this collider is a sensor.\n     * @param isSensor - If `true`, the collider will be a sensor.\n     */\n    public setSensor(isSensor: boolean) {\n        this.colliderSet.raw.coSetSensor(this.handle, isSensor);\n    }\n\n    /**\n     * Sets the new shape of the collider.\n     * @param shape - The collider\u2019s new shape.\n     */\n    public setShape(shape: Shape) {\n        let rawShape = shape.intoRaw();\n        this.colliderSet.raw.coSetShape(this.handle, rawShape);\n        rawShape.free();\n        this._shape = shape;\n    }\n\n    /**\n     * Sets whether this collider is enabled or not.\n     *\n     * @param enabled - Set to `false` to disable this collider (its parent rigid-body won\u2019t be disabled automatically by this).\n     */\n    public setEnabled(enabled: boolean) {\n        this.colliderSet.raw.coSetEnabled(this.handle, enabled);\n    }\n\n    /**\n     * Is this collider enabled?\n     */\n    public isEnabled(): boolean {\n        return this.colliderSet.raw.coIsEnabled(this.handle);\n    }\n\n    /**\n     * Sets the restitution coefficient of the collider to be created.\n     *\n     * @param restitution - The restitution coefficient in `[0, 1]`. A value of 0 (the default) means no bouncing behavior\n     *                   while 1 means perfect bouncing (though energy may still be lost due to numerical errors of the\n     *                   constraints solver).\n     */\n    public setRestitution(restitution: number) {\n        this.colliderSet.raw.coSetRestitution(this.handle, restitution);\n    }\n\n    /**\n     * Sets the friction coefficient of the collider to be created.\n     *\n     * @param friction - The friction coefficient. Must be greater or equal to 0. This is generally smaller than 1. The\n     *                   higher the coefficient, the stronger friction forces will be for contacts with the collider\n     *                   being built.\n     */\n    public setFriction(friction: number) {\n        this.colliderSet.raw.coSetFriction(this.handle, friction);\n    }\n\n    /**\n     * Gets the rule used to combine the friction coefficients of two colliders\n     * colliders involved in a contact.\n     */\n    public frictionCombineRule(): CoefficientCombineRule {\n        return this.colliderSet.raw.coFrictionCombineRule(this.handle);\n    }\n\n    /**\n     * Sets the rule used to combine the friction coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule \u2212 The combine rule to apply.\n     */\n    public setFrictionCombineRule(rule: CoefficientCombineRule) {\n        this.colliderSet.raw.coSetFrictionCombineRule(this.handle, rule);\n    }\n\n    /**\n     * Gets the rule used to combine the restitution coefficients of two colliders\n     * colliders involved in a contact.\n     */\n    public restitutionCombineRule(): CoefficientCombineRule {\n        return this.colliderSet.raw.coRestitutionCombineRule(this.handle);\n    }\n\n    /**\n     * Sets the rule used to combine the restitution coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule \u2212 The combine rule to apply.\n     */\n    public setRestitutionCombineRule(rule: CoefficientCombineRule) {\n        this.colliderSet.raw.coSetRestitutionCombineRule(this.handle, rule);\n    }\n\n    /**\n     * Sets the collision groups used by this collider.\n     *\n     * Two colliders will interact iff. their collision groups are compatible.\n     * See the documentation of `InteractionGroups` for details on teh used bit pattern.\n     *\n     * @param groups - The collision groups used for the collider being built.\n     */\n    public setCollisionGroups(groups: InteractionGroups) {\n        this.colliderSet.raw.coSetCollisionGroups(this.handle, groups);\n    }\n\n    /**\n     * Sets the solver groups used by this collider.\n     *\n     * Forces between two colliders in contact will be computed iff their solver\n     * groups are compatible.\n     * See the documentation of `InteractionGroups` for details on the used bit pattern.\n     *\n     * @param groups - The solver groups used for the collider being built.\n     */\n    public setSolverGroups(groups: InteractionGroups) {\n        this.colliderSet.raw.coSetSolverGroups(this.handle, groups);\n    }\n\n    /**\n     * Get the physics hooks active for this collider.\n     */\n    public activeHooks() {\n        return this.colliderSet.raw.coActiveHooks(this.handle);\n    }\n\n    /**\n     * Set the physics hooks active for this collider.\n     *\n     * Use this to enable custom filtering rules for contact/intersecstion pairs involving this collider.\n     *\n     * @param activeHooks - The hooks active for contact/intersection pairs involving this collider.\n     */\n    public setActiveHooks(activeHooks: ActiveHooks) {\n        this.colliderSet.raw.coSetActiveHooks(this.handle, activeHooks);\n    }\n\n    /**\n     * The events active for this collider.\n     */\n    public activeEvents(): ActiveEvents {\n        return this.colliderSet.raw.coActiveEvents(this.handle);\n    }\n\n    /**\n     * Set the events active for this collider.\n     *\n     * Use this to enable contact and/or intersection event reporting for this collider.\n     *\n     * @param activeEvents - The events active for contact/intersection pairs involving this collider.\n     */\n    public setActiveEvents(activeEvents: ActiveEvents) {\n        this.colliderSet.raw.coSetActiveEvents(this.handle, activeEvents);\n    }\n\n    /**\n     * Gets the collision types active for this collider.\n     */\n    public activeCollisionTypes(): ActiveCollisionTypes {\n        return this.colliderSet.raw.coActiveCollisionTypes(this.handle);\n    }\n\n    /**\n     * Sets the total force magnitude beyond which a contact force event can be emitted.\n     *\n     * @param threshold - The new force threshold.\n     */\n    public setContactForceEventThreshold(threshold: number) {\n        return this.colliderSet.raw.coSetContactForceEventThreshold(\n            this.handle,\n            threshold,\n        );\n    }\n\n    /**\n     * The total force magnitude beyond which a contact force event can be emitted.\n     */\n    public contactForceEventThreshold(): number {\n        return this.colliderSet.raw.coContactForceEventThreshold(this.handle);\n    }\n\n    /**\n     * Set the collision types active for this collider.\n     *\n     * @param activeCollisionTypes - The hooks active for contact/intersection pairs involving this collider.\n     */\n    public setActiveCollisionTypes(activeCollisionTypes: ActiveCollisionTypes) {\n        this.colliderSet.raw.coSetActiveCollisionTypes(\n            this.handle,\n            activeCollisionTypes,\n        );\n    }\n\n    /**\n     * Sets the uniform density of this collider.\n     *\n     * This will override any previous mass-properties set by `this.setDensity`,\n     * `this.setMass`, `this.setMassProperties`, `ColliderDesc.density`,\n     * `ColliderDesc.mass`, or `ColliderDesc.massProperties` for this collider.\n     *\n     * The mass and angular inertia of this collider will be computed automatically based on its\n     * shape.\n     */\n    public setDensity(density: number) {\n        this.colliderSet.raw.coSetDensity(this.handle, density);\n    }\n\n    /**\n     * Sets the mass of this collider.\n     *\n     * This will override any previous mass-properties set by `this.setDensity`,\n     * `this.setMass`, `this.setMassProperties`, `ColliderDesc.density`,\n     * `ColliderDesc.mass`, or `ColliderDesc.massProperties` for this collider.\n     *\n     * The angular inertia of this collider will be computed automatically based on its shape\n     * and this mass value.\n     */\n    public setMass(mass: number) {\n        this.colliderSet.raw.coSetMass(this.handle, mass);\n    }\n\n    // #if DIM3\n    /**\n     * Sets the mass of this collider.\n     *\n     * This will override any previous mass-properties set by `this.setDensity`,\n     * `this.setMass`, `this.setMassProperties`, `ColliderDesc.density`,\n     * `ColliderDesc.mass`, or `ColliderDesc.massProperties` for this collider.\n     */\n    public setMassProperties(\n        mass: number,\n        centerOfMass: Vector,\n        principalAngularInertia: Vector,\n        angularInertiaLocalFrame: Rotation,\n    ) {\n        let rawCom = VectorOps.intoRaw(centerOfMass);\n        let rawPrincipalInertia = VectorOps.intoRaw(principalAngularInertia);\n        let rawInertiaFrame = RotationOps.intoRaw(angularInertiaLocalFrame);\n\n        this.colliderSet.raw.coSetMassProperties(\n            this.handle,\n            mass,\n            rawCom,\n            rawPrincipalInertia,\n            rawInertiaFrame,\n        );\n\n        rawCom.free();\n        rawPrincipalInertia.free();\n        rawInertiaFrame.free();\n    }\n    // #endif\n\n\n    /**\n     * Sets the translation of this collider.\n     *\n     * @param tra - The world-space position of the collider.\n     */\n    public setTranslation(tra: Vector) {\n        // #if DIM3\n        this.colliderSet.raw.coSetTranslation(this.handle, tra.x, tra.y, tra.z);\n        // #endif\n    }\n\n    /**\n     * Sets the translation of this collider relative to its parent rigid-body.\n     *\n     * Does nothing if this collider isn't attached to a rigid-body.\n     *\n     * @param tra - The new translation of the collider relative to its parent.\n     */\n    public setTranslationWrtParent(tra: Vector) {\n        // #if DIM3\n        this.colliderSet.raw.coSetTranslationWrtParent(\n            this.handle,\n            tra.x,\n            tra.y,\n            tra.z,\n        );\n        // #endif\n    }\n\n    // #if DIM3\n    /**\n     * Sets the rotation quaternion of this collider.\n     *\n     * This does nothing if a zero quaternion is provided.\n     *\n     * @param rotation - The rotation to set.\n     */\n    public setRotation(rot: Rotation) {\n        this.colliderSet.raw.coSetRotation(\n            this.handle,\n            rot.x,\n            rot.y,\n            rot.z,\n            rot.w,\n        );\n    }\n\n    /**\n     * Sets the rotation quaternion of this collider relative to its parent rigid-body.\n     *\n     * This does nothing if a zero quaternion is provided or if this collider isn't\n     * attached to a rigid-body.\n     *\n     * @param rotation - The rotation to set.\n     */\n    public setRotationWrtParent(rot: Rotation) {\n        this.colliderSet.raw.coSetRotationWrtParent(\n            this.handle,\n            rot.x,\n            rot.y,\n            rot.z,\n            rot.w,\n        );\n    }\n    // #endif\n\n    /**\n     * The type of the shape of this collider.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    public shapeType(): ShapeType {\n        return this.colliderSet.raw.coShapeType(this.handle);\n    }\n\n    /**\n     * The half-extents of this collider if it is a cuboid shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    public halfExtents(): Vector {\n        return VectorOps.fromRaw(\n            this.colliderSet.raw.coHalfExtents(this.handle),\n        );\n    }\n\n    /**\n     * Sets the half-extents of this collider if it is a cuboid shape.\n     *\n     * @param newHalfExtents - desired half extents.\n     */\n    public setHalfExtents(newHalfExtents: Vector) {\n        const rawPoint = VectorOps.intoRaw(newHalfExtents);\n        this.colliderSet.raw.coSetHalfExtents(this.handle, rawPoint);\n    }\n\n    /**\n     * The radius of this collider if it is a ball, cylinder, capsule, or cone shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    public radius(): number {\n        return this.colliderSet.raw.coRadius(this.handle);\n    }\n\n    /**\n     * Sets the radius of this collider if it is a ball, cylinder, capsule, or cone shape.\n     *\n     * @param newRadius - desired radius.\n     */\n    public setRadius(newRadius: number): void {\n        this.colliderSet.raw.coSetRadius(this.handle, newRadius);\n    }\n\n    /**\n     * The radius of the round edges of this collider if it is a round cylinder.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    public roundRadius(): number {\n        return this.colliderSet.raw.coRoundRadius(this.handle);\n    }\n\n    /**\n     * Sets the radius of the round edges of this collider if it has round edges.\n     *\n     * @param newBorderRadius - desired round edge radius.\n     */\n    public setRoundRadius(newBorderRadius: number) {\n        this.colliderSet.raw.coSetRoundRadius(this.handle, newBorderRadius);\n    }\n\n    /**\n     * The half height of this collider if it is a cylinder, capsule, or cone shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    public halfHeight(): number {\n        return this.colliderSet.raw.coHalfHeight(this.handle);\n    }\n\n    /**\n     * Sets the half height of this collider if it is a cylinder, capsule, or cone shape.\n     *\n     * @param newHalfheight - desired half height.\n     */\n    public setHalfHeight(newHalfheight: number) {\n        this.colliderSet.raw.coSetHalfHeight(this.handle, newHalfheight);\n    }\n\n    /**\n     * If this collider has a triangle mesh, polyline, convex polygon, or convex polyhedron shape,\n     * this returns the vertex buffer of said shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    public vertices(): Float32Array {\n        return this.colliderSet.raw.coVertices(this.handle);\n    }\n\n    /**\n     * If this collider has a triangle mesh, polyline, or convex polyhedron shape,\n     * this returns the index buffer of said shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    public indices(): Uint32Array | undefined {\n        return this.colliderSet.raw.coIndices(this.handle);\n    }\n\n    /**\n     * If this collider has a heightfield shape, this returns the heights buffer of\n     * the heightfield.\n     * In 3D, the returned height matrix is provided in column-major order.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    public heightfieldHeights(): Float32Array {\n        return this.colliderSet.raw.coHeightfieldHeights(this.handle);\n    }\n\n    /**\n     * If this collider has a heightfield shape, this returns the scale\n     * applied to it.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    public heightfieldScale(): Vector {\n        let scale = this.colliderSet.raw.coHeightfieldScale(this.handle);\n        return VectorOps.fromRaw(scale);\n    }\n\n    // #if DIM3\n    /**\n     * If this collider has a heightfield shape, this returns the number of\n     * rows of its height matrix.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    public heightfieldNRows(): number {\n        return this.colliderSet.raw.coHeightfieldNRows(this.handle);\n    }\n\n    /**\n     * If this collider has a heightfield shape, this returns the number of\n     * columns of its height matrix.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    public heightfieldNCols(): number {\n        return this.colliderSet.raw.coHeightfieldNCols(this.handle);\n    }\n\n    // #endif\n\n    /**\n     * The rigid-body this collider is attached to.\n     */\n    public parent(): RigidBody | null {\n        return this._parent;\n    }\n\n    /**\n     * The friction coefficient of this collider.\n     */\n    public friction(): number {\n        return this.colliderSet.raw.coFriction(this.handle);\n    }\n\n    /**\n     * The restitution coefficient of this collider.\n     */\n    public restitution(): number {\n        return this.colliderSet.raw.coRestitution(this.handle);\n    }\n\n    /**\n     * The density of this collider.\n     */\n    public density(): number {\n        return this.colliderSet.raw.coDensity(this.handle);\n    }\n\n    /**\n     * The mass of this collider.\n     */\n    public mass(): number {\n        return this.colliderSet.raw.coMass(this.handle);\n    }\n\n    /**\n     * The volume of this collider.\n     */\n    public volume(): number {\n        return this.colliderSet.raw.coVolume(this.handle);\n    }\n\n    /**\n     * The collision groups of this collider.\n     */\n    public collisionGroups(): InteractionGroups {\n        return this.colliderSet.raw.coCollisionGroups(this.handle);\n    }\n\n    /**\n     * The solver groups of this collider.\n     */\n    public solverGroups(): InteractionGroups {\n        return this.colliderSet.raw.coSolverGroups(this.handle);\n    }\n\n    /**\n     * Tests if this collider contains a point.\n     *\n     * @param point - The point to test.\n     */\n    public containsPoint(point: Vector): boolean {\n        let rawPoint = VectorOps.intoRaw(point);\n        let result = this.colliderSet.raw.coContainsPoint(\n            this.handle,\n            rawPoint,\n        );\n\n        rawPoint.free();\n\n        return result;\n    }\n\n    /**\n     * Find the projection of a point on this collider.\n     *\n     * @param point - The point to project.\n     * @param solid - If this is set to `true` then the collider shapes are considered to\n     *   be plain (if the point is located inside of a plain shape, its projection is the point\n     *   itself). If it is set to `false` the collider shapes are considered to be hollow\n     *   (if the point is located inside of an hollow shape, it is projected on the shape's\n     *   boundary).\n     */\n    public projectPoint(point: Vector, solid: boolean): PointProjection | null {\n        let rawPoint = VectorOps.intoRaw(point);\n        let result = PointProjection.fromRaw(\n            this.colliderSet.raw.coProjectPoint(this.handle, rawPoint, solid),\n        );\n\n        rawPoint.free();\n\n        return result;\n    }\n\n    /**\n     * Tests if this collider intersects the given ray.\n     *\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     */\n    public intersectsRay(ray: Ray, maxToi: number): boolean {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let result = this.colliderSet.raw.coIntersectsRay(\n            this.handle,\n            rawOrig,\n            rawDir,\n            maxToi,\n        );\n\n        rawOrig.free();\n        rawDir.free();\n\n        return result;\n    }\n\n    /*\n     * Computes the smallest time between this and the given shape under translational movement are separated by a distance smaller or equal to distance.\n     *\n     * @param collider1Vel - The constant velocity of the current shape to cast (i.e. the cast direction).\n     * @param shape2 - The shape to cast against.\n     * @param shape2Pos - The position of the second shape.\n     * @param shape2Rot - The rotation of the second shape.\n     * @param shape2Vel - The constant velocity of the second shape.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the distance traveled by the shape to `collider1Vel.norm() * maxToi`.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast won\u2019t immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that it\u2019s on a path to exist that penetration state.\n     */\n    public castShape(\n        collider1Vel: Vector,\n        shape2: Shape,\n        shape2Pos: Vector,\n        shape2Rot: Rotation,\n        shape2Vel: Vector,\n        maxToi: number,\n        stopAtPenetration: boolean,\n    ): ShapeTOI | null {\n        let rawCollider1Vel = VectorOps.intoRaw(collider1Vel);\n        let rawShape2Pos = VectorOps.intoRaw(shape2Pos);\n        let rawShape2Rot = RotationOps.intoRaw(shape2Rot);\n        let rawShape2Vel = VectorOps.intoRaw(shape2Vel);\n        let rawShape2 = shape2.intoRaw();\n\n        let result = ShapeTOI.fromRaw(\n            this.colliderSet,\n            this.colliderSet.raw.coCastShape(\n                this.handle,\n                rawCollider1Vel,\n                rawShape2,\n                rawShape2Pos,\n                rawShape2Rot,\n                rawShape2Vel,\n                maxToi,\n                stopAtPenetration,\n            ),\n        );\n\n        rawCollider1Vel.free();\n        rawShape2Pos.free();\n        rawShape2Rot.free();\n        rawShape2Vel.free();\n        rawShape2.free();\n\n        return result;\n    }\n\n    /*\n     * Computes the smallest time between this and the given collider under translational movement are separated by a distance smaller or equal to distance.\n     *\n     * @param collider1Vel - The constant velocity of the current collider to cast (i.e. the cast direction).\n     * @param collider2 - The collider to cast against.\n     * @param collider2Vel - The constant velocity of the second collider.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the distance traveled by the shape to `shapeVel.norm() * maxToi`.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast won\u2019t immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that it\u2019s on a path to exist that penetration state.\n     */\n    public castCollider(\n        collider1Vel: Vector,\n        collider2: Collider,\n        collider2Vel: Vector,\n        maxToi: number,\n        stopAtPenetration: boolean,\n    ): ShapeColliderTOI | null {\n        let rawCollider1Vel = VectorOps.intoRaw(collider1Vel);\n        let rawCollider2Vel = VectorOps.intoRaw(collider2Vel);\n\n        let result = ShapeColliderTOI.fromRaw(\n            this.colliderSet,\n            this.colliderSet.raw.coCastCollider(\n                this.handle,\n                rawCollider1Vel,\n                collider2.handle,\n                rawCollider2Vel,\n                maxToi,\n                stopAtPenetration,\n            ),\n        );\n\n        rawCollider1Vel.free();\n        rawCollider2Vel.free();\n\n        return result;\n    }\n\n    public intersectsShape(\n        shape2: Shape,\n        shapePos2: Vector,\n        shapeRot2: Rotation,\n    ): boolean {\n        let rawPos2 = VectorOps.intoRaw(shapePos2);\n        let rawRot2 = RotationOps.intoRaw(shapeRot2);\n        let rawShape2 = shape2.intoRaw();\n\n        let result = this.colliderSet.raw.coIntersectsShape(\n            this.handle,\n            rawShape2,\n            rawPos2,\n            rawRot2,\n        );\n\n        rawPos2.free();\n        rawRot2.free();\n        rawShape2.free();\n\n        return result;\n    }\n\n    /**\n     * Computes one pair of contact points between the shape owned by this collider and the given shape.\n     *\n     * @param shape2 - The second shape.\n     * @param shape2Pos - The initial position of the second shape.\n     * @param shape2Rot - The rotation of the second shape.\n     * @param prediction - The prediction value, if the shapes are separated by a distance greater than this value, test will fail.\n     * @returns `null` if the shapes are separated by a distance greater than prediction, otherwise contact details. The result is given in world-space.\n     */\n    contactShape(\n        shape2: Shape,\n        shape2Pos: Vector,\n        shape2Rot: Rotation,\n        prediction: number,\n    ): ShapeContact | null {\n        let rawPos2 = VectorOps.intoRaw(shape2Pos);\n        let rawRot2 = RotationOps.intoRaw(shape2Rot);\n        let rawShape2 = shape2.intoRaw();\n\n        let result = ShapeContact.fromRaw(\n            this.colliderSet.raw.coContactShape(\n                this.handle,\n                rawShape2,\n                rawPos2,\n                rawRot2,\n                prediction,\n            ),\n        );\n\n        rawPos2.free();\n        rawRot2.free();\n        rawShape2.free();\n\n        return result;\n    }\n\n    /**\n     * Computes one pair of contact points between the collider and the given collider.\n     *\n     * @param collider2 - The second collider.\n     * @param prediction - The prediction value, if the shapes are separated by a distance greater than this value, test will fail.\n     * @returns `null` if the shapes are separated by a distance greater than prediction, otherwise contact details. The result is given in world-space.\n     */\n    contactCollider(\n        collider2: Collider,\n        prediction: number,\n    ): ShapeContact | null {\n        let result = ShapeContact.fromRaw(\n            this.colliderSet.raw.coContactCollider(\n                this.handle,\n                collider2.handle,\n                prediction,\n            ),\n        );\n\n        return result;\n    }\n\n    /*\n     * Find the closest intersection between a ray and this collider.\n     *\n     * This also computes the normal at the hit point.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @returns The time-of-impact between this collider and the ray, or `-1` if there is no intersection.\n     */\n    public castRay(ray: Ray, maxToi: number, solid: boolean): number {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let result = this.colliderSet.raw.coCastRay(\n            this.handle,\n            rawOrig,\n            rawDir,\n            maxToi,\n            solid,\n        );\n\n        rawOrig.free();\n        rawDir.free();\n\n        return result;\n    }\n\n    /**\n     * Find the closest intersection between a ray and this collider.\n     *\n     * This also computes the normal at the hit point.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     */\n    public castRayAndGetNormal(\n        ray: Ray,\n        maxToi: number,\n        solid: boolean,\n    ): RayIntersection | null {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let result = RayIntersection.fromRaw(\n            this.colliderSet.raw.coCastRayAndGetNormal(\n                this.handle,\n                rawOrig,\n                rawDir,\n                maxToi,\n                solid,\n            ),\n        );\n\n        rawOrig.free();\n        rawDir.free();\n\n        return result;\n    }\n}\n\nexport enum MassPropsMode {\n    Density,\n    Mass,\n    MassProps,\n}\n\nexport class ColliderDesc {\n    enabled: boolean;\n    shape: Shape;\n    massPropsMode: MassPropsMode;\n    mass: number;\n    centerOfMass: Vector;\n    // #if DIM3\n    principalAngularInertia: Vector;\n    angularInertiaLocalFrame: Rotation;\n    // #endif\n    density: number;\n    friction: number;\n    restitution: number;\n    rotation: Rotation;\n    translation: Vector;\n    isSensor: boolean;\n    collisionGroups: InteractionGroups;\n    solverGroups: InteractionGroups;\n    frictionCombineRule: CoefficientCombineRule;\n    restitutionCombineRule: CoefficientCombineRule;\n    activeEvents: ActiveEvents;\n    activeHooks: ActiveHooks;\n    activeCollisionTypes: ActiveCollisionTypes;\n    contactForceEventThreshold: number;\n\n    /**\n     * Initializes a collider descriptor from the collision shape.\n     *\n     * @param shape - The shape of the collider being built.\n     */\n    constructor(shape: Shape) {\n        this.enabled = true;\n        this.shape = shape;\n        this.massPropsMode = MassPropsMode.Density;\n        this.density = 1.0;\n        this.friction = 0.5;\n        this.restitution = 0.0;\n        this.rotation = RotationOps.identity();\n        this.translation = VectorOps.zeros();\n        this.isSensor = false;\n        this.collisionGroups = 0xffff_ffff;\n        this.solverGroups = 0xffff_ffff;\n        this.frictionCombineRule = CoefficientCombineRule.Average;\n        this.restitutionCombineRule = CoefficientCombineRule.Average;\n        this.activeCollisionTypes = ActiveCollisionTypes.DEFAULT;\n        this.activeEvents = ActiveEvents.NONE;\n        this.activeHooks = ActiveHooks.NONE;\n        this.mass = 0.0;\n        this.centerOfMass = VectorOps.zeros();\n        this.contactForceEventThreshold = 0.0;\n\n        // #if DIM3\n        this.principalAngularInertia = VectorOps.zeros();\n        this.angularInertiaLocalFrame = RotationOps.identity();\n        // #endif\n    }\n\n    /**\n     * Create a new collider descriptor with a ball shape.\n     *\n     * @param radius - The radius of the ball.\n     */\n    public static ball(radius: number): ColliderDesc {\n        const shape = new Ball(radius);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Create a new collider descriptor with a capsule shape.\n     *\n     * @param halfHeight - The half-height of the capsule, along the `y` axis.\n     * @param radius - The radius of the capsule basis.\n     */\n    public static capsule(halfHeight: number, radius: number): ColliderDesc {\n        const shape = new Capsule(halfHeight, radius);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new segment shape.\n     *\n     * @param a - The first point of the segment.\n     * @param b - The second point of the segment.\n     */\n    public static segment(a: Vector, b: Vector): ColliderDesc {\n        const shape = new Segment(a, b);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new triangle shape.\n     *\n     * @param a - The first point of the triangle.\n     * @param b - The second point of the triangle.\n     * @param c - The third point of the triangle.\n     */\n    public static triangle(a: Vector, b: Vector, c: Vector): ColliderDesc {\n        const shape = new Triangle(a, b, c);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new triangle shape with round corners.\n     *\n     * @param a - The first point of the triangle.\n     * @param b - The second point of the triangle.\n     * @param c - The third point of the triangle.\n     * @param borderRadius - The radius of the borders of this triangle. In 3D,\n     *   this is also equal to half the thickness of the triangle.\n     */\n    public static roundTriangle(\n        a: Vector,\n        b: Vector,\n        c: Vector,\n        borderRadius: number,\n    ): ColliderDesc {\n        const shape = new RoundTriangle(a, b, c, borderRadius);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new collider descriptor with a polyline shape.\n     *\n     * @param vertices - The coordinates of the polyline's vertices.\n     * @param indices - The indices of the polyline's segments. If this is `undefined` or `null`,\n     *    the vertices are assumed to describe a line strip.\n     */\n    public static polyline(\n        vertices: Float32Array,\n        indices?: Uint32Array | null,\n    ): ColliderDesc {\n        const shape = new Polyline(vertices, indices);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new collider descriptor with a triangle mesh shape.\n     *\n     * @param vertices - The coordinates of the triangle mesh's vertices.\n     * @param indices - The indices of the triangle mesh's triangles.\n     */\n    public static trimesh(\n        vertices: Float32Array,\n        indices: Uint32Array,\n    ): ColliderDesc {\n        const shape = new TriMesh(vertices, indices);\n        return new ColliderDesc(shape);\n    }\n\n\n    // #if DIM3\n    /**\n     * Creates a new collider descriptor with a cuboid shape.\n     *\n     * @param hx - The half-width of the rectangle along its local `x` axis.\n     * @param hy - The half-width of the rectangle along its local `y` axis.\n     * @param hz - The half-width of the rectangle along its local `z` axis.\n     */\n    public static cuboid(hx: number, hy: number, hz: number): ColliderDesc {\n        const shape = new Cuboid(hx, hy, hz);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new collider descriptor with a rectangular shape with round borders.\n     *\n     * @param hx - The half-width of the rectangle along its local `x` axis.\n     * @param hy - The half-width of the rectangle along its local `y` axis.\n     * @param hz - The half-width of the rectangle along its local `z` axis.\n     * @param borderRadius - The radius of the cuboid's borders.\n     */\n    public static roundCuboid(\n        hx: number,\n        hy: number,\n        hz: number,\n        borderRadius: number,\n    ): ColliderDesc {\n        const shape = new RoundCuboid(hx, hy, hz, borderRadius);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new collider descriptor with a heightfield shape.\n     *\n     * @param nrows \u2212 The number of rows in the heights matrix.\n     * @param ncols - The number of columns in the heights matrix.\n     * @param heights - The heights of the heightfield along its local `y` axis,\n     *                  provided as a matrix stored in column-major order.\n     * @param scale - The scale factor applied to the heightfield.\n     */\n    public static heightfield(\n        nrows: number,\n        ncols: number,\n        heights: Float32Array,\n        scale: Vector,\n    ): ColliderDesc {\n        const shape = new Heightfield(nrows, ncols, heights, scale);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Create a new collider descriptor with a cylinder shape.\n     *\n     * @param halfHeight - The half-height of the cylinder, along the `y` axis.\n     * @param radius - The radius of the cylinder basis.\n     */\n    public static cylinder(halfHeight: number, radius: number): ColliderDesc {\n        const shape = new Cylinder(halfHeight, radius);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Create a new collider descriptor with a cylinder shape with rounded corners.\n     *\n     * @param halfHeight - The half-height of the cylinder, along the `y` axis.\n     * @param radius - The radius of the cylinder basis.\n     * @param borderRadius - The radius of the cylinder's rounded edges and vertices.\n     */\n    public static roundCylinder(\n        halfHeight: number,\n        radius: number,\n        borderRadius: number,\n    ): ColliderDesc {\n        const shape = new RoundCylinder(halfHeight, radius, borderRadius);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Create a new collider descriptor with a cone shape.\n     *\n     * @param halfHeight - The half-height of the cone, along the `y` axis.\n     * @param radius - The radius of the cone basis.\n     */\n    public static cone(halfHeight: number, radius: number): ColliderDesc {\n        const shape = new Cone(halfHeight, radius);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Create a new collider descriptor with a cone shape with rounded corners.\n     *\n     * @param halfHeight - The half-height of the cone, along the `y` axis.\n     * @param radius - The radius of the cone basis.\n     * @param borderRadius - The radius of the cone's rounded edges and vertices.\n     */\n    public static roundCone(\n        halfHeight: number,\n        radius: number,\n        borderRadius: number,\n    ): ColliderDesc {\n        const shape = new RoundCone(halfHeight, radius, borderRadius);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Computes the convex-hull of the given points and use the resulting\n     * convex polyhedron as the shape for this new collider descriptor.\n     *\n     * @param points - The point that will be used to compute the convex-hull.\n     */\n    public static convexHull(points: Float32Array): ColliderDesc | null {\n        const shape = new ConvexPolyhedron(points, null);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new collider descriptor that uses the given set of points assumed\n     * to form a convex polyline (no convex-hull computation will be done).\n     *\n     * @param vertices - The vertices of the convex polyline.\n     */\n    public static convexMesh(\n        vertices: Float32Array,\n        indices?: Uint32Array | null,\n    ): ColliderDesc | null {\n        const shape = new ConvexPolyhedron(vertices, indices);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Computes the convex-hull of the given points and use the resulting\n     * convex polyhedron as the shape for this new collider descriptor. A\n     * border is added to that convex polyhedron to give it round corners.\n     *\n     * @param points - The point that will be used to compute the convex-hull.\n     * @param borderRadius - The radius of the round border added to the convex polyhedron.\n     */\n    public static roundConvexHull(\n        points: Float32Array,\n        borderRadius: number,\n    ): ColliderDesc | null {\n        const shape = new RoundConvexPolyhedron(points, null, borderRadius);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new collider descriptor that uses the given set of points assumed\n     * to form a round convex polyline (no convex-hull computation will be done).\n     *\n     * @param vertices - The vertices of the convex polyline.\n     * @param borderRadius - The radius of the round border added to the convex polyline.\n     */\n    public static roundConvexMesh(\n        vertices: Float32Array,\n        indices: Uint32Array | null,\n        borderRadius: number,\n    ): ColliderDesc | null {\n        const shape = new RoundConvexPolyhedron(\n            vertices,\n            indices,\n            borderRadius,\n        );\n        return new ColliderDesc(shape);\n    }\n\n    // #endif\n\n\n    // #if DIM3\n    /**\n     * Sets the position of the collider to be created relative to the rigid-body it is attached to.\n     */\n    public setTranslation(x: number, y: number, z: number): ColliderDesc {\n        if (\n            typeof x != \"number\" ||\n            typeof y != \"number\" ||\n            typeof z != \"number\"\n        )\n            throw TypeError(\"The translation components must be numbers.\");\n\n        this.translation = {x: x, y: y, z: z};\n        return this;\n    }\n\n    // #endif\n\n    /**\n     * Sets the rotation of the collider to be created relative to the rigid-body it is attached to.\n     *\n     * @param rot - The rotation of the collider to be created relative to the rigid-body it is attached to.\n     */\n    public setRotation(rot: Rotation): ColliderDesc {\n        // #if DIM3\n        RotationOps.copy(this.rotation, rot);\n        // #endif\n        return this;\n    }\n\n    /**\n     * Sets whether or not the collider being created is a sensor.\n     *\n     * A sensor collider does not take part of the physics simulation, but generates\n     * proximity events.\n     *\n     * @param sensor - Set to `true` of the collider built is to be a sensor.\n     */\n    public setSensor(sensor: boolean): ColliderDesc {\n        this.isSensor = sensor;\n        return this;\n    }\n\n    /**\n     * Sets whether the created collider will be enabled or disabled.\n     * @param enabled \u2212 If set to `false` the collider will be disabled at creation.\n     */\n    public setEnabled(enabled: boolean): ColliderDesc {\n        this.enabled = enabled;\n        return this;\n    }\n\n    /**\n     * Sets the density of the collider being built.\n     *\n     * The mass and angular inertia tensor will be computed automatically based on this density and the collider\u2019s shape.\n     *\n     * @param density - The density to set, must be greater or equal to 0. A density of 0 means that this collider\n     *                  will not affect the mass or angular inertia of the rigid-body it is attached to.\n     */\n    public setDensity(density: number): ColliderDesc {\n        this.massPropsMode = MassPropsMode.Density;\n        this.density = density;\n        return this;\n    }\n\n    /**\n     * Sets the mass of the collider being built.\n     *\n     * The angular inertia tensor will be computed automatically based on this mass and the collider\u2019s shape.\n     *\n     * @param mass - The mass to set, must be greater or equal to 0.\n     */\n    public setMass(mass: number): ColliderDesc {\n        this.massPropsMode = MassPropsMode.Mass;\n        this.mass = mass;\n        return this;\n    }\n\n\n    // #if DIM3\n    /**\n     * Sets the mass properties of the collider being built.\n     *\n     * This replaces the mass-properties automatically computed from the collider's density and shape.\n     * These mass-properties will be added to the mass-properties of the rigid-body this collider will be attached to.\n     *\n     * @param mass \u2212 The mass of the collider to create.\n     * @param centerOfMass \u2212 The center-of-mass of the collider to create.\n     * @param principalAngularInertia \u2212 The initial principal angular inertia of the collider to create.\n     *                                  These are the eigenvalues of the angular inertia matrix.\n     * @param angularInertiaLocalFrame \u2212 The initial local angular inertia frame of the collider to create.\n     *                                   These are the eigenvectors of the angular inertia matrix.\n     */\n    public setMassProperties(\n        mass: number,\n        centerOfMass: Vector,\n        principalAngularInertia: Vector,\n        angularInertiaLocalFrame: Rotation,\n    ): ColliderDesc {\n        this.massPropsMode = MassPropsMode.MassProps;\n        this.mass = mass;\n        VectorOps.copy(this.centerOfMass, centerOfMass);\n        VectorOps.copy(this.principalAngularInertia, principalAngularInertia);\n        RotationOps.copy(\n            this.angularInertiaLocalFrame,\n            angularInertiaLocalFrame,\n        );\n        return this;\n    }\n    // #endif\n\n    /**\n     * Sets the restitution coefficient of the collider to be created.\n     *\n     * @param restitution - The restitution coefficient in `[0, 1]`. A value of 0 (the default) means no bouncing behavior\n     *                   while 1 means perfect bouncing (though energy may still be lost due to numerical errors of the\n     *                   constraints solver).\n     */\n    public setRestitution(restitution: number): ColliderDesc {\n        this.restitution = restitution;\n        return this;\n    }\n\n    /**\n     * Sets the friction coefficient of the collider to be created.\n     *\n     * @param friction - The friction coefficient. Must be greater or equal to 0. This is generally smaller than 1. The\n     *                   higher the coefficient, the stronger friction forces will be for contacts with the collider\n     *                   being built.\n     */\n    public setFriction(friction: number): ColliderDesc {\n        this.friction = friction;\n        return this;\n    }\n\n    /**\n     * Sets the rule used to combine the friction coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule \u2212 The combine rule to apply.\n     */\n    public setFrictionCombineRule(rule: CoefficientCombineRule): ColliderDesc {\n        this.frictionCombineRule = rule;\n        return this;\n    }\n\n    /**\n     * Sets the rule used to combine the restitution coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule \u2212 The combine rule to apply.\n     */\n    public setRestitutionCombineRule(\n        rule: CoefficientCombineRule,\n    ): ColliderDesc {\n        this.restitutionCombineRule = rule;\n        return this;\n    }\n\n    /**\n     * Sets the collision groups used by this collider.\n     *\n     * Two colliders will interact iff. their collision groups are compatible.\n     * See the documentation of `InteractionGroups` for details on teh used bit pattern.\n     *\n     * @param groups - The collision groups used for the collider being built.\n     */\n    public setCollisionGroups(groups: InteractionGroups): ColliderDesc {\n        this.collisionGroups = groups;\n        return this;\n    }\n\n    /**\n     * Sets the solver groups used by this collider.\n     *\n     * Forces between two colliders in contact will be computed iff their solver\n     * groups are compatible.\n     * See the documentation of `InteractionGroups` for details on the used bit pattern.\n     *\n     * @param groups - The solver groups used for the collider being built.\n     */\n    public setSolverGroups(groups: InteractionGroups): ColliderDesc {\n        this.solverGroups = groups;\n        return this;\n    }\n\n    /**\n     * Set the physics hooks active for this collider.\n     *\n     * Use this to enable custom filtering rules for contact/intersecstion pairs involving this collider.\n     *\n     * @param activeHooks - The hooks active for contact/intersection pairs involving this collider.\n     */\n    public setActiveHooks(activeHooks: ActiveHooks): ColliderDesc {\n        this.activeHooks = activeHooks;\n        return this;\n    }\n\n    /**\n     * Set the events active for this collider.\n     *\n     * Use this to enable contact and/or intersection event reporting for this collider.\n     *\n     * @param activeEvents - The events active for contact/intersection pairs involving this collider.\n     */\n    public setActiveEvents(activeEvents: ActiveEvents): ColliderDesc {\n        this.activeEvents = activeEvents;\n        return this;\n    }\n\n    /**\n     * Set the collision types active for this collider.\n     *\n     * @param activeCollisionTypes - The hooks active for contact/intersection pairs involving this collider.\n     */\n    public setActiveCollisionTypes(\n        activeCollisionTypes: ActiveCollisionTypes,\n    ): ColliderDesc {\n        this.activeCollisionTypes = activeCollisionTypes;\n        return this;\n    }\n\n    /**\n     * Sets the total force magnitude beyond which a contact force event can be emitted.\n     *\n     * @param threshold - The force threshold to set.\n     */\n    public setContactForceEventThreshold(threshold: number): ColliderDesc {\n        this.contactForceEventThreshold = threshold;\n        return this;\n    }\n}\n", "import {RawColliderSet} from \"../raw\";\nimport {Coarena} from \"../coarena\";\nimport {RotationOps, VectorOps} from \"../math\";\nimport {Collider, ColliderDesc, ColliderHandle} from \"./collider\";\nimport {ImpulseJointHandle, IslandManager, RigidBodyHandle} from \"../dynamics\";\nimport {RigidBodySet} from \"../dynamics\";\n\n/**\n * A set of rigid bodies that can be handled by a physics pipeline.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `colliderSet.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nexport class ColliderSet {\n    raw: RawColliderSet;\n    private map: Coarena<Collider>;\n\n    /**\n     * Release the WASM memory occupied by this collider set.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n\n        if (!!this.map) {\n            this.map.clear();\n        }\n        this.map = undefined;\n    }\n\n    constructor(raw?: RawColliderSet) {\n        this.raw = raw || new RawColliderSet();\n        this.map = new Coarena<Collider>();\n        // Initialize the map with the existing elements, if any.\n        if (raw) {\n            raw.forEachColliderHandle((handle: ColliderHandle) => {\n                this.map.set(handle, new Collider(this, handle, null));\n            });\n        }\n    }\n\n    /** @internal */\n    public castClosure<Res>(\n        f?: (collider: Collider) => Res,\n    ): (handle: ColliderHandle) => Res | undefined {\n        return (handle) => {\n            if (!!f) {\n                return f(this.get(handle));\n            } else {\n                return undefined;\n            }\n        };\n    }\n\n    /** @internal */\n    public finalizeDeserialization(bodies: RigidBodySet) {\n        this.map.forEach((collider) =>\n            collider.finalizeDeserialization(bodies),\n        );\n    }\n\n    /**\n     * Creates a new collider and return its integer handle.\n     *\n     * @param bodies - The set of bodies where the collider's parent can be found.\n     * @param desc - The collider's description.\n     * @param parentHandle - The integer handle of the rigid-body this collider is attached to.\n     */\n    public createCollider(\n        bodies: RigidBodySet,\n        desc: ColliderDesc,\n        parentHandle: RigidBodyHandle,\n    ): Collider {\n        let hasParent = parentHandle != undefined && parentHandle != null;\n\n        if (hasParent && isNaN(parentHandle))\n            throw Error(\n                \"Cannot create a collider with a parent rigid-body handle that is not a number.\",\n            );\n\n        let rawShape = desc.shape.intoRaw();\n        let rawTra = VectorOps.intoRaw(desc.translation);\n        let rawRot = RotationOps.intoRaw(desc.rotation);\n        let rawCom = VectorOps.intoRaw(desc.centerOfMass);\n\n        // #if DIM3\n        let rawPrincipalInertia = VectorOps.intoRaw(\n            desc.principalAngularInertia,\n        );\n        let rawInertiaFrame = RotationOps.intoRaw(\n            desc.angularInertiaLocalFrame,\n        );\n        // #endif\n\n        let handle = this.raw.createCollider(\n            desc.enabled,\n            rawShape,\n            rawTra,\n            rawRot,\n            desc.massPropsMode,\n            desc.mass,\n            rawCom,\n            // #if DIM3\n            rawPrincipalInertia,\n            rawInertiaFrame,\n            // #endif\n            desc.density,\n            desc.friction,\n            desc.restitution,\n            desc.frictionCombineRule,\n            desc.restitutionCombineRule,\n            desc.isSensor,\n            desc.collisionGroups,\n            desc.solverGroups,\n            desc.activeCollisionTypes,\n            desc.activeHooks,\n            desc.activeEvents,\n            desc.contactForceEventThreshold,\n            hasParent,\n            hasParent ? parentHandle : 0,\n            bodies.raw,\n        );\n\n        rawShape.free();\n        rawTra.free();\n        rawRot.free();\n        rawCom.free();\n\n        // #if DIM3\n        rawPrincipalInertia.free();\n        rawInertiaFrame.free();\n        // #endif\n\n        let parent = hasParent ? bodies.get(parentHandle) : null;\n        let collider = new Collider(this, handle, parent, desc.shape);\n        this.map.set(handle, collider);\n        return collider;\n    }\n\n    /**\n     * Remove a collider from this set.\n     *\n     * @param handle - The integer handle of the collider to remove.\n     * @param bodies - The set of rigid-body containing the rigid-body the collider is attached to.\n     * @param wakeUp - If `true`, the rigid-body the removed collider is attached to will be woken-up automatically.\n     */\n    public remove(\n        handle: ColliderHandle,\n        islands: IslandManager,\n        bodies: RigidBodySet,\n        wakeUp: boolean,\n    ) {\n        this.raw.remove(handle, islands.raw, bodies.raw, wakeUp);\n        this.unmap(handle);\n    }\n\n    /**\n     * Internal function, do not call directly.\n     * @param handle\n     */\n    public unmap(handle: ImpulseJointHandle) {\n        this.map.delete(handle);\n    }\n\n    /**\n     * Gets the rigid-body with the given handle.\n     *\n     * @param handle - The handle of the rigid-body to retrieve.\n     */\n    public get(handle: ColliderHandle): Collider | null {\n        return this.map.get(handle);\n    }\n\n    /**\n     * The number of colliders on this set.\n     */\n    public len(): number {\n        return this.map.len();\n    }\n\n    /**\n     * Does this set contain a collider with the given handle?\n     *\n     * @param handle - The collider handle to check.\n     */\n    public contains(handle: ColliderHandle): boolean {\n        return this.get(handle) != null;\n    }\n\n    /**\n     * Applies the given closure to each collider contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n    public forEach(f: (collider: Collider) => void) {\n        this.map.forEach(f);\n    }\n\n    /**\n     * Gets all colliders in the list.\n     *\n     * @returns collider list.\n     */\n    public getAll(): Collider[] {\n        return this.map.getAll();\n    }\n}\n", "import * as RAPIER from '@dimforge/rapier3d';\n\nexport class Physics {\n    constructor() {\n        this.world = new RAPIER.World({ x: 0.0, y: -9.81, z: 0.0 });\n        const world = this.world;\n        this.bodyToTransform = new Map();\n        // Create the ground\n        const groundColliderDesc = RAPIER.ColliderDesc.cuboid(10.0, 0.1, 10.0);\n        world.createCollider(groundColliderDesc);\n    }\n    update() {\n        this.world.step();\n        this.world.forEachActiveRigidBody((body) => {\n            const pos = body.translation();\n            const rot = body.rotation();\n            const mesh = this.bodyToTransform.get(body.handle);\n            mesh.position.set(pos.x, pos.y, pos.z);\n            mesh.quaternion.set(rot.x, rot.y, rot.z, rot.w);\n        });\n    }\n}\n", "export function makeButtonInList(buttonLabel, listId, callback) {\n  const li = document.createElement(\"li\");\n  const button = document.createElement(\"button\");\n  button.append(buttonLabel);\n  button.addEventListener(\"click\", callback);\n  li.append(button);\n  document.getElementById(listId).append(li);\n}\n", "#version 300 es\nin vec3 position;\n//in vec4 color;\nin vec3 normal;\n//in vec2 uv;\nuniform vec3 cameraPosition;\nuniform vec3 lightPosition[3];\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform mat4 projectionMatrix;\n\n//out vec2 vUV;\n//out vec4 vColor;\nout vec3 vNormal;\nout vec3 vSurfaceToLight[3];\nout vec3 vSurfaceToCamera;\n\nvoid main() {\n    vec3 surfaceWorldPosition = mat3(modelMatrix) * position;\n    for (int i = 0; i < 3; ++i) {\n        vSurfaceToLight[i] = lightPosition[i] - surfaceWorldPosition;\n    }\n    vSurfaceToCamera = cameraPosition - surfaceWorldPosition;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    //vColor = color;\n    vNormal = mat3(modelMatrix) * normal;\n    //v_uv = uv;\n}\n", "#version 300 es\nprecision highp float;\n//in vec2 v_uv;\n//in vec4 vColor;\nin vec3 vNormal;\nin vec3 vSurfaceToLight[3];\nin vec3 vSurfaceToCamera;\nout vec4 outColor;\n//uniform sampler2D tBaseColor;\nuniform vec3 lightColor[3];\n\nvec3 unlit() {\n    return vec3(0.1, 0.1, 0.1);\n}\n\nvoid main() {\n    vec3 viewDir = normalize(vSurfaceToCamera);\n    vec3 normal = normalize(vNormal);\n\n    vec3 lightTotal;\n    for (int i = 0; i < 3; ++i) {\n        lightTotal = lightTotal + clamp(dot(normalize(vSurfaceToLight[i]), normal), 0.0, 1.0) * lightColor[i];\n    }\n    outColor = vec4((lightTotal/2.) + 0.5, 1.0);\n}\n", "#version 300 es\nin vec3 position;\nin vec3 normal;\nin vec2 uv;\nin vec4 skinIndex;\nin vec4 skinWeight;\n\nuniform mat3 normalMatrix;\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\n\nuniform sampler2D boneTexture;\nuniform int boneTextureSize;\n\nmat4 getBoneMatrix(const in float i) {\n    float j = i * 4.0;\n    float x = mod(j, float(boneTextureSize));\n    float y = floor(j / float(boneTextureSize));\n\n    float dx = 1.0 / float(boneTextureSize);\n    float dy = 1.0 / float(boneTextureSize);\n\n    y = dy * (y + 0.5);\n\n    vec4 v1 = texture(boneTexture, vec2(dx * (x + 0.5), y));\n    vec4 v2 = texture(boneTexture, vec2(dx * (x + 1.5), y));\n    vec4 v3 = texture(boneTexture, vec2(dx * (x + 2.5), y));\n    vec4 v4 = texture(boneTexture, vec2(dx * (x + 3.5), y));\n\n    return mat4(v1, v2, v3, v4);\n}\n\nout vec2 vUv;\nout vec3 vNormal;\n\nvoid main() {\n    vUv = uv;\n    vNormal = normalize(normalMatrix * normal);\n\n    mat4 boneMatX = getBoneMatrix(skinIndex.x);\n    mat4 boneMatY = getBoneMatrix(skinIndex.y);\n    mat4 boneMatZ = getBoneMatrix(skinIndex.z);\n    mat4 boneMatW = getBoneMatrix(skinIndex.w);\n\n    // update normal\n    mat4 skinMatrix = mat4(0.0);\n    skinMatrix += skinWeight.x * boneMatX;\n    skinMatrix += skinWeight.y * boneMatY;\n    skinMatrix += skinWeight.z * boneMatZ;\n    skinMatrix += skinWeight.w * boneMatW;\n    vNormal = vec4(skinMatrix * vec4(vNormal, 0.0)).xyz;\n\n    // Update position\n    vec4 bindPos = vec4(position, 1.0);\n    vec4 transformed = vec4(0.0);\n    transformed += boneMatX * bindPos * skinWeight.x;\n    transformed += boneMatY * bindPos * skinWeight.y;\n    transformed += boneMatZ * bindPos * skinWeight.z;\n    transformed += boneMatW * bindPos * skinWeight.w;\n    vec3 pos = transformed.xyz;\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}\n", "#version 300 es\nprecision highp float;\n\nuniform sampler2D tMap;\nuniform sampler2D boneTexture;\n\nin vec2 vUv;\nin vec3 vNormal;\nout vec4 outColor;\n\nvoid main() {\n    // vec3 tex = texture2D(tMap, vUv).rgb;\n\n    // vec3 normal = normalize(vNormal);\n    // vec3 light = vec3(0.0, 1.0, 0.0);\n    // float shading = min(0.0, dot(normal, light) * 0.2);\n\n    // outColor.rgb = tex + shading;\n    // outColor.a = 1.0;\n    outColor.rgb = texture(tMap, vUv).rgb;\n    outColor.a = 1.0;\n}\n", "import { Renderer, Camera, Transform, Orbit, Program, Geometry,\n         Sphere, Mesh, Vec3, GLTFLoader, GLTFSkin, TextureLoader} from 'ogl';\nimport { SkyBox } from './skybox.js';\nimport { PhysDebugMesh } from './physdebug.js';\nimport { MessageBus } from './abstract.js';\nimport { Physics } from './physics.js';\nimport { makeButtonInList } from './ui.js';\nimport vertShader from './shaders/main.vert';\nimport fragShader from './shaders/main.frag';\nimport skinVert from './shaders/skin.vert';\nimport skinFrag from './shaders/skin.frag';\nimport physDebugVert from './shaders/physDebug.vert';\nimport physDebugFrag from './shaders/physDebug.frag';\nimport * as RAPIER from '@dimforge/rapier3d';\n\nfunction shallowClone(obj) {\n    return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));\n}\n\nfunction init() {\n    // Initialize graphics\n    const canvasElem = document.querySelector(\"#renderCanvas\");\n    const renderer = new Renderer({ dpr: 1, canvas: canvasElem, antialias: true });\n    const gl = renderer.gl;\n\n    // Orbit camera & window resize helper\n    const camera = new Camera(gl, { near: 0.1, far: 10000 });\n    const controls = new Orbit(camera, { element: canvasElem });\n    camera.position\n        .set(0, 0.5, -1)\n        .normalize()\n        .multiply(2.5)\n        .add([5, 5, -5]);\n    controls.target.copy([0, 2, 2]);\n    controls.forcePosition();\n\n    function resize() {\n        renderer.setSize(canvasElem.parentNode.clientWidth, canvasElem.parentNode.clientHeight);\n        camera.perspective({ aspect: gl.canvas.width / gl.canvas.height });\n    }\n    window.addEventListener('resize', resize, false);\n    resize();\n\n    // Initialize non-graphics things\n    const msgBus = new MessageBus();\n    const physics = new Physics();\n\n    // Main Shader\n    const lightPosition = [new Vec3(10.0, 1.0, 0.0), new Vec3(0.0, 10.0, 3.0), new Vec3(0.0, 1.0, 5.0)];\n    const lightColor = [new Vec3(0.2, 0.7, 1.0), new Vec3(1.0, 1.0, 1.0), new Vec3(0.9, 0.1, 0.2)];\n    const lightFalloff = [1.0, 0.5, 1.0];\n    const lightPenumbra = [];\n    const lightUmbra = [];\n\n    const mainProgram = new Program(gl, {\n        vertex: vertShader,\n        fragment: fragShader,\n        uniforms: {\n            cameraPosition: { value: camera.position },\n            lightPosition: { value: lightPosition },\n            lightColor: { value: lightColor },\n            lightFalloff: { value: lightFalloff },\n            lightPenumbra: { value: lightPenumbra },\n            lightUmbra: { value: lightUmbra },\n        },\n    });\n\n    function makeSkinProgram (skin) {\n        const material = skin.program.gltfMaterial;\n        console.log(\"skin: \", skin);\n        return new Program(gl, {\n            vertex: skinVert,\n            fragment: skinFrag,\n            uniforms: {\n                boneTexture:{ value: skin.boneTexture },\n                boneTextureSize: { value: skin.boneTextureSize },\n                tMap: { value: material.baseColorTexture.texture },\n            }\n        });\n    }\n\n    const sphereGeom = new Sphere(gl);\n    const rigidBodyDesc = new RAPIER.RigidBodyDesc(RAPIER.RigidBodyType.Dynamic).setTranslation(0.0, 1.0, 0.0);\n    function makeBall(position) {\n        const ball = {}\n        ball.mesh = new Mesh(gl, {geometry: sphereGeom, program: mainProgram});\n        ball.mesh.setParent(scene);\n        ball.body = physics.world.createRigidBody(rigidBodyDesc);\n        ball.coll = physics.world.createCollider(RAPIER.ColliderDesc.ball(0.5), ball.body);\n        physics.bodyToTransform.set(ball.body.handle, ball.mesh);\n        ball.body.setTranslation(position, true);\n        return ball;\n    }\n    // Initialize scene\n    const scene = new Transform();\n    const skybox = new SkyBox(gl);\n    skybox.setParent(scene);\n\n    // Setting up physics debug rendering\n    const debugMesh = new PhysDebugMesh(gl, physics.world, scene);\n\n    // Physics sausage\n    function makeCapsule(x, y, z, length, radius) {\n        const collDesc = new RAPIER.ColliderDesc(new RAPIER.Capsule(length, radius));\n        const bodyDesc = new RAPIER.RigidBodyDesc(RAPIER.RigidBodyType.Dynamic)\n                                   .setTranslation(x + Math.random() / 100, y + Math.random() / 100, z + Math.random() / 100);\n        const body = physics.world.createRigidBody(bodyDesc);\n        return {\n            body: body,\n            coll: physics.world.createCollider(collDesc, body),\n        };\n    }\n\n    function makeJoint(anchor1, anchor2, body1, body2) {\n        const params = RAPIER.JointData.generic(anchor1, anchor2,\n                                                {x: 0, y: 0, z: 1},\n                                                RAPIER.JointAxesMask.X |\n                                                RAPIER.JointAxesMask.Y |\n                                                RAPIER.JointAxesMask.Z |\n                                                RAPIER.JointAxesMask.AngZ\n                                               );\n        const joint = physics.world.createImpulseJoint(params, body1, body2, true);\n        joint.setContactsEnabled(false);\n        return joint;\n    }\n\n    // Graphics sausage\n    let skin;\n    loadAssets();\n    async function loadAssets() {\n        const gltf = await GLTFLoader.load(gl, `sausage.glb`);\n        console.log(gltf);\n        const s = gltf.scene || gltf.scenes[0];\n        s.forEach((root) => {\n            root.traverse((node) => {\n                if (node.program) {\n                    if (node instanceof GLTFSkin) {\n                        node.program = makeSkinProgram(node);\n                        skin = node;\n                    }\n                    else node.program = mainProgram;\n                }\n            });\n        });\n    }\n\n    function makeSausage(position) {\n        // this is almost a generic skin cloner\n        const sausageParent = new Transform();\n        const newSkel = {\n            joints: [],\n            inverseBindMatrices: shallowClone(skin.skeleton.inverseBindMatrices),\n        }\n        for (const bone of skin.skeleton.joints) {\n            const newBone = new Transform();\n            newBone.matrix.copy(bone.matrix);\n            newBone.decompose(); // eww, rotten bones in my sausage!\n            newBone.scale.set(0.1);\n            newBone.bindInverse = shallowClone(bone.bindInverse);\n            newBone.setParent(sausageParent);\n            newSkel.joints.push(newBone);\n        }\n\n        const newSkin = new GLTFSkin(gl, {\n            skeleton: newSkel,\n            program: skin.program,\n            geometry: skin.geometry,\n        });\n        newSkin.setParent(sausageParent);\n        console.log(newSkin, newSkel);\n\n        sausageParent.setParent(scene);\n        const s1 = makeCapsule(position.x, position.y + 0.9, position.z, 0.03, 0.215);\n        const s2 = makeCapsule(position.x, position.y + 0.6, position.z, 0.03, 0.215);\n        const s3 = makeCapsule(position.x, position.y + 0.3, position.z, 0.03, 0.215);\n        const s4 = makeCapsule(position.x, position.y, position.z, 0.03, 0.215);\n        physics.bodyToTransform.set(s1.body.handle, newSkel.joints[0]);\n        physics.bodyToTransform.set(s2.body.handle, newSkel.joints[1]);\n        physics.bodyToTransform.set(s3.body.handle, newSkel.joints[2]);\n        physics.bodyToTransform.set(s4.body.handle, newSkel.joints[3]);\n\n        makeJoint({x: 0, y: 0.15, z: 0}, {x: 0, y: -0.15, z: 0}, s1.body, s2.body);\n        makeJoint({x: 0, y: 0.15, z: 0}, {x: 0, y: -0.15, z: 0}, s2.body, s3.body);\n        makeJoint({x: 0, y: 0.15, z: 0}, {x: 0, y: -0.15, z: 0}, s3.body, s4.body);\n\n        return sausageParent;\n    }\n\n    const balls = [];\n    canvasElem.addEventListener('pointerdown', (e) => {\n        const clipSpaceX = 2.0 * (e.x / renderer.width) - 1.0;\n        const clipSpaceY =  2.0 * (1.0 - e.y / renderer.height) - 1.0;\n        const direction = new Vec3(clipSpaceX, clipSpaceY, 0.5);\n        camera.unproject(direction);\n        direction.sub(camera.position).normalize();\n        //it is COMPLETELY ACCIDENTAL that ogl Vec3's work inside Rapier\n        const ray = new RAPIER.Ray(camera.position, direction);\n        const hit = physics.world.castRayAndGetNormal(ray, 100, false);\n        if (hit != null) {\n            const hitPoint = ray.pointAt(hit.toi);\n            //to use Rapier vectors in ogl they need to be initialized with the ogl math classes\n            const hitVec = new Vec3(hitPoint.x, hitPoint.y, hitPoint.z);\n            const normal = new Vec3(hit.normal.x, hit.normal.y, hit.normal.z);\n            hitVec.add(normal.scale(0.5));\n            balls.push(makeSausage(hitVec));\n        }\n    } );\n\n    // Generic joint test\n    // const Axes = RAPIER.JointAxesMask;\n    // const collDescG1 = new RAPIER.ColliderDesc(new RAPIER.Cone(0.5, 0.5));\n    // const bodyDescG1 = new RAPIER.RigidBodyDesc(RAPIER.RigidBodyType.Dynamic).setTranslation(1, 1, 1);\n    // const bodyDescG2 = new RAPIER.RigidBodyDesc(RAPIER.RigidBodyType.Dynamic).setTranslation(1.5, 1.5, 1.5);\n    // const bodyG1 = physics.world.createRigidBody(bodyDescG1);\n    // const bodyG2 = physics.world.createRigidBody(bodyDescG2);\n    // const collG1 = physics.world.createCollider(collDescG1, bodyG1);\n    // const collG2 = physics.world.createCollider(collDescG1, bodyG2);\n    // const genParams = RAPIER.JointData.generic(\n    //     {x: 0, y: 0.5, z: 0},\n    //     {x: 0, y: -0.5, z: 0},\n    //     {x: 1, y: 0, z: 0},\n    //     Axes.X | Axes.Y | Axes.Z | Axes.AngX);\n    // const genJoint = physics.world.createImpulseJoint(genParams, bodyG1, bodyG2, true);\n\n    // Add Pause Button\n    let paused = false;\n    let requestID;\n\n    makeButtonInList(\"Pause\", \"buttonList\", () => {\n        if (paused) {\n            requestID = requestAnimationFrame(update);\n            paused = false;\n        } else {\n            cancelAnimationFrame(requestID);\n            paused = true;\n        }\n    });\n    makeButtonInList(\"Show/Hide Colliders\", \"buttonList\", () => {\n        debugMesh.toggle();\n    })\n\n    // Main Loop\n    let startTime, lastTime;\n\n    requestID = requestAnimationFrame(update);\n    function update(time) {\n        if (startTime === undefined) {\n            startTime = time;\n        }\n        const totalTime = time - startTime;\n        // if (skin) {\n        //     for (const bone of skin.skeleton.joints) {\n        //         bone.position.y = Math.sin((totalTime) / 1000 + bone.position.x * 2);\n        //     }\n        // }\n\n        //physics.world.timestep = time - lastTime;\n        //lastTime = time;\n        physics.update();\n\n        //update buffers for physics collider rendering\n        if (debugMesh.enabled) debugMesh.updateBuffers();\n\n        controls.update();\n\n        renderer.render({ scene, camera, sort: false, frustumCull: false });\n\n        requestID = requestAnimationFrame(update);\n    }\n}\n\ninit();\n"],
  "mappings": "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",
  "names": ["scale", "ID", "vertex", "fragment", "length", "tempVec3", "ID", "copy", "set", "scale", "normalize", "dot", "multiply", "dot", "copy", "set", "dot", "normalize", "set", "copy", "normalize", "multiply", "dot", "copy", "set", "identity", "invert", "multiply", "scale", "add", "subtract", "set", "scale", "add", "subtract", "multiply", "identity", "copy", "invert", "invert", "distance", "fromQuat", "copy", "set", "identity", "invert", "multiply", "translate", "rotate", "scale", "set", "translate", "rotate", "scale", "multiply", "identity", "copy", "fromQuat", "invert", "ID", "ID", "copy", "set", "add", "subtract", "multiply", "divide", "scale", "distance", "squaredDistance", "length", "squaredLength", "negate", "inverse", "normalize", "dot", "cross", "lerp", "transformMat3", "transformMat4", "exactEquals", "set", "copy", "add", "subtract", "multiply", "scale", "divide", "inverse", "length", "distance", "squaredDistance", "squaredLength", "negate", "cross", "normalize", "dot", "exactEquals", "transformMat3", "transformMat4", "lerp", "set", "copy", "normalize", "scale", "dot", "tempVec3", "distance", "angle", "size", "tempMat4", "identity", "image", "texture", "extras", "scale", "i", "physDebug_default", "physDebug_default", "instance", "angle", "distance", "scale", "module", "imports", "RigidBodyType", "scale", "handle", "JointType", "MotorModel", "JointAxesMask", "CoefficientCombineRule", "FeatureType", "scale", "ShapeType", "QueryFilterFlags", "angle", "distance", "ActiveEvents", "ActiveHooks", "SolverFlags", "ActiveCollisionTypes", "scale", "MassPropsMode", "main_default", "skin_default", "main_default", "skin", "skin_default", "length"]
}
